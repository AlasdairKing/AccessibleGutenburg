<html><head><title>AccessibleGutenberg - Tue 01 September 2009</title>
<style type="text/css">body { font-family:sans-serif; margin-left:10%; margin-right:10%; } pre { background-color:#eee; } </style>
</head>
<body>
<h1>Accessible Gutenberg 2.0.9</h1>
<p>This archive file made: Tue 01 Sep 2009</p>
<p>Date last modified: Thu 13 Aug 2009 18:32</p><!--
Type=Exe
Reference=*\G{00020430-0000-0000-C000-000000000046}#2.0#0#..\..\..\..\..\Windows\system32\stdole2.tlb#OLE Automation
Reference=*\G{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}#4.0#0#..\..\..\..\..\Windows\system32\MSHTML.TLB#Microsoft HTML Object Library
Reference=*\G{50A7E9B0-70EF-11D1-B75A-00A0C90564FE}#1.0#0#..\..\..\..\..\Windows\system32\SHELL32.dll#Microsoft Shell Controls And Automation
Reference=*\G{F935DC20-1CF0-11D0-ADB9-00C04FD58A0B}#1.0#0#..\..\..\..\..\Windows\system32\wshom.ocx#Windows Script Host Object Model
Reference=*\G{F5078F18-C551-11D3-89B9-0000F81FE221}#3.0#0#..\..\..\..\..\Windows\System32\msxml3.dll#Microsoft XML, v3.0
Reference=*\G{420B2830-E718-11CF-893D-00A0C9054228}#1.0#0#..\..\..\..\..\Windows\system32\scrrun.dll#Microsoft Scripting Runtime
Object={3B7C8863-D78F-101B-B9B5-04021C009402}#1.2#0; RICHTX32.OCX
Form=frmGutenberg.frm
Form=frmHelp.frm
Module=Globals; Globals.bas
Object={EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}#1.1#0; ieframe.dll
Form=frmBook.frm
Module=modRememberPosition; ..\Common\modRememberPosition.bas
Class=clsDownloader; ..\Common\clsDownloader.cls
Form=frmProgress.frm
Form=frmAccessing.frm
Object={F9043C88-F6F2-101A-A3C9-08002B2F49FB}#1.2#0; comdlg32.ocx
Module=modLargeFonts; ..\Common\modLargeFonts.bas
Form=..\Common\frmLargeFonts.frm
Object={6B7E6392-850A-101B-AFC0-4210102A8DA7}#1.3#0; comctl32.ocx
Module=modPath; ..\Common\modPath.bas
Module=modI18N; ..\Common\modI18N.bas
Module=modXPStyle; ..\Common\modXPStyle.bas
Module=modUpdate; ..\Common\modUpdate.bas
Module=modShared; ..\Common\modShared.bas
Module=modVersion; ..\Common\modVersion.bas
Object={831FDD16-0C5C-11D2-A9FC-0000F8754DA1}#2.0#0; mscomctl.ocx
ResFile32="AccessibleGutenberg.RES"
IconForm="frmGutenberg"
Startup="frmGutenberg"
HelpFile=""
Title="Accessible Gutenberg"
ExeName32="Gutenberg.exe"
Path32="..\Installer\Program Files\WebbIE"
Command32=""
Name="AccessibleGutenberg"
HelpContextID="0"
CompatibleMode="0"
MajorVer=2
MinorVer=0
RevisionVer=9
AutoIncrementVer=0
ServerSupportFiles=0
VersionCompanyName="WebbIE"
CompilationType=0
OptimizationType=0
FavorPentiumPro(tm)=0
CodeViewDebugInfo=0
NoAliasing=0
BoundsCheck=0
OverflowCheck=0
FlPointCheck=0
FDIVCheck=0
UnroundedFP=0
StartMode=0
Unattended=0
Retained=0
ThreadPerObject=0
MaxNumberOfThreads=1

[MS Transaction Server]
AutoRefresh=1

-->
<dl><dt>Objects</dt>
<dd>RICHTX32.OCX</dd>
<dd>ieframe.dll</dd>
<dd>comdlg32.ocx</dd>
<dd>comctl32.ocx</dd>
<dd>mscomctl.ocx</dd>
</dl>
<dl><dt>References</dt>
<dd>OLE Automation</dd>
<dd>Microsoft HTML Object Library</dd>
<dd>Microsoft Shell Controls And Automation</dd>
<dd>Windows Script Host Object Model</dd>
<dd>Microsoft XML, v3.0</dd>
<dd>Microsoft Scripting Runtime</dd>
</dl>
<p>Compiler switches: </p>
<h2>VB.Form frmGutenberg </h2>
<p>Filename: frmGutenberg.frm</p><p>Date last modified: Thu Aug 2009 18:32</p><!-- 
VERSION 5.00
Object = "{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}#1.1#0"; "ieframe.dll"
Object = "{F9043C88-F6F2-101A-A3C9-08002B2F49FB}#1.2#0"; "comdlg32.ocx"
Object = "{6B7E6392-850A-101B-AFC0-4210102A8DA7}#1.3#0"; "comctl32.ocx"
Object = "{831FDD16-0C5C-11D2-A9FC-0000F8754DA1}#2.0#0"; "mscomctl.ocx"
Begin VB.Form frmGutenberg 
   Caption         =   "Accessible Gutenberg"
   ClientHeight    =   6630
   ClientLeft      =   225
   ClientTop       =   825
   ClientWidth     =   11880
   BeginProperty Font 
      Name            =   "Tahoma"
      Size            =   12
      Charset         =   0
      Weight          =   700
      Underline       =   0   'False
      Italic          =   0   'False
      Strikethrough   =   0   'False
   EndProperty
   Icon            =   "frmGutenberg.frx":0000
   KeyPreview      =   -1  'True
   LinkTopic       =   "Form1"
   ScaleHeight     =   6630
   ScaleWidth      =   11880
   StartUpPosition =   3  'Windows Default
   Begin MSComctlLib.TreeView tvwMain 
      Height          =   2295
      Left            =   120
      TabIndex        =   1
      Top             =   480
      Width           =   4935
      _ExtentX        =   8705
      _ExtentY        =   4048
      _Version        =   393217
      Style           =   7
      Appearance      =   1
   End
   Begin SHDocVwCtl.WebBrowser mBrowser 
      Height          =   1455
      Left            =   8160
      TabIndex        =   9
      Top             =   840
      Width           =   1815
      ExtentX         =   3201
      ExtentY         =   2566
      ViewMode        =   0
      Offline         =   0
      Silent          =   0
      RegisterAsBrowser=   0
      RegisterAsDropTarget=   1
      AutoArrange     =   0   'False
      NoClientEdge    =   0   'False
      AlignLeft       =   0   'False
      NoWebView       =   0   'False
      HideFileNames   =   0   'False
      SingleClick     =   0   'False
      SingleSelection =   0   'False
      NoFolders       =   0   'False
      Transparent     =   0   'False
      ViewID          =   "{0057D0E0-3573-11CF-AE69-08002B2E1262}"
      Location        =   "http:///"
   End
   Begin VB.TextBox txtDummy 
      Height          =   495
      Left            =   9360
      TabIndex        =   8
      TabStop         =   0   'False
      Top             =   4920
      Width           =   1215
   End
   Begin ComctlLib.StatusBar staMain 
      Align           =   2  'Align Bottom
      Height          =   375
      Left            =   0
      TabIndex        =   7
      Top             =   6255
      Width           =   11880
      _ExtentX        =   20955
      _ExtentY        =   661
      Style           =   1
      SimpleText      =   ""
      _Version        =   327682
      BeginProperty Panels {0713E89E-850A-101B-AFC0-4210102A8DA7} 
         NumPanels       =   1
         BeginProperty Panel1 {0713E89F-850A-101B-AFC0-4210102A8DA7} 
            Key             =   ""
            Object.Tag             =   ""
         EndProperty
      EndProperty
   End
   Begin MSComDlg.CommonDialog cdlg 
      Left            =   5760
      Top             =   3120
      _ExtentX        =   847
      _ExtentY        =   847
      _Version        =   393216
      CancelError     =   -1  'True
   End
   Begin VB.ListBox lstBooksAuthorTitle 
      Height          =   915
      ItemData        =   "frmGutenberg.frx":0442
      Left            =   7920
      List            =   "frmGutenberg.frx":0449
      Sorted          =   -1  'True
      TabIndex        =   4
      Top             =   3120
      Width           =   3135
   End
   Begin VB.OptionButton optSort 
      Caption         =   "Sort by &title"
      Height          =   495
      Index           =   0
      Left            =   5280
      TabIndex        =   5
      Top             =   3360
      Value           =   -1  'True
      Width           =   2295
   End
   Begin VB.OptionButton optSort 
      Caption         =   "Sort by &author"
      Height          =   495
      Index           =   1
      Left            =   5160
      TabIndex        =   6
      Top             =   3720
      Width           =   2295
   End
   Begin VB.ListBox lstBooksTitleAuthor 
      Height          =   1260
      IntegralHeight  =   0   'False
      Left            =   120
      TabIndex        =   3
      Top             =   3240
      Width           =   5055
   End
   Begin VB.Timer tmrBrowser 
      Enabled         =   0   'False
      Interval        =   50
      Left            =   3120
      Top             =   1320
   End
   Begin VB.Label lblDownloaded 
      AutoSize        =   -1  'True
      Caption         =   "Downloaded &books"
      Height          =   285
      Left            =   120
      TabIndex        =   2
      Top             =   3000
      Width           =   2310
   End
   Begin VB.Label lblMain 
      AutoSize        =   -1  'True
      Caption         =   "Book &directory"
      Height          =   285
      Left            =   120
      TabIndex        =   0
      Top             =   120
      Width           =   1785
   End
   Begin VB.Menu mnuFile 
      Caption         =   "&File"
      Begin VB.Menu mnuFileOpen 
         Caption         =   "&Open"
         Shortcut        =   ^O
      End
      Begin VB.Menu mnuFileExit 
         Caption         =   "E&xit"
      End
      Begin VB.Menu mnuBar 
         Caption         =   "-"
         Visible         =   0   'False
      End
      Begin VB.Menu mnuRecent 
         Caption         =   ""
         Index           =   0
      End
   End
   Begin VB.Menu mnuEdit 
      Caption         =   "&Edit"
      Begin VB.Menu mnuCut 
         Caption         =   "Cu&t"
         Shortcut        =   ^X
      End
      Begin VB.Menu mnuCopy 
         Caption         =   "&Copy"
         Shortcut        =   ^C
      End
      Begin VB.Menu mnuPaste 
         Caption         =   "&Paste"
         Shortcut        =   ^V
      End
      Begin VB.Menu mnuEditFind 
         Caption         =   "&Find"
         Shortcut        =   ^F
      End
      Begin VB.Menu mnuEditFindnext 
         Caption         =   "Find &next"
         Shortcut        =   {F3}
      End
      Begin VB.Menu mnuSelectall 
         Caption         =   "Select &all"
         Shortcut        =   ^A
      End
   End
   Begin VB.Menu mnuView 
      Caption         =   "&View"
      Begin VB.Menu mnuViewWhat 
         Caption         =   "&Catalogue"
         Index           =   0
         Shortcut        =   ^L
      End
      Begin VB.Menu mnuViewWhat 
         Caption         =   "&Book"
         Index           =   1
         Shortcut        =   ^B
      End
      Begin VB.Menu mnuViewWhat 
         Caption         =   "&Downloaded books"
         Index           =   2
         Shortcut        =   ^D
      End
   End
   Begin VB.Menu mnuHelp 
      Caption         =   "&Help"
      Begin VB.Menu mnuHelpManual 
         Caption         =   "&Manual"
         Shortcut        =   {F1}
      End
      Begin VB.Menu mnuHelpLegal 
         Caption         =   "&Legal"
      End
      Begin VB.Menu mnuHelpAbout 
         Caption         =   "&About"
      End
   End
End
Attribute VB_Name = "frmGutenberg"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
'Program to let users access the Gutenberg catalog online with no fuss.

Option Explicit

'DEVELOPMENT
'mSection values:
'   "home"          First list of choice of author or title catalogues.
'       "authors"
'           "authors-A"
'           "authors-B"
'           ...
'       "titles"        A-Z list (leading to titles)
'   "titleList"     List of titles for a letter, e.g. B.
'   "book"          Actual book loaded
'The navigation structure looks like this:
'home
'   authors
'       authors-A
'       authors-B
'       authors-C
'   titles
'       title-A
'       title-B
'       title-C

'VERSION HISTORY
'1.0.0
'Sent to Roger to review
'1.0.1
'Added Resume Nexts to all functions
'Fixed ListIndex = 0 sets that might have confused screenreaders.
'Fixed default book
'Fixed authors who had married names from failing to display
'Changed fonts all to Tahoma (Windows XP font)
'Started (but didn't finish!) writing a caching mechanism. Turned out I didn't
'need it: I optimised the webpage processing instead.
'Released, foolishly, Jan 2007.
'1.0.2
'Fixed bug with recent list (no default installed) that made it hang.
'Fixed bug with recent list that allowed duplicate entries.
'1.0.3
'Forgot to update the default book list in the resource file, didn't I? Now
'correctly only shows installed book (Christmas Carol) on installation. Also
'deletes books that are missing from the download list, so it should correct
'previously-broken installs.
'1.0.4
'Fix for non-English language handling.
'1.0.5 1 April 2007
'Change to default langauge handling - see CLanguage.
'1.0.6 25 April 2007
'Wouldn't instantiate InternetExplorer on test machine, so changed reference
'to InternetExplorer to instance of WebBrowser on form.
'1.0.7 15 May 2007
'Updated copyright notice stripping, so it better removes Gutenberg notices.
'Added double-click handling on lists.
'Remembers and displays book currently open on Book tab.
'Fixed bug with shift and page up/down changing tab.
'Remembers the tab you were last in and displays that when opening.
'2.0.0 30 Jan 2008
'Redesigned user interface, added progress bar, message when accessing web.
'2.0.1 23 March 2008
'Fixed i18n bug.
'2.0.2 13 July 2008
'Removed almost all the Gutenberg processing, because it is too unreliable and sometimes
'produces books with no text.
'Fixed Help and Open menu items in Book view.
'Made treeview open when you click right, as well as loading children.
'2.0.3 31 August 2008
'Lets you delete books when list is sorted by author.
'2.0.4  08 Oct 2008
'   Exit while loop error handling in clsDownloader
'2.0.5 23 Mar 2009
'   Fix focus going to web browser with dummy control, hope this fixes freezing reported by Brett Hollis brett.hollis@gmail.com.
'2.0.6 25 May 2009
'   Fixed XP style being misapplied in _Activate, not _Initialize
'2.0.7 8 June 2009
'   Replaced comctl32 TreeView with one from mscomctl because the former would cause the application to crash in JAWS and Narrator.
'2.0.8 13 June 2009
'   Fixed XP Style bug.
'2.0.9 15 June 2009
'   Fixed XP Style bug AGAIN.
'   Fixed books downloading but not being given title.
'   Fixed Books not being opened when selected from Recent.

'TO DO
'Check it deletes okay, especially recent list
'Fix removal of copyright notice
'Add some more default books

Private mSection As String ' tracks the state of what is being downloaded.
Private mFind As String ' sought by user in Find dialogue
Private mRecent As DOMDocument30 ' holds the most recent files opened by the user.
Private Const MAX_RECENT_LIST As Long = 10 ' how many entries can appear in the recent list in
'   the file menu.

Private mAuthorCache() As IHTMLDocument ' cache of the author entries
Private mBookCache() As IHTMLDocument ' cache of the book entries
Private Const A As Long = 65
Private Const Z As Long = 90
Private mGettingIndex As Long ' the current Unicode value of what we're getting,
    'allowing us to index the mAuthors or gBooks cache arrays.
Private mHREFIndex As Collection 'indexes book node against href so we can get the book

Private mCache As String ' where we keep cached downloaded index pages
Private Const CACHE_ARRAY_START As Long = 97 ' Unicode "a"
Private Const CACHE_ARRAY_END As Long = 122  ' Unicode "z"

Private Const BOOK_DATA_FILE As String = "\downloadedBooks.xml"
Private Const GUTENBERG_HEADER As String = "*END*THE SMALL PRINT!"
Private Const GUTENBERG_FOOTER As String = "*** END OF THIS PROJECT GUTENBERG EBOOK"

Private gstrNoDownloadedBooks As String
Private gstrDeleteConfirm1 As String
Private gstrDeleteConfirm2 As String

Private Const Document As Integer = 0

Private Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
   (ByVal lpBuffer As String, nSize As Long) As Long

Private Declare Function URLDownloadToFile Lib "urlmon" Alias _
    "URLDownloadToFileA" (ByVal pCaller As Long, _
    ByVal szURL As String, _
    ByVal szFileName As String, _
    ByVal dwReserved As Long, _
    ByVal lpfnCB As Long) As Long

Private Sub Form_Initialize()
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
End Sub

Private Sub Form_Load()
    On Error Resume Next
    Dim i As Long
    Dim result As String
    
    'create folder for downloading books and storing data
    Call modPath.DetermineSettingsPath("WebbIE", App.title, "1") ' Make sure it keeps reading old store.
    Call modUpdate.CheckForUpdates
    Call modRememberPosition.LoadPosition(Me)
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    'Set mBrowser = New InternetExplorer
    Call Load(frmBook)
    gstrNoDownloadedBooks = modI18N.GetText("No books downloaded yet.")
    gstrDeleteConfirm1 = modI18N.GetText("Do you want to delete") & " "
    gstrDeleteConfirm2 = " " & modI18N.GetText("from your list of downloaded books?")
    'stop user tabbing to IE object
    mBrowser.TabStop = False
    mBrowser.Silent = True
    'no book loaded yet
    gLoadedIndex = -1
    'setup books file
    Call SetupBooksFile
    'setup recent file
    Call SetupRecent
    'setup directory
    Call SetupDirectory
    'load downloaded record
    Call LoadBooks
    'prepare to get book index from Gutenberg
    Set mHREFIndex = New Collection
    Call Me.Show
    'Work out book sort
    result = modPath.GetSettingIni(App.EXEName, "Downloaded", "Sort", "Title")
    If result = "Title" Then
        optSort(0).value = True
        Call optSort_Click(0)
    Else
        optSort(1).value = True
        Call optSort_Click(1)
    End If
    'display current book, if any
    result = modShared.SharedReadIniFile(modPath.settingsPath & "\" & App.title & ".ini", "State", "CurrentBookIndex")
    'Default to first book if not found but a book exists:
    If lstBooksTitleAuthor.ListCount > 0 And Len(result) = 0 Then result = "0"
    If Len(result) > 0 Then
        lstBooksTitleAuthor.ListIndex = CInt(result)
        If lstBooksTitleAuthor.ListIndex > -1 Then
            gLoadedIndex = lstBooksTitleAuthor.ListIndex
            'Call LoadSelectedBook
        End If
    End If
    'restore tab state
    Call Home
    Call tvwMain.SetFocus
    Call Load(frmProgress)
End Sub

Private Sub Home()
    On Error Resume Next
    mSection = "home"
    Set tvwMain.SelectedItem = tvwMain.Nodes(1)
    tvwMain.Nodes(2).EnsureVisible
    staMain.SimpleText = Empty
End Sub

Private Sub Form_Resize()
    On Error Resume Next
    Dim i As Long
    If Me.WindowState <> vbMinimized Then
        If Me.ScaleHeight > 2000 Then
            lblMain.Top = GAP
            tvwMain.Top = lblMain.Top + lblMain.Height + GAP
            tvwMain.Height = Me.ScaleHeight / 2 - tvwMain.Top
            lblDownloaded.Top = tvwMain.Top + tvwMain.Height + GAP
            lstBooksTitleAuthor.Top = lblDownloaded.Top + lblDownloaded.Height + GAP
            lstBooksTitleAuthor.Height = Me.ScaleHeight - optSort(0).Height - GAP - GAP - lstBooksTitleAuthor.Top - staMain.Height
            lstBooksAuthorTitle.Top = lstBooksTitleAuthor.Top
            lstBooksAuthorTitle.Height = lstBooksTitleAuthor.Height
            optSort(0).Top = Me.ScaleHeight - optSort(0).Height - GAP - staMain.Height
            optSort(1).Top = optSort(0).Top
        End If
        If Me.ScaleWidth > 2000 Then
            lblMain.Left = GAP
            tvwMain.Left = GAP
            tvwMain.Width = Me.ScaleWidth - tvwMain.Left
            lstBooksTitleAuthor.Left = GAP
            lstBooksTitleAuthor.Width = Me.ScaleWidth - lstBooksTitleAuthor.Left
            lstBooksAuthorTitle.Left = lstBooksTitleAuthor.Left
            lstBooksAuthorTitle.Width = lstBooksTitleAuthor.Width
            optSort(0).Left = GAP
            optSort(1).Left = optSort(0).Left + optSort(0).Width + GAP
        End If
    End If
    txtDummy.Left = Me.ScaleWidth + 500
    mBrowser.Left = Me.ScaleWidth + 100
End Sub

Private Sub Form_Unload(Cancel As Integer)
    On Error Resume Next
    'save downloaded books
    Call gBooks.Save(gBooks.url)
    'save sort type
    If optSort(0).value Then
        Call modPath.SaveSettingIni(App.EXEName, "Downloaded", "Sort", "Title")
    Else
        Call modPath.SaveSettingIni(App.EXEName, "Downloaded", "Sort", "Author")
    End If
    'save current book index
    Call WritePrivateProfileString("State", "CurrentBookIndex", CStr(lstBooksTitleAuthor.ListIndex), modPath.settingsPath & "\" & App.title & ".ini")
    'save position
    Call modRememberPosition.SavePosition(Me)
    'unload forms
    Call Unload(frmHelp)
    Call Unload(frmBook)
    Call Unload(frmProgress)
    Call Unload(frmAccessing)
End Sub

Private Sub lstBooksAuthorTitle_KeyDown(KeyCode As Integer, Shift As Integer)
'Delete book when list is sorted by author. 2.0.3
    On Error Resume Next
    If KeyCode = vbKeyDelete Then
        'delete downloaded book
        lstBooksTitleAuthor.ListIndex = lstBooksAuthorTitle.ItemData(lstBooksAuthorTitle.ListIndex) - 1
        Call lstBooksTitleAuthor_KeyDown(vbKeyDelete, 0)
    End If
End Sub

Private Sub lstBooksTitleAuthor_DblClick()
    On Error Resume Next
    Call lstBooksTitleAuthor_KeyPress(vbKeyReturn)
End Sub

Private Sub lstBooksTitleAuthor_GotFocus()
    On Error Resume Next
    If lstBooksTitleAuthor.ListIndex = -1 Then lstBooksTitleAuthor.ListIndex = 0
End Sub

Private Sub lstBooksTitleAuthor_KeyDown(KeyCode As Integer, Shift As Integer)
    On Error Resume Next
    Dim result As Long
    Dim old As Long
    
    If KeyCode = vbKeyDelete Then
        'delete downloaded book
        If lstBooksTitleAuthor.List(0) = gstrNoDownloadedBooks Then
            'no books to delete
            Call Beep
        Else
            'delete book
            result = MsgBox(gstrDeleteConfirm1 & lstBooksTitleAuthor.List(lstBooksTitleAuthor.ListIndex) & gstrDeleteConfirm2, vbYesNoCancel, App.title)
            If result = vbYes Then
                frmBook.rtfMain.text = Empty
                gLoadedIndex = -1
                Call RemoveRecent(gBooks.documentElement.selectNodes("book").Item(lstBooksTitleAuthor.ListIndex).selectSingleNode("filename").text)
                Call gBooks.documentElement.removeChild(gBooks.documentElement.selectNodes("book").Item(lstBooksTitleAuthor.ListIndex))
                Call gBooks.Save(gBooks.url)
                If optSort(0).value Then
                    'Sorted by title.
                    old = lstBooksTitleAuthor.ListIndex
                    Call LoadBooks
                    Call lstBooksTitleAuthor.SetFocus
                    If old > lstBooksTitleAuthor.ListCount - 1 Then old = lstBooksTitleAuthor.ListCount - 1
                    lstBooksTitleAuthor.ListIndex = old
                Else
                    'Sorted by author.
                    old = lstBooksAuthorTitle.ListIndex
                    Call LoadBooks
                    Call lstBooksAuthorTitle.SetFocus
                    If old > lstBooksAuthorTitle.ListCount - 1 Then old = lstBooksAuthorTitle.ListCount - 1
                    lstBooksAuthorTitle.ListIndex = old
                End If
            End If
        End If
    End If
End Sub

Private Sub lstBooksTitleAuthor_KeyPress(KeyAscii As Integer)
    On Error Resume Next
    If KeyAscii = vbKeyReturn Then
        'load downloaded book
        If lstBooksTitleAuthor.ListCount = 1 And gstrNoDownloadedBooks = lstBooksTitleAuthor.List(0) Then
            'no books!
            Call Beep
        Else
            'downloaded, open
            gLoadedIndex = lstBooksTitleAuthor.ListIndex
            Call LoadSelectedBook
        End If
    End If
End Sub

Private Sub LoadSelectedBook(Optional id As String)
    On Error Resume Next
    Dim Path As String
    Dim cursor As Long
    Dim index As Long
    Dim book As IXMLDOMNode
    Dim name As String
    Dim filename As String
    
    If id = Empty Then
        If lstBooksTitleAuthor.Visible Then
            index = lstBooksTitleAuthor.ListIndex
        Else
            index = lstBooksAuthorTitle.ListIndex
        End If
        If index >= 0 Then
            Set book = gBooks.documentElement.selectNodes("book").Item(index)
        End If
    Else
        Set book = gBooks.documentElement.selectSingleNode("book[@id='" & id & "']")
    End If
    If Not (book Is Nothing) Then
        If frmBook.rtfMain.filename <> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
        Call frmBook.rtfMain.LoadFile(modPath.nonRoamingSettingsPath & "\" & book.selectSingleNode("filename").text)
        Call AddRecent(book.selectSingleNode("title").text, book.selectSingleNode("filename").text)
        cursor = book.selectSingleNode("cursorPos").text
        If cursor > 0 Then
            frmBook.rtfMain.SelStart = cursor
        End If
        Call frmBook.Show(vbModal, Me)
    End If
End Sub

Public Sub mnuFileOpen_Click()
    On Error Resume Next
    Dim name As String
    Dim author As String
    Dim s As String
    Dim fso As New Scripting.FileSystemObject
    Dim entry As Integer
    
    cdlg.Flags = cdlOFNFileMustExist + cdlOFNPathMustExist
    cdlg.DefaultExt = "txt"
    cdlg.CancelError = True
    cdlg.DialogTitle = "Open document"
    cdlg.Filter = "Documents|*.txt;*.doc;*.rtf;*.text"
    On Error GoTo CancelError:
    cdlg.ShowOpen
    On Error Resume Next
    If cdlg.filename <> "" Then
        name = InputBox("Name of document:")
        author = InputBox("Author:")
        If Len(name) = 0 Then
            name = cdlg.filename
            If InStr(1, name, "\") > 0 Then
                name = Right(name, Len(name) - InStrRev(name, "\", Len(name)))
            End If
            If InStr(1, name, ".") > 0 Then
                name = Left(name, Len(name) - InStr(1, name, ".") - 1)
            End If
        End If
        If Len(author) = 0 Then
            s = String(256, Chr(0))
            Call GetUserName(s, Len(s))
            author = Left(s, InStr(1, s, Chr(0)))
        End If
        If frmBook.rtfMain.filename <> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
        Call frmBook.rtfMain.LoadFile(cdlg.filename)
        'Trim path to just filename
        entry = AddToBooks(name, fso.GetFile(cdlg.filename).name, author, Globals.GetUniqueKey)
        Call AddRecent(name, cdlg.filename)
    End If
CancelError:
End Sub

Public Sub mnuViewWhat_Click(index As Integer)
    On Error Resume Next
    Select Case index
        Case 0 ' catalogue
            Call tvwMain.SetFocus
        Case 1 ' book
            Call LoadSelectedBook
        Case 2 ' downloaded book list
            If lstBooksAuthorTitle.Enabled Then
                Call lstBooksAuthorTitle.SetFocus
            Else
                Call lstBooksTitleAuthor.SetFocus
            End If
    End Select
End Sub

Private Sub tvwmain_DblClick()
    On Error Resume Next
    Call tvwMain_KeyPress(vbKeyReturn)
End Sub

Private Sub lstBooksAuthorTitle_DblClick()
    On Error Resume Next
    Call lstBooksAuthorTitle_KeyPress(vbKeyReturn)
End Sub

Private Sub lstBooksAuthorTitle_GotFocus()
    On Error Resume Next
    If lstBooksAuthorTitle.ListIndex = -1 Then lstBooksAuthorTitle.ListIndex = 0
End Sub

Private Sub lstBooksAuthorTitle_KeyPress(KeyAscii As Integer)
    On Error Resume Next
    If KeyAscii = vbKeyReturn Then
        'need to call lstBooksTitleAuthor with correct index: stored in ItemData
        lstBooksTitleAuthor.ListIndex = lstBooksAuthorTitle.ItemData(lstBooksAuthorTitle.ListIndex) - 1
        Call lstBooksTitleAuthor_KeyPress(vbKeyReturn)
    End If
End Sub

Private Sub mBrowser_DocumentComplete(ByVal pDisp As Object, url As Variant)
    On Error Resume Next
    Dim elementIterator As IHTMLElement
    Dim filename As String
    Dim Path As String
    Dim slash As Long
    Dim notice As Long
    Dim text As String
    Dim href As String

'    Debug.Print "url:" & url
    If url = "http:///" Or url = "" Then
    Else
        Select Case mSection
            Case "book"
                'get book
                For Each elementIterator In pDisp.Document.getElementsByTagName("A")
                    filename = elementIterator.getAttribute("href")
                    Path = elementIterator.getAttribute("href")
                    If InStr(1, filename, ".txt", vbTextCompare) > 0 Then
                        'get the filename by parsing href
                        slash = InStrRev(filename, "/", Len(filename))
                        filename = Right(filename, Len(filename) - slash)
                        'filename = Left(filename, InStrRev(filename, "/", Len(filename)))
                        'work out title/author
                        Call frmAccessing.Hide
                        Call frmProgress.SetDownload(Path, modPath.nonRoamingSettingsPath & "\" & filename, tvwMain.SelectedItem.text)
                        Call frmProgress.Show(vbModal, Me)
                        Exit For
                    End If
                Next elementIterator
            Case Else
                'Debug.Print "Loading the cat here"
                'what have I just got?
                'Debug.Print "Got a document: current state is: " & mSection & vbNewLine & "mGettingIndex is:" & mGettingIndex
                'show contents
                Call DisplayCatalogue(mBrowser.Document)
                Call frmAccessing.Hide
        End Select
    End If
End Sub

Public Sub BookDownloaded(filename As String, url As String)
    On Error Resume Next
    Dim text As String
    Dim author As String
    Dim notice As String
    Dim n As Node
    Dim fso As New Scripting.FileSystemObject
    Dim title As String
    
'    Set n = tvwMain.SelectedItem
    'Debug.Print "Text:" & n.text
    'title = n.text
    title = tvwMain.SelectedItem
    'Debug.Print "Key:" & n.key
    'Set n = n.Parent
    'Debug.Print "Parent:" & n.text
    author = tvwMain.SelectedItem.Parent
    'Add to downloaded books
    gLoadedIndex = AddToBooks(title, fso.GetFile(filename).name, author, gLoadingID)
    If frmBook.rtfMain.filename <> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
    Call frmBook.rtfMain.LoadFile(filename)
    Call AddRecent(title, filename)
    'No longer try to strip out Gutenberg stuff: it's too unreliable, sometimes we lose the whole book.
    'The user will just have to find the start themselves.
    'Still process the newlines, though.
'    'trim out the gutenberg stuff
    text = frmBook.rtfMain.text
'    'header:
'    notice = InStr(1, text, GUTENBERG_HEADER, vbTextCompare)
'    If notice > 0 Then
'        notice = InStr(notice, text, vbNewLine, vbTextCompare)
'        text = Right(text, Len(text) - notice + 1)
'    Else
'        'hmm, didn't find header. Maybe different format.
'        notice = InStr(1, text, vbNewLine & vbNewLine & vbNewLine & vbNewLine & vbNewLine & vbNewLine, vbBinaryCompare)
'        If notice > 0 Then
'            'six newlines: that's probably the header
'            notice = notice + Len(vbNewLine) * 6
'            text = Right(text, Len(text) - notice + 1)
'        End If
'    End If
'    text = Trim(text)
'    While Left(text, Len(vbNewLine)) = vbNewLine And Len(text) > 0
'        text = Right(text, Len(text) - Len(vbNewLine))
'    Wend
'    'footer:
'    notice = InStr(1, text, GUTENBERG_FOOTER, vbTextCompare)
'    If notice > 0 Then
'        text = Left(text, notice)
'    End If
'    text = Trim(text)
'    While Left(text, Len(vbNewLine)) = vbNewLine
'        text = Right(text, Len(text) - Len(vbNewLine))
'    Wend
    'take out the extraneous newlines
    text = Replace(text, vbNewLine & vbNewLine, "jkjkjkjkjjkjkjk")
    text = Replace(text, vbNewLine, " ")
    text = Replace(text, "  ", " ")
    text = Replace(text, "jkjkjkjkjjkjkjk", vbNewLine & vbNewLine)
    frmBook.rtfMain.text = text
    Call frmBook.rtfMain.SaveFile(filename)
    staMain.SimpleText = Empty
    Call LoadSelectedBook
End Sub

Private Sub DisplayCatalogue(doc As IHTMLDocument)
'Load entries from the page and put in main list.
    On Error Resume Next
    Dim elementIterator As IHTMLElement
    Dim listcat As String
    Dim publications As IHTMLElement
    Dim book As IHTMLElement
    Dim newKey As String
    Dim newKey2 As String
    Dim childA As IHTMLElement
    Dim foundBook As Boolean
    Dim author As IHTMLElement
    
    staMain.SimpleText = "Loading catalogue - please wait"
    tvwMain.Visible = False
    'Call modShared.LockWindowUpdate(tvwMain.hwnd)
    For Each elementIterator In doc.getElementsByTagName("H2")
        newKey = Globals.GetUniqueKey '"item-" & elementIterator.innerText
        Call tvwMain.Nodes.Add(tvwMain.SelectedItem.key, tvwChild, newKey, Replace(elementIterator.innerText, vbNewLine, " "))
        Set publications = elementIterator.nextSibling
        foundBook = False
        If mSection = "authorList" Then
            For Each book In publications.children
                If book.tagName = "LI" Then
                    If book.className = "pgdbetext" Then
                        'Got an etext to add to this author.
                        newKey2 = Globals.GetUniqueKey
                        Call tvwMain.Nodes.Add(newKey, tvwChild, newKey2, Replace(book.innerText, vbNewLine, " "))
                        For Each childA In book.children
                            If childA.tagName = "A" Then
                                foundBook = True
                                Call mHREFIndex.Add(childA.getAttribute("href"), newKey2)
                                Exit For
                            End If
                        Next childA
                    End If
                End If
            Next book
        ElseIf mSection = "titleList" Then
            Call mHREFIndex.Add(elementIterator.children(0).getAttribute("href"), newKey)
            Set author = elementIterator.nextSibling
            tvwMain.Nodes.Item(newKey).text = tvwMain.Nodes.Item(newKey).text & " " & author.innerText
            foundBook = True
        End If
        If Not foundBook Then
            'didn't find a book link, remove the treeview node
            Call tvwMain.Nodes.Remove(newKey)
        End If
    Next elementIterator
    'Open the current author/item.
    Call tvwMain.SelectedItem.Child.EnsureVisible
    'Call modShared.LockWindowUpdate(0)
    tvwMain.Visible = True
    staMain.SimpleText = Empty
    Call tvwMain.SetFocus
End Sub

Private Sub mBrowser_StatusTextChange(ByVal text As String)
    On Error Resume Next
    staMain.SimpleText = text
End Sub

Private Sub mnuCopy_Click()
    On Error Resume Next
    Call SendKeys("^C")
End Sub

Private Sub mnuCut_Click()
    On Error Resume Next
    Call SendKeys("^X")
End Sub

Private Sub mnuEditFind_Click()
    On Error Resume Next
    Dim newSearch As String
    
    newSearch = InputBox("Find what:", "Find", mFind)
    If Len(newSearch) > 0 Then
        mFind = newSearch
        Call Find(mFind)
    End If
End Sub

Private Sub Find(what As String)
    On Error Resume Next
    Dim searchList As ListBox
    Dim start As Long
    Dim i As Long
    Dim found As Boolean

    If Len(what) > 0 Then
        mFind = what
        'Debug.Print "Name:" & Me.ActiveControl.Name
        Select Case Me.ActiveControl.name
            Case Me.tvwMain.name
                Call FindInTree(tvwMain, what)
            Case lstBooksTitleAuthor.name
                Call FindInList(lstBooksTitleAuthor, what)
            Case Me.lstBooksAuthorTitle.name
                Call FindInList(lstBooksAuthorTitle, what)
        End Select
    End If
End Sub

Private Sub FindInTree(t As TreeView, what As String)
    On Error Resume Next
    Dim i As Long
    Dim keepLooking As Boolean
    Dim found As Node
    
    i = t.SelectedItem.index + 1
    keepLooking = (i <= t.Nodes.Count) ' don't search current item.
    While keepLooking
        If InStr(1, t.Nodes.Item(i), what, vbTextCompare) > 0 Then
            keepLooking = False
            Set found = t.Nodes.Item(i)
        Else
            If i = t.Nodes.Count Then
                keepLooking = False
            Else
                i = i + 1
            End If
        End If
    Wend
    If found Is Nothing Then
        'didn't find, search again from the top.
        keepLooking = True
        i = 1
        While keepLooking
            If InStr(1, t.Nodes.Item(i), what, vbTextCompare) > 0 Then
                keepLooking = False
                Set found = t.Nodes.Item(i)
            Else
                If i = t.SelectedItem.index Then
                    keepLooking = False
                Else
                    i = i + 1
                End If
            End If
        Wend
    End If
    If found Is Nothing Then
        'failed to find
    Else
        'found matching text
        Set tvwMain.SelectedItem = found
    End If
End Sub

Private Sub FindInList(l As ListBox, what As String)
    On Error Resume Next
    Dim found As Boolean
    Dim start As Long
    Dim i As Long
    
    start = l.ListIndex
    For i = l.ListIndex + 1 To l.ListCount - 1
        If InStr(1, l.List(i), what, vbTextCompare) > 0 Then
            l.ListIndex = i
            found = True
            Exit For
        End If
    Next i
    If Not found Then
        For i = 0 To l.ListIndex - 1
            If InStr(1, l.List(i), what, vbTextCompare) > 0 Then
                l.ListIndex = i
                found = True
                Exit For
            End If
        Next i
    End If
    If found Then
        'okay!
    Else
        Call Beep
    End If
    Call l.SetFocus
End Sub


Private Sub mnuEditFindnext_Click()
    On Error Resume Next
    Call Find(mFind)
End Sub

Private Sub mnuFileExit_Click()
    On Error Resume Next
    Call Unload(Me)
End Sub

Public Sub mnuHelpAbout_Click()
    On Error Resume Next
    Call MsgBox(App.title & " " & App.Major & "." & App.Minor & "." & App.Revision & vbNewLine & "WebbIE Suite " & modVersion.GetPackageVersion & vbNewLine & "Alasdair King http://www.webbie.org.uk", vbInformation, App.title)
End Sub


Public Sub mnuHelpLegal_Click()
    On Error Resume Next
    Call frmHelp.ShowLegal
    Call frmHelp.Show(vbModeless, Me)
End Sub

Public Sub mnuHelpManual_Click()
    On Error Resume Next
    Call frmHelp.ShowHelp
    Call frmHelp.Show(vbModeless, Me)
End Sub

Private Sub mnuPaste_Click()
    On Error Resume Next
    Call SendKeys("^V")
End Sub

Private Sub mnuRecent_Click(index As Integer)
    On Error Resume Next
    Dim Path As String
    Dim caption As String
    'load downloaded book
    If frmBook.rtfMain.filename <> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
    Path = modPath.nonRoamingSettingsPath & "\" & mRecent.documentElement.selectNodes("recent").Item(index).selectSingleNode("filename").text
    Call frmBook.rtfMain.LoadFile(Path)
    caption = GetText("frmBook.Caption")
    If caption <> "frmBook.Caption" Then
        frmBook.caption = caption & " - " & mRecent.documentElement.selectNodes("recent").Item(index).selectSingleNode("name").text
    End If
    Call frmBook.Show(vbModal, Me)
End Sub

Private Sub mnuSelectall_Click()
    On Error Resume Next
    frmBook.rtfMain.SelStart = 1
    frmBook.rtfMain.SelLength = Len(frmBook.rtfMain.text)
End Sub

Private Sub mBrowser_GotFocus()
    On Error Resume Next
    'Need to put in dummy controls in case of known Microsoft bug breaking MSAA.
    Call Me.txtDummy.SetFocus
    'Call Me.tvwMain.SetFocus
End Sub

Private Sub optSort_Click(index As Integer)
    On Error Resume Next
    If index = 0 Then
        lstBooksTitleAuthor.Enabled = True
        Call lstBooksTitleAuthor.ZOrder
        Call lstBooksTitleAuthor.SetFocus
        lstBooksAuthorTitle.Enabled = False
    Else
        lstBooksAuthorTitle.Enabled = True
        Call lstBooksAuthorTitle.ZOrder
        Call lstBooksAuthorTitle.SetFocus
        lstBooksTitleAuthor.Enabled = False
    End If
End Sub

Private Sub DisplayDownloaded()
    On Error Resume Next
    Call lstBooksTitleAuthor.ZOrder
    Call lstBooksTitleAuthor.SetFocus
End Sub

Private Sub LoadBooks()
'load the reference file describing the books already downloaded
    On Error Resume Next
    Dim bookIterator As IXMLDOMNode
    Dim i As Long
    Dim counter
    Dim fso As FileSystemObject
    
    Set gBooks = New DOMDocument30
    gBooks.async = False
    Call gBooks.Load(modPath.nonRoamingSettingsPath & BOOK_DATA_FILE)
    Call lstBooksTitleAuthor.Clear
    Call lstBooksAuthorTitle.Clear
    Set fso = New FileSystemObject
    For Each bookIterator In gBooks.documentElement.selectNodes("book")
        'check this book is actually there: need to do this because I cocked
        'up the default file once, so I need to edit the book list if one
        'of them is missing
        If fso.FileExists(modPath.nonRoamingSettingsPath & "\" & bookIterator.selectSingleNode("filename").text) Then
            Call lstBooksTitleAuthor.AddItem(bookIterator.selectSingleNode("title").text & " - " & bookIterator.selectSingleNode("author").text)
            Call lstBooksAuthorTitle.AddItem(bookIterator.selectSingleNode("author").text & " - " & bookIterator.selectSingleNode("title").text)
            For i = 0 To lstBooksAuthorTitle.ListCount - 1
                If lstBooksAuthorTitle.ItemData(i) = 0 Then
                    'just added
                    Exit For
                End If
            Next i
            lstBooksAuthorTitle.ItemData(i) = lstBooksTitleAuthor.ListCount
        Else
            'Book isn't actually downloaded: need to delete from book list
            Call gBooks.documentElement.removeChild(bookIterator)
        End If
    Next bookIterator
    If lstBooksTitleAuthor.ListCount = 0 Then
        Call lstBooksTitleAuthor.AddItem(gstrNoDownloadedBooks)
    End If
    If lstBooksAuthorTitle.ListCount = 0 Then
        Call lstBooksAuthorTitle.AddItem(gstrNoDownloadedBooks)
    End If
    'Don't set ListIndex unless you mean a screenreader to change focus
    'to that list
    'lstBooksAuthorTitle.ListIndex = 0
    'lstBooksTitleAuthor.ListIndex = 0
End Sub

Private Sub SetupBooksFile()
    On Error Resume Next
    Dim fso As FileSystemObject
    Dim ts As TextStream
    Dim b() As Byte
    Dim text As String
    
    Set fso = New FileSystemObject
    If fso.FileExists(modPath.nonRoamingSettingsPath & BOOK_DATA_FILE) Then
        'okay!
    Else
        'no books file: copy default from resource file
        b() = VB.LoadResData("EN", "BOOKDATAFILES")
        text = StrConv(b(), vbUnicode)
        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & BOOK_DATA_FILE, ForWriting, True)
        Call ts.write(text)
        Call ts.Close
        'hard code this stuff for the time being!
        b() = VB.LoadResData("EN1", "BOOKDATAFILES")
        text = StrConv(b(), vbUnicode)
        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\46-8.txt", ForWriting, True)
        Call ts.write(text)
        Call ts.Close
'       DEV: This makes 6MB of installer, so pulled them out. Only do Christmas Carol.
'        b() = VB.LoadResData("EN2", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\alice30.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN3", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\dracu13.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN4", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\frank15.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN5", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\janey11.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN6", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\lwmen13.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN7", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\olivr11.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN8", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\pandp12.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
'        b() = VB.LoadResData("EN9", "BOOKDATAFILES")
'        text = StrConv(b(), vbUnicode)
'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\tarzn10.txt", ForWriting, True)
'        Call ts.write(text)
'        Call ts.Close
'
    End If
End Sub

Private Function AddToBooks(title As String, filename As String, author As String, id As String) As Integer
    On Error Resume Next
    'add a book to the saved book list and return where it was placed (0-based)
    Dim book As IXMLDOMNode
    Dim added As Boolean
    Dim newNode As IXMLDOMNode
    
    
    Set newNode = gBooks.createNode(NODE_ELEMENT, "book", Empty)
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "title", Empty))
    newNode.selectSingleNode("title").text = title
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "filename", Empty))
    newNode.selectSingleNode("filename").text = filename
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "author", Empty))
    newNode.selectSingleNode("author").text = author
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "cursorPos", Empty))
    newNode.selectSingleNode("cursorPos").text = "1"
    Call newNode.Attributes.setNamedItem(gBooks.createNode(NODE_ATTRIBUTE, "id", Empty))
    newNode.Attributes.getNamedItem("id").text = id
    AddToBooks = 0
    'trim title: appears to gain an extra space at times
    title = Trim(title)
    For Each book In gBooks.documentElement.selectNodes("book")
        'Debug.Print "comparing title=[" & title & "]" & vbNewLine & " with node=[" & book.selectSingleNode("title").text & "]"
        If StrComp(book.selectSingleNode("title").text, title, vbTextCompare) = 0 Then
            'found it already in there!
            Debug.Print "Found already"
            added = True
            Exit For
        ElseIf StrComp(book.selectSingleNode("title").text, title, vbTextCompare) > 0 Then
            added = True
            Debug.Print "Added new"
            Call gBooks.documentElement.insertBefore(newNode, book)
            Exit For
        End If
        AddToBooks = AddToBooks + 1
    Next book
    If Not added Then
        Call gBooks.documentElement.appendChild(newNode)
    End If
    Call gBooks.Save(gBooks.url)
    Call LoadBooks
End Function

Private Sub SetupRecent()
    On Error Resume Next
    Dim fso As FileSystemObject
    Dim b() As Byte
    Dim ts As TextStream
    
    Set fso = New FileSystemObject
    If Not fso.FileExists(modPath.nonRoamingSettingsPath & "\recent.xml") Then
        b() = VB.LoadResData("COMMON", "RECENT")
        Set ts = fso.CreateTextFile(modPath.nonRoamingSettingsPath & "\recent.xml", True)
        Call ts.write(StrConv(b(), vbUnicode))
        Call ts.Close
    End If
    Set mRecent = New DOMDocument30
    mRecent.async = False
    
    Call mRecent.Load(modPath.nonRoamingSettingsPath & "\recent.xml")
    Call DisplayRecent
End Sub

Private Sub DisplayRecent()
    On Error Resume Next
    Dim recentIterator As IXMLDOMNode
    Dim i As Long
    
    'clear recent
    For i = mnuRecent.UBound To 1 Step -1
        Call Unload(mnuRecent(i))
    Next i
    mnuRecent(0).Visible = False
    'load new
    i = 0
    'Debug.Print "mRecent" & vbNewLine & mRecent.xml
    For Each recentIterator In mRecent.documentElement.selectNodes("recent")
        i = i + 1
        If i - 1 > mnuRecent.UBound Then
            Call Load(mnuRecent(i - 1))
        End If
        mnuRecent(i - 1).Visible = True
    Next recentIterator
    i = 0
    For Each recentIterator In mRecent.documentElement.selectNodes("recent")
        'Debug.Print "RX" & recentIterator.xml
        mnuRecent(i).caption = "&" & (i + 1) & " " & recentIterator.selectSingleNode("name").text
        i = i + 1
    Next recentIterator
    mnuBar.Visible = mnuRecent(0).Visible
End Sub

Private Sub AddRecent(name As String, filename As String)
    On Error Resume Next
    Dim newNode As IXMLDOMNode
    Dim nodeIterator As IXMLDOMNode
    Dim needsToBeAdded As Boolean
    
    'first see if we already have the filename
    needsToBeAdded = True
    
    For Each nodeIterator In mRecent.documentElement.selectNodes("recent")
        If nodeIterator.selectSingleNode("filename").text = filename Then
            'we already have this in the recent list: rest easy
            needsToBeAdded = False
            Exit For
        End If
    Next nodeIterator
    'okay, is this something new to add?
    If needsToBeAdded Then
        'yes, it is!
        Set newNode = mRecent.createNode(NODE_ELEMENT, "recent", "")
        Call newNode.appendChild(mRecent.createNode(NODE_ELEMENT, "name", ""))
        newNode.selectSingleNode("name").text = name
        Call newNode.appendChild(mRecent.createNode(NODE_ELEMENT, "filename", ""))
        newNode.selectSingleNode("filename").text = filename
        'add to beginning
        Call mRecent.documentElement.insertBefore(newNode, mRecent.documentElement.selectNodes("recent").Item(0))
        'remove last one if > MAX_RECENT_LIST
        If mRecent.documentElement.selectNodes("recent").length > MAX_RECENT_LIST Then
            Call mRecent.documentElement.removeChild(mRecent.documentElement.selectNodes("recent").Item(5))
        End If
        'save amended file
        Call mRecent.Save(modPath.nonRoamingSettingsPath & "\recent.xml")
        'show list
    End If
    Call DisplayRecent
End Sub

Private Sub RemoveRecent(filename As String)
    On Error Resume Next
'removes an item from the recent list because it's been deleted
    Dim recentIterator As IXMLDOMNode
    
    For Each recentIterator In mRecent.documentElement.selectNodes("recent")
        If recentIterator.selectSingleNode("filename").text = filename Then
            'remove node
            Call mRecent.documentElement.removeChild(recentIterator)
            Call mRecent.Save(mRecent.url)
            Call DisplayRecent
            Exit For
        End If
    Next recentIterator
End Sub

Private Sub SetupDirectory()
    On Error Resume Next
    Dim i As Integer
    Call tvwMain.Nodes.Clear
    Call tvwMain.Nodes.Add(, , "home", "Gutenberg Directory")
    Call tvwMain.Nodes.Add("home", tvwChild, "authors", "Books by Author")
    Call tvwMain.Nodes.Add("home", tvwChild, "titles", "Books by Title")
    For i = vbKeyA To vbKeyZ
        Call tvwMain.Nodes.Add("authors", tvwChild, "authors-" & Chr(i), Chr(i))
        Call tvwMain.Nodes.Add("titles", tvwChild, "titles-" & Chr(i), Chr(i))
    Next i
End Sub

Private Sub tvwMain_KeyDown(KeyCode As Integer, Shift As Integer)
    On Error Resume Next
    If KeyCode = vbKeyRight Then
        If tvwMain.SelectedItem.children Then
            'already got this node
        Else
            KeyCode = 0
            Call tvwMain_KeyPress(vbKeyReturn)
        End If
    End If
End Sub

Private Sub tvwMain_KeyPress(KeyAscii As Integer)
    On Error Resume Next
    Dim href As String
    
    'This is where the main downloading activity is initiated.
    If KeyAscii = vbKeyReturn Then
        KeyAscii = 0
        If tvwMain.SelectedItem.children Then
            'already got this node - it's a container node.
        Else
            If InStr(1, tvwMain.SelectedItem.key, "authors-") > 0 Then
                'one of the author nodes
                staMain.SimpleText = "Getting list of authors..."
                'record which index letter we need.
                mGettingIndex = AscW(LCase(tvwMain.SelectedItem.text))
                mSection = "authorList"
                'load from Gutenberg: see DocumentComplete for processing
                Call frmAccessing.Show
                Call mBrowser.navigate("http://www.gutenberg.org/browse/authors/" & LCase(tvwMain.SelectedItem.text))
            ElseIf InStr(1, tvwMain.SelectedItem.key, "titles-") > 0 Then
                'one of the title nodes
                staMain.SimpleText = "Getting list of titles..."
                'record which index letter we need.
                mGettingIndex = AscW(LCase(tvwMain.SelectedItem.text))
                mSection = "titleList"
                'load from Gutenberg: see DocumentComplete for processing
                Call frmAccessing.Show
                Call mBrowser.navigate("http://www.gutenberg.org/browse/titles/" & LCase(tvwMain.SelectedItem.text))
            Else
                'got a book to download. Have we downloaded this already?
                href = mHREFIndex.Item(tvwMain.SelectedItem.key)
                gLoadingID = Right(href, Len(href) - InStrRev(href, "/"))
                If gBooks.documentElement.selectNodes("book[@id=""" & gLoadingID & """]").length > 0 Then
                    'we've already downloaded this
                    Call LoadSelectedBook(gLoadingID)
                Else
                    'download
                    mSection = "book"
                    Call frmAccessing.Show
                    Call mBrowser.Navigate2(mHREFIndex.Item(tvwMain.SelectedItem.key))
                    'MsgBox "HREF:" & mHREFIndex.item(tvwMain.SelectedItem.key)
                End If
            End If
        End If
        KeyAscii = 0
    End If
End Sub

Private Sub txtDummy_GotFocus()
    On Error Resume Next
    Call Me.tvwMain.SetFocus
End Sub

-->
<pre id="0">
Option Explicit

<font color="green">'DEVELOPMENT</font>
<font color="green">'mSection values:</font>
<font color="green">'   "home"          First list of choice of author or title catalogues.</font>
<font color="green">'       "authors"</font>
<font color="green">'           "authors-A"</font>
<font color="green">'           "authors-B"</font>
<font color="green">'           ...</font>
<font color="green">'       "titles"        A-Z list (leading to titles)</font>
<font color="green">'   "titleList"     List of titles for a letter, e.g. B.</font>
<font color="green">'   "book"          Actual book loaded</font>
<font color="green">'The navigation structure looks like this:</font>
<font color="green">'home</font>
<font color="green">'   authors</font>
<font color="green">'       authors-A</font>
<font color="green">'       authors-B</font>
<font color="green">'       authors-C</font>
<font color="green">'   titles</font>
<font color="green">'       title-A</font>
<font color="green">'       title-B</font>
<font color="green">'       title-C</font>

<font color="green">'VERSION HISTORY</font>
<font color="green">'1.0.0</font>
<font color="green">'Sent to Roger to review</font>
<font color="green">'1.0.1</font>
<font color="green">'Added Resume Nexts to all functions</font>
<font color="green">'Fixed ListIndex = 0 sets that might have confused screenreaders.</font>
<font color="green">'Fixed default book</font>
<font color="green">'Fixed authors who had married names from failing to display</font>
<font color="green">'Changed fonts all to Tahoma (Windows XP font)</font>
<font color="green">'Started (but didn't finish!) writing a caching mechanism. Turned out I didn't</font>
<font color="green">'need it: I optimised the webpage processing instead.</font>
<font color="green">'Released, foolishly, Jan 2007.</font>
<font color="green">'1.0.2</font>
<font color="green">'Fixed bug with recent list (no default installed) that made it hang.</font>
<font color="green">'Fixed bug with recent list that allowed duplicate entries.</font>
<font color="green">'1.0.3</font>
<font color="green">'Forgot to update the default book list in the resource file, didn't I? Now</font>
<font color="green">'correctly only shows installed book (Christmas Carol) on installation. Also</font>
<font color="green">'deletes books that are missing from the download list, so it should correct</font>
<font color="green">'previously-broken installs.</font>
<font color="green">'1.0.4</font>
<font color="green">'Fix for non-English language handling.</font>
<font color="green">'1.0.5 1 April 2007</font>
<font color="green">'Change to default langauge handling - see CLanguage.</font>
<font color="green">'1.0.6 25 April 2007</font>
<font color="green">'Wouldn't instantiate InternetExplorer on test machine, so changed reference</font>
<font color="green">'to InternetExplorer to instance of WebBrowser on form.</font>
<font color="green">'1.0.7 15 May 2007</font>
<font color="green">'Updated copyright notice stripping, so it better removes Gutenberg notices.</font>
<font color="green">'Added double-click handling on lists.</font>
<font color="green">'Remembers and displays book currently open on Book tab.</font>
<font color="green">'Fixed bug with shift and page up/down changing tab.</font>
<font color="green">'Remembers the tab you were last in and displays that when opening.</font>
<font color="green">'2.0.0 30 Jan 2008</font>
<font color="green">'Redesigned user interface, added progress bar, message when accessing web.</font>
<font color="green">'2.0.1 23 March 2008</font>
<font color="green">'Fixed i18n bug.</font>
<font color="green">'2.0.2 13 July 2008</font>
<font color="green">'Removed almost all the Gutenberg processing, because it is too unreliable and sometimes</font>
<font color="green">'produces books with no text.</font>
<font color="green">'Fixed Help and Open menu items in Book view.</font>
<font color="green">'Made treeview open when you click right, as well as loading children.</font>
<font color="green">'2.0.3 31 August 2008</font>
<font color="green">'Lets you delete books when list is sorted by author.</font>
<font color="green">'2.0.4  08 Oct 2008</font>
<font color="green">'   Exit while loop error handling in clsDownloader</font>
<font color="green">'2.0.5 23 Mar 2009</font>
<font color="green">'   Fix focus going to web browser with dummy control, hope this fixes freezing reported by Brett Hollis brett.hollis@gmail.com.</font>
<font color="green">'2.0.6 25 May 2009</font>
<font color="green">'   Fixed XP style being misapplied in _Activate, not _Initialize</font>
<font color="green">'2.0.7 8 June 2009</font>
<font color="green">'   Replaced comctl32 TreeView with one from mscomctl because the former would cause the application to crash in JAWS and Narrator.</font>
<font color="green">'2.0.8 13 June 2009</font>
<font color="green">'   Fixed XP Style bug.</font>
<font color="green">'2.0.9 15 June 2009</font>
<font color="green">'   Fixed XP Style bug AGAIN.</font>
<font color="green">'   Fixed books downloading but not being given title.</font>
<font color="green">'   Fixed Books not being opened when selected from Recent.</font>

<font color="green">'TO DO</font>
<font color="green">'Check it deletes okay, especially recent list</font>
<font color="green">'Fix removal of copyright notice</font>
<font color="green">'Add some more default books</font>

Private mSection As String ' tracks the state of what is being downloaded.
Private mFind As String ' sought by user in Find dialogue
Private mRecent As DOMDocument30 ' holds the most recent files opened by the user.
Private Const MAX_RECENT_LIST As Long = 10 ' how many entries can appear in the recent list in
<font color="green">'   the file menu.</font>

Private mAuthorCache() As IHTMLDocument ' cache of the author entries
Private mBookCache() As IHTMLDocument ' cache of the book entries
Private Const A As Long = 65
Private Const Z As Long = 90
Private mGettingIndex As Long ' the current Unicode value of what we're getting,
    'allowing us to index the mAuthors or gBooks cache arrays.
Private mHREFIndex As Collection 'indexes book node against href so we can get the book

Private mCache As String ' where we keep cached downloaded index pages
Private Const CACHE_ARRAY_START As Long = 97 ' Unicode "a"
Private Const CACHE_ARRAY_END As Long = 122  ' Unicode "z"

Private Const BOOK_DATA_FILE As String = "\downloadedBooks.xml"
Private Const GUTENBERG_HEADER As String = "*END*THE SMALL PRINT!"
Private Const GUTENBERG_FOOTER As String = "*** END OF THIS PROJECT GUTENBERG EBOOK"

Private gstrNoDownloadedBooks As String
Private gstrDeleteConfirm1 As String
Private gstrDeleteConfirm2 As String

Private Const Document As Integer = 0

Private Declare Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" _
   (ByVal lpBuffer As String, nSize As Long) As Long

Private Declare Function URLDownloadToFile Lib "urlmon" Alias _
    "URLDownloadToFileA" (ByVal pCaller As Long, _
    ByVal szURL As String, _
    ByVal szFileName As String, _
    ByVal dwReserved As Long, _
    ByVal lpfnCB As Long) As Long

<b>Private Sub Form_Initialize()</b>
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
<b>End Sub</b>

<b>Private Sub Form_Load()</b>
    On Error Resume Next
    Dim i As Long
    Dim result As String
    
    'create folder for downloading books and storing data
    Call modPath.DetermineSettingsPath("WebbIE", App.title, "1") ' Make sure it keeps reading old store.
    Call modUpdate.CheckForUpdates
    Call modRememberPosition.LoadPosition(Me)
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    'Set mBrowser = New InternetExplorer
    Call Load(frmBook)
    gstrNoDownloadedBooks = modI18N.GetText("No books downloaded yet.")
    gstrDeleteConfirm1 = modI18N.GetText("Do you want to delete") & " "
    gstrDeleteConfirm2 = " " & modI18N.GetText("from your list of downloaded books?")
    'stop user tabbing to IE object
    mBrowser.TabStop = False
    mBrowser.Silent = True
    'no book loaded yet
    gLoadedIndex = -1
    'setup books file
    Call SetupBooksFile
    'setup recent file
    Call SetupRecent
    'setup directory
    Call SetupDirectory
    'load downloaded record
    Call LoadBooks
    'prepare to get book index from Gutenberg
    Set mHREFIndex = New Collection
    Call Me.Show
    'Work out book sort
    result = modPath.GetSettingIni(App.EXEName, "Downloaded", "Sort", "Title")
    If result = "Title" Then
        optSort(0).value = True
        Call optSort_Click(0)
    Else
        optSort(1).value = True
        Call optSort_Click(1)
    End If
    'display current book, if any
    result = modShared.SharedReadIniFile(modPath.settingsPath & "\" & App.title & ".ini", "State", "CurrentBookIndex")
    'Default to first book if not found but a book exists:
    If lstBooksTitleAuthor.ListCount > 0 And Len(result) = 0 Then result = "0"
    If Len(result) > 0 Then
        lstBooksTitleAuthor.ListIndex = CInt(result)
        If lstBooksTitleAuthor.ListIndex > -1 Then
            gLoadedIndex = lstBooksTitleAuthor.ListIndex
            'Call LoadSelectedBook
        End If
    End If
    'restore tab state
    Call Home
    Call tvwMain.SetFocus
    Call Load(frmProgress)
<b>End Sub</b>

<b>Private Sub Home()</b>
    On Error Resume Next
    mSection = "home"
    Set tvwMain.SelectedItem = tvwMain.Nodes(1)
    tvwMain.Nodes(2).EnsureVisible
    staMain.SimpleText = Empty
<b>End Sub</b>

<b>Private Sub Form_Resize()</b>
    On Error Resume Next
    Dim i As Long
    If Me.WindowState &lt;> vbMinimized Then
        If Me.ScaleHeight > 2000 Then
            lblMain.Top = GAP
            tvwMain.Top = lblMain.Top + lblMain.Height + GAP
            tvwMain.Height = Me.ScaleHeight / 2 - tvwMain.Top
            lblDownloaded.Top = tvwMain.Top + tvwMain.Height + GAP
            lstBooksTitleAuthor.Top = lblDownloaded.Top + lblDownloaded.Height + GAP
            lstBooksTitleAuthor.Height = Me.ScaleHeight - optSort(0).Height - GAP - GAP - lstBooksTitleAuthor.Top - staMain.Height
            lstBooksAuthorTitle.Top = lstBooksTitleAuthor.Top
            lstBooksAuthorTitle.Height = lstBooksTitleAuthor.Height
            optSort(0).Top = Me.ScaleHeight - optSort(0).Height - GAP - staMain.Height
            optSort(1).Top = optSort(0).Top
        End If
        If Me.ScaleWidth > 2000 Then
            lblMain.Left = GAP
            tvwMain.Left = GAP
            tvwMain.Width = Me.ScaleWidth - tvwMain.Left
            lstBooksTitleAuthor.Left = GAP
            lstBooksTitleAuthor.Width = Me.ScaleWidth - lstBooksTitleAuthor.Left
            lstBooksAuthorTitle.Left = lstBooksTitleAuthor.Left
            lstBooksAuthorTitle.Width = lstBooksTitleAuthor.Width
            optSort(0).Left = GAP
            optSort(1).Left = optSort(0).Left + optSort(0).Width + GAP
        End If
    End If
    txtDummy.Left = Me.ScaleWidth + 500
    mBrowser.Left = Me.ScaleWidth + 100
<b>End Sub</b>

<b>Private Sub Form_Unload(Cancel As Integer)</b>
    On Error Resume Next
    'save downloaded books
    Call gBooks.Save(gBooks.url)
    'save sort type
    If optSort(0).value Then
        Call modPath.SaveSettingIni(App.EXEName, "Downloaded", "Sort", "Title")
    Else
        Call modPath.SaveSettingIni(App.EXEName, "Downloaded", "Sort", "Author")
    End If
    'save current book index
    Call WritePrivateProfileString("State", "CurrentBookIndex", CStr(lstBooksTitleAuthor.ListIndex), modPath.settingsPath & "\" & App.title & ".ini")
    'save position
    Call modRememberPosition.SavePosition(Me)
    'unload forms
    Call Unload(frmHelp)
    Call Unload(frmBook)
    Call Unload(frmProgress)
    Call Unload(frmAccessing)
<b>End Sub</b>

<b>Private Sub lstBooksAuthorTitle_KeyDown(KeyCode As Integer, Shift As Integer)</b>
<font color="green">'Delete book when list is sorted by author. 2.0.3</font>
    On Error Resume Next
    If KeyCode = vbKeyDelete Then
        'delete downloaded book
        lstBooksTitleAuthor.ListIndex = lstBooksAuthorTitle.ItemData(lstBooksAuthorTitle.ListIndex) - 1
        Call lstBooksTitleAuthor_KeyDown(vbKeyDelete, 0)
    End If
<b>End Sub</b>

<b>Private Sub lstBooksTitleAuthor_DblClick()</b>
    On Error Resume Next
    Call lstBooksTitleAuthor_KeyPress(vbKeyReturn)
<b>End Sub</b>

<b>Private Sub lstBooksTitleAuthor_GotFocus()</b>
    On Error Resume Next
    If lstBooksTitleAuthor.ListIndex = -1 Then lstBooksTitleAuthor.ListIndex = 0
<b>End Sub</b>

<b>Private Sub lstBooksTitleAuthor_KeyDown(KeyCode As Integer, Shift As Integer)</b>
    On Error Resume Next
    Dim result As Long
    Dim old As Long
    
    If KeyCode = vbKeyDelete Then
        'delete downloaded book
        If lstBooksTitleAuthor.List(0) = gstrNoDownloadedBooks Then
            'no books to delete
            Call Beep
        Else
            'delete book
            result = MsgBox(gstrDeleteConfirm1 & lstBooksTitleAuthor.List(lstBooksTitleAuthor.ListIndex) & gstrDeleteConfirm2, vbYesNoCancel, App.title)
            If result = vbYes Then
                frmBook.rtfMain.text = Empty
                gLoadedIndex = -1
                Call RemoveRecent(gBooks.documentElement.selectNodes("book").Item(lstBooksTitleAuthor.ListIndex).selectSingleNode("filename").text)
                Call gBooks.documentElement.removeChild(gBooks.documentElement.selectNodes("book").Item(lstBooksTitleAuthor.ListIndex))
                Call gBooks.Save(gBooks.url)
                If optSort(0).value Then
                    'Sorted by title.
                    old = lstBooksTitleAuthor.ListIndex
                    Call LoadBooks
                    Call lstBooksTitleAuthor.SetFocus
                    If old > lstBooksTitleAuthor.ListCount - 1 Then old = lstBooksTitleAuthor.ListCount - 1
                    lstBooksTitleAuthor.ListIndex = old
                Else
                    'Sorted by author.
                    old = lstBooksAuthorTitle.ListIndex
                    Call LoadBooks
                    Call lstBooksAuthorTitle.SetFocus
                    If old > lstBooksAuthorTitle.ListCount - 1 Then old = lstBooksAuthorTitle.ListCount - 1
                    lstBooksAuthorTitle.ListIndex = old
                End If
            End If
        End If
    End If
<b>End Sub</b>

<b>Private Sub lstBooksTitleAuthor_KeyPress(KeyAscii As Integer)</b>
    On Error Resume Next
    If KeyAscii = vbKeyReturn Then
        'load downloaded book
        If lstBooksTitleAuthor.ListCount = 1 And gstrNoDownloadedBooks = lstBooksTitleAuthor.List(0) Then
            'no books!
            Call Beep
        Else
            'downloaded, open
            gLoadedIndex = lstBooksTitleAuthor.ListIndex
            Call LoadSelectedBook
        End If
    End If
<b>End Sub</b>

<b>Private Sub LoadSelectedBook(Optional id As String)</b>
    On Error Resume Next
    Dim Path As String
    Dim cursor As Long
    Dim index As Long
    Dim book As IXMLDOMNode
    Dim name As String
    Dim filename As String
    
    If id = Empty Then
        If lstBooksTitleAuthor.Visible Then
            index = lstBooksTitleAuthor.ListIndex
        Else
            index = lstBooksAuthorTitle.ListIndex
        End If
        If index >= 0 Then
            Set book = gBooks.documentElement.selectNodes("book").Item(index)
        End If
    Else
        Set book = gBooks.documentElement.selectSingleNode("book[@id='" & id & "']")
    End If
    If Not (book Is Nothing) Then
        If frmBook.rtfMain.filename &lt;> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
        Call frmBook.rtfMain.LoadFile(modPath.nonRoamingSettingsPath & "\" & book.selectSingleNode("filename").text)
        Call AddRecent(book.selectSingleNode("title").text, book.selectSingleNode("filename").text)
        cursor = book.selectSingleNode("cursorPos").text
        If cursor > 0 Then
            frmBook.rtfMain.SelStart = cursor
        End If
        Call frmBook.Show(vbModal, Me)
    End If
<b>End Sub</b>

<b>Public Sub mnuFileOpen_Click()</b>
    On Error Resume Next
    Dim name As String
    Dim author As String
    Dim s As String
    Dim fso As New Scripting.FileSystemObject
    Dim entry As Integer
    
    cdlg.Flags = cdlOFNFileMustExist + cdlOFNPathMustExist
    cdlg.DefaultExt = "txt"
    cdlg.CancelError = True
    cdlg.DialogTitle = "Open document"
    cdlg.Filter = "Documents|*.txt;*.doc;*.rtf;*.text"
    On Error GoTo CancelError:
    cdlg.ShowOpen
    On Error Resume Next
    If cdlg.filename &lt;> "" Then
        name = InputBox("Name of document:")
        author = InputBox("Author:")
        If Len(name) = 0 Then
            name = cdlg.filename
            If InStr(1, name, "\") > 0 Then
                name = Right(name, Len(name) - InStrRev(name, "\", Len(name)))
            End If
            If InStr(1, name, ".") > 0 Then
                name = Left(name, Len(name) - InStr(1, name, ".") - 1)
            End If
        End If
        If Len(author) = 0 Then
            s = String(256, Chr(0))
            Call GetUserName(s, Len(s))
            author = Left(s, InStr(1, s, Chr(0)))
        End If
        If frmBook.rtfMain.filename &lt;> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
        Call frmBook.rtfMain.LoadFile(cdlg.filename)
        'Trim path to just filename
        entry = AddToBooks(name, fso.GetFile(cdlg.filename).name, author, Globals.GetUniqueKey)
        Call AddRecent(name, cdlg.filename)
    End If
CancelError:
<b>End Sub</b>

<b>Public Sub mnuViewWhat_Click(index As Integer)</b>
    On Error Resume Next
    Select Case index
        Case 0 ' catalogue
            Call tvwMain.SetFocus
        Case 1 ' book
            Call LoadSelectedBook
        Case 2 ' downloaded book list
            If lstBooksAuthorTitle.Enabled Then
                Call lstBooksAuthorTitle.SetFocus
            Else
                Call lstBooksTitleAuthor.SetFocus
            End If
    End Select
<b>End Sub</b>

<b>Private Sub tvwmain_DblClick()</b>
    On Error Resume Next
    Call tvwMain_KeyPress(vbKeyReturn)
<b>End Sub</b>

<b>Private Sub lstBooksAuthorTitle_DblClick()</b>
    On Error Resume Next
    Call lstBooksAuthorTitle_KeyPress(vbKeyReturn)
<b>End Sub</b>

<b>Private Sub lstBooksAuthorTitle_GotFocus()</b>
    On Error Resume Next
    If lstBooksAuthorTitle.ListIndex = -1 Then lstBooksAuthorTitle.ListIndex = 0
<b>End Sub</b>

<b>Private Sub lstBooksAuthorTitle_KeyPress(KeyAscii As Integer)</b>
    On Error Resume Next
    If KeyAscii = vbKeyReturn Then
        'need to call lstBooksTitleAuthor with correct index: stored in ItemData
        lstBooksTitleAuthor.ListIndex = lstBooksAuthorTitle.ItemData(lstBooksAuthorTitle.ListIndex) - 1
        Call lstBooksTitleAuthor_KeyPress(vbKeyReturn)
    End If
<b>End Sub</b>

<b>Private Sub mBrowser_DocumentComplete(ByVal pDisp As Object, url As Variant)</b>
    On Error Resume Next
    Dim elementIterator As IHTMLElement
    Dim filename As String
    Dim Path As String
    Dim slash As Long
    Dim notice As Long
    Dim text As String
    Dim href As String

<font color="green">'    Debug.Print "url:" & url</font>
    If url = "http:///" Or url = "" Then
    Else
        Select Case mSection
            Case "book"
                'get book
                For Each elementIterator In pDisp.Document.getElementsByTagName("A")
                    filename = elementIterator.getAttribute("href")
                    Path = elementIterator.getAttribute("href")
                    If InStr(1, filename, ".txt", vbTextCompare) > 0 Then
                        'get the filename by parsing href
                        slash = InStrRev(filename, "/", Len(filename))
                        filename = Right(filename, Len(filename) - slash)
                        'filename = Left(filename, InStrRev(filename, "/", Len(filename)))
                        'work out title/author
                        Call frmAccessing.Hide
                        Call frmProgress.SetDownload(Path, modPath.nonRoamingSettingsPath & "\" & filename, tvwMain.SelectedItem.text)
                        Call frmProgress.Show(vbModal, Me)
                        Exit For
                    End If
                Next elementIterator
            Case Else
                'Debug.Print "Loading the cat here"
                'what have I just got?
                'Debug.Print "Got a document: current state is: " & mSection & vbNewLine & "mGettingIndex is:" & mGettingIndex
                'show contents
                Call DisplayCatalogue(mBrowser.Document)
                Call frmAccessing.Hide
        End Select
    End If
<b>End Sub</b>

<b>Public Sub BookDownloaded(filename As String, url As String)</b>
    On Error Resume Next
    Dim text As String
    Dim author As String
    Dim notice As String
    Dim n As Node
    Dim fso As New Scripting.FileSystemObject
    Dim title As String
    
<font color="green">'    Set n = tvwMain.SelectedItem</font>
    'Debug.Print "Text:" & n.text
    'title = n.text
    title = tvwMain.SelectedItem
    'Debug.Print "Key:" & n.key
    'Set n = n.Parent
    'Debug.Print "Parent:" & n.text
    author = tvwMain.SelectedItem.Parent
    'Add to downloaded books
    gLoadedIndex = AddToBooks(title, fso.GetFile(filename).name, author, gLoadingID)
    If frmBook.rtfMain.filename &lt;> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
    Call frmBook.rtfMain.LoadFile(filename)
    Call AddRecent(title, filename)
    'No longer try to strip out Gutenberg stuff: it's too unreliable, sometimes we lose the whole book.
    'The user will just have to find the start themselves.
    'Still process the newlines, though.
<font color="green">'    'trim out the gutenberg stuff</font>
    text = frmBook.rtfMain.text
<font color="green">'    'header:</font>
<font color="green">'    notice = InStr(1, text, GUTENBERG_HEADER, vbTextCompare)</font>
<font color="green">'    If notice > 0 Then</font>
<font color="green">'        notice = InStr(notice, text, vbNewLine, vbTextCompare)</font>
<font color="green">'        text = Right(text, Len(text) - notice + 1)</font>
<font color="green">'    Else</font>
<font color="green">'        'hmm, didn't find header. Maybe different format.</font>
<font color="green">'        notice = InStr(1, text, vbNewLine & vbNewLine & vbNewLine & vbNewLine & vbNewLine & vbNewLine, vbBinaryCompare)</font>
<font color="green">'        If notice > 0 Then</font>
<font color="green">'            'six newlines: that's probably the header</font>
<font color="green">'            notice = notice + Len(vbNewLine) * 6</font>
<font color="green">'            text = Right(text, Len(text) - notice + 1)</font>
<font color="green">'        End If</font>
<font color="green">'    End If</font>
<font color="green">'    text = Trim(text)</font>
<font color="green">'    While Left(text, Len(vbNewLine)) = vbNewLine And Len(text) > 0</font>
<font color="green">'        text = Right(text, Len(text) - Len(vbNewLine))</font>
<font color="green">'    Wend</font>
<font color="green">'    'footer:</font>
<font color="green">'    notice = InStr(1, text, GUTENBERG_FOOTER, vbTextCompare)</font>
<font color="green">'    If notice > 0 Then</font>
<font color="green">'        text = Left(text, notice)</font>
<font color="green">'    End If</font>
<font color="green">'    text = Trim(text)</font>
<font color="green">'    While Left(text, Len(vbNewLine)) = vbNewLine</font>
<font color="green">'        text = Right(text, Len(text) - Len(vbNewLine))</font>
<font color="green">'    Wend</font>
    'take out the extraneous newlines
    text = Replace(text, vbNewLine & vbNewLine, "jkjkjkjkjjkjkjk")
    text = Replace(text, vbNewLine, " ")
    text = Replace(text, "  ", " ")
    text = Replace(text, "jkjkjkjkjjkjkjk", vbNewLine & vbNewLine)
    frmBook.rtfMain.text = text
    Call frmBook.rtfMain.SaveFile(filename)
    staMain.SimpleText = Empty
    Call LoadSelectedBook
<b>End Sub</b>

<b>Private Sub DisplayCatalogue(doc As IHTMLDocument)</b>
<font color="green">'Load entries from the page and put in main list.</font>
    On Error Resume Next
    Dim elementIterator As IHTMLElement
    Dim listcat As String
    Dim publications As IHTMLElement
    Dim book As IHTMLElement
    Dim newKey As String
    Dim newKey2 As String
    Dim childA As IHTMLElement
    Dim foundBook As Boolean
    Dim author As IHTMLElement
    
    staMain.SimpleText = "Loading catalogue - please wait"
    tvwMain.Visible = False
    'Call modShared.LockWindowUpdate(tvwMain.hwnd)
    For Each elementIterator In doc.getElementsByTagName("H2")
        newKey = Globals.GetUniqueKey '"item-" & elementIterator.innerText
        Call tvwMain.Nodes.Add(tvwMain.SelectedItem.key, tvwChild, newKey, Replace(elementIterator.innerText, vbNewLine, " "))
        Set publications = elementIterator.nextSibling
        foundBook = False
        If mSection = "authorList" Then
            For Each book In publications.children
                If book.tagName = "LI" Then
                    If book.className = "pgdbetext" Then
                        'Got an etext to add to this author.
                        newKey2 = Globals.GetUniqueKey
                        Call tvwMain.Nodes.Add(newKey, tvwChild, newKey2, Replace(book.innerText, vbNewLine, " "))
                        For Each childA In book.children
                            If childA.tagName = "A" Then
                                foundBook = True
                                Call mHREFIndex.Add(childA.getAttribute("href"), newKey2)
                                Exit For
                            End If
                        Next childA
                    End If
                End If
            Next book
        ElseIf mSection = "titleList" Then
            Call mHREFIndex.Add(elementIterator.children(0).getAttribute("href"), newKey)
            Set author = elementIterator.nextSibling
            tvwMain.Nodes.Item(newKey).text = tvwMain.Nodes.Item(newKey).text & " " & author.innerText
            foundBook = True
        End If
        If Not foundBook Then
            'didn't find a book link, remove the treeview node
            Call tvwMain.Nodes.Remove(newKey)
        End If
    Next elementIterator
    'Open the current author/item.
    Call tvwMain.SelectedItem.Child.EnsureVisible
    'Call modShared.LockWindowUpdate(0)
    tvwMain.Visible = True
    staMain.SimpleText = Empty
    Call tvwMain.SetFocus
<b>End Sub</b>

<b>Private Sub mBrowser_StatusTextChange(ByVal text As String)</b>
    On Error Resume Next
    staMain.SimpleText = text
<b>End Sub</b>

<b>Private Sub mnuCopy_Click()</b>
    On Error Resume Next
    Call SendKeys("^C")
<b>End Sub</b>

<b>Private Sub mnuCut_Click()</b>
    On Error Resume Next
    Call SendKeys("^X")
<b>End Sub</b>

<b>Private Sub mnuEditFind_Click()</b>
    On Error Resume Next
    Dim newSearch As String
    
    newSearch = InputBox("Find what:", "Find", mFind)
    If Len(newSearch) > 0 Then
        mFind = newSearch
        Call Find(mFind)
    End If
<b>End Sub</b>

<b>Private Sub Find(what As String)</b>
    On Error Resume Next
    Dim searchList As ListBox
    Dim start As Long
    Dim i As Long
    Dim found As Boolean

    If Len(what) > 0 Then
        mFind = what
        'Debug.Print "Name:" & Me.ActiveControl.Name
        Select Case Me.ActiveControl.name
            Case Me.tvwMain.name
                Call FindInTree(tvwMain, what)
            Case lstBooksTitleAuthor.name
                Call FindInList(lstBooksTitleAuthor, what)
            Case Me.lstBooksAuthorTitle.name
                Call FindInList(lstBooksAuthorTitle, what)
        End Select
    End If
<b>End Sub</b>

<b>Private Sub FindInTree(t As TreeView, what As String)</b>
    On Error Resume Next
    Dim i As Long
    Dim keepLooking As Boolean
    Dim found As Node
    
    i = t.SelectedItem.index + 1
    keepLooking = (i &lt;= t.Nodes.Count) ' don't search current item.
    While keepLooking
        If InStr(1, t.Nodes.Item(i), what, vbTextCompare) > 0 Then
            keepLooking = False
            Set found = t.Nodes.Item(i)
        Else
            If i = t.Nodes.Count Then
                keepLooking = False
            Else
                i = i + 1
            End If
        End If
    Wend
    If found Is Nothing Then
        'didn't find, search again from the top.
        keepLooking = True
        i = 1
        While keepLooking
            If InStr(1, t.Nodes.Item(i), what, vbTextCompare) > 0 Then
                keepLooking = False
                Set found = t.Nodes.Item(i)
            Else
                If i = t.SelectedItem.index Then
                    keepLooking = False
                Else
                    i = i + 1
                End If
            End If
        Wend
    End If
    If found Is Nothing Then
        'failed to find
    Else
        'found matching text
        Set tvwMain.SelectedItem = found
    End If
<b>End Sub</b>

<b>Private Sub FindInList(l As ListBox, what As String)</b>
    On Error Resume Next
    Dim found As Boolean
    Dim start As Long
    Dim i As Long
    
    start = l.ListIndex
    For i = l.ListIndex + 1 To l.ListCount - 1
        If InStr(1, l.List(i), what, vbTextCompare) > 0 Then
            l.ListIndex = i
            found = True
            Exit For
        End If
    Next i
    If Not found Then
        For i = 0 To l.ListIndex - 1
            If InStr(1, l.List(i), what, vbTextCompare) > 0 Then
                l.ListIndex = i
                found = True
                Exit For
            End If
        Next i
    End If
    If found Then
        'okay!
    Else
        Call Beep
    End If
    Call l.SetFocus
<b>End Sub</b>


<b>Private Sub mnuEditFindnext_Click()</b>
    On Error Resume Next
    Call Find(mFind)
<b>End Sub</b>

<b>Private Sub mnuFileExit_Click()</b>
    On Error Resume Next
    Call Unload(Me)
<b>End Sub</b>

<b>Public Sub mnuHelpAbout_Click()</b>
    On Error Resume Next
    Call MsgBox(App.title & " " & App.Major & "." & App.Minor & "." & App.Revision & vbNewLine & "WebbIE Suite " & modVersion.GetPackageVersion & vbNewLine & "Alasdair King http://www.webbie.org.uk", vbInformation, App.title)
<b>End Sub</b>


<b>Public Sub mnuHelpLegal_Click()</b>
    On Error Resume Next
    Call frmHelp.ShowLegal
    Call frmHelp.Show(vbModeless, Me)
<b>End Sub</b>

<b>Public Sub mnuHelpManual_Click()</b>
    On Error Resume Next
    Call frmHelp.ShowHelp
    Call frmHelp.Show(vbModeless, Me)
<b>End Sub</b>

<b>Private Sub mnuPaste_Click()</b>
    On Error Resume Next
    Call SendKeys("^V")
<b>End Sub</b>

<b>Private Sub mnuRecent_Click(index As Integer)</b>
    On Error Resume Next
    Dim Path As String
    Dim caption As String
    'load downloaded book
    If frmBook.rtfMain.filename &lt;> "" Then Call frmBook.rtfMain.SaveFile(frmBook.rtfMain.filename)
    Path = modPath.nonRoamingSettingsPath & "\" & mRecent.documentElement.selectNodes("recent").Item(index).selectSingleNode("filename").text
    Call frmBook.rtfMain.LoadFile(Path)
    caption = GetText("frmBook.Caption")
    If caption &lt;> "frmBook.Caption" Then
        frmBook.caption = caption & " - " & mRecent.documentElement.selectNodes("recent").Item(index).selectSingleNode("name").text
    End If
    Call frmBook.Show(vbModal, Me)
<b>End Sub</b>

<b>Private Sub mnuSelectall_Click()</b>
    On Error Resume Next
    frmBook.rtfMain.SelStart = 1
    frmBook.rtfMain.SelLength = Len(frmBook.rtfMain.text)
<b>End Sub</b>

<b>Private Sub mBrowser_GotFocus()</b>
    On Error Resume Next
    'Need to put in dummy controls in case of known Microsoft bug breaking MSAA.
    Call Me.txtDummy.SetFocus
    'Call Me.tvwMain.SetFocus
<b>End Sub</b>

<b>Private Sub optSort_Click(index As Integer)</b>
    On Error Resume Next
    If index = 0 Then
        lstBooksTitleAuthor.Enabled = True
        Call lstBooksTitleAuthor.ZOrder
        Call lstBooksTitleAuthor.SetFocus
        lstBooksAuthorTitle.Enabled = False
    Else
        lstBooksAuthorTitle.Enabled = True
        Call lstBooksAuthorTitle.ZOrder
        Call lstBooksAuthorTitle.SetFocus
        lstBooksTitleAuthor.Enabled = False
    End If
<b>End Sub</b>

<b>Private Sub DisplayDownloaded()</b>
    On Error Resume Next
    Call lstBooksTitleAuthor.ZOrder
    Call lstBooksTitleAuthor.SetFocus
<b>End Sub</b>

<b>Private Sub LoadBooks()</b>
<font color="green">'load the reference file describing the books already downloaded</font>
    On Error Resume Next
    Dim bookIterator As IXMLDOMNode
    Dim i As Long
    Dim counter
    Dim fso As FileSystemObject
    
    Set gBooks = New DOMDocument30
    gBooks.async = False
    Call gBooks.Load(modPath.nonRoamingSettingsPath & BOOK_DATA_FILE)
    Call lstBooksTitleAuthor.Clear
    Call lstBooksAuthorTitle.Clear
    Set fso = New FileSystemObject
    For Each bookIterator In gBooks.documentElement.selectNodes("book")
        'check this book is actually there: need to do this because I cocked
        'up the default file once, so I need to edit the book list if one
        'of them is missing
        If fso.FileExists(modPath.nonRoamingSettingsPath & "\" & bookIterator.selectSingleNode("filename").text) Then
            Call lstBooksTitleAuthor.AddItem(bookIterator.selectSingleNode("title").text & " - " & bookIterator.selectSingleNode("author").text)
            Call lstBooksAuthorTitle.AddItem(bookIterator.selectSingleNode("author").text & " - " & bookIterator.selectSingleNode("title").text)
            For i = 0 To lstBooksAuthorTitle.ListCount - 1
                If lstBooksAuthorTitle.ItemData(i) = 0 Then
                    'just added
                    Exit For
                End If
            Next i
            lstBooksAuthorTitle.ItemData(i) = lstBooksTitleAuthor.ListCount
        Else
            'Book isn't actually downloaded: need to delete from book list
            Call gBooks.documentElement.removeChild(bookIterator)
        End If
    Next bookIterator
    If lstBooksTitleAuthor.ListCount = 0 Then
        Call lstBooksTitleAuthor.AddItem(gstrNoDownloadedBooks)
    End If
    If lstBooksAuthorTitle.ListCount = 0 Then
        Call lstBooksAuthorTitle.AddItem(gstrNoDownloadedBooks)
    End If
    'Don't set ListIndex unless you mean a screenreader to change focus
    'to that list
    'lstBooksAuthorTitle.ListIndex = 0
    'lstBooksTitleAuthor.ListIndex = 0
<b>End Sub</b>

<b>Private Sub SetupBooksFile()</b>
    On Error Resume Next
    Dim fso As FileSystemObject
    Dim ts As TextStream
    Dim b() As Byte
    Dim text As String
    
    Set fso = New FileSystemObject
    If fso.FileExists(modPath.nonRoamingSettingsPath & BOOK_DATA_FILE) Then
        'okay!
    Else
        'no books file: copy default from resource file
        b() = VB.LoadResData("EN", "BOOKDATAFILES")
        text = StrConv(b(), vbUnicode)
        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & BOOK_DATA_FILE, ForWriting, True)
        Call ts.write(text)
        Call ts.Close
        'hard code this stuff for the time being!
        b() = VB.LoadResData("EN1", "BOOKDATAFILES")
        text = StrConv(b(), vbUnicode)
        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\46-8.txt", ForWriting, True)
        Call ts.write(text)
        Call ts.Close
<font color="green">'       DEV: This makes 6MB of installer, so pulled them out. Only do Christmas Carol.</font>
<font color="green">'        b() = VB.LoadResData("EN2", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\alice30.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN3", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\dracu13.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN4", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\frank15.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN5", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\janey11.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN6", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\lwmen13.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN7", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\olivr11.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN8", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\pandp12.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
<font color="green">'        b() = VB.LoadResData("EN9", "BOOKDATAFILES")</font>
<font color="green">'        text = StrConv(b(), vbUnicode)</font>
<font color="green">'        Set ts = fso.OpenTextFile(modPath.nonRoamingSettingsPath & "\tarzn10.txt", ForWriting, True)</font>
<font color="green">'        Call ts.write(text)</font>
<font color="green">'        Call ts.Close</font>
<font color="green">'</font>
    End If
<b>End Sub</b>

<b>Private Function AddToBooks(title As String, filename As String, author As String, id As String) As Integer</b>
    On Error Resume Next
    'add a book to the saved book list and return where it was placed (0-based)
    Dim book As IXMLDOMNode
    Dim added As Boolean
    Dim newNode As IXMLDOMNode
    
    
    Set newNode = gBooks.createNode(NODE_ELEMENT, "book", Empty)
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "title", Empty))
    newNode.selectSingleNode("title").text = title
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "filename", Empty))
    newNode.selectSingleNode("filename").text = filename
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "author", Empty))
    newNode.selectSingleNode("author").text = author
    Call newNode.appendChild(gBooks.createNode(NODE_ELEMENT, "cursorPos", Empty))
    newNode.selectSingleNode("cursorPos").text = "1"
    Call newNode.Attributes.setNamedItem(gBooks.createNode(NODE_ATTRIBUTE, "id", Empty))
    newNode.Attributes.getNamedItem("id").text = id
    AddToBooks = 0
    'trim title: appears to gain an extra space at times
    title = Trim(title)
    For Each book In gBooks.documentElement.selectNodes("book")
        'Debug.Print "comparing title=[" & title & "]" & vbNewLine & " with node=[" & book.selectSingleNode("title").text & "]"
        If StrComp(book.selectSingleNode("title").text, title, vbTextCompare) = 0 Then
            'found it already in there!
            Debug.Print "Found already"
            added = True
            Exit For
        ElseIf StrComp(book.selectSingleNode("title").text, title, vbTextCompare) > 0 Then
            added = True
            Debug.Print "Added new"
            Call gBooks.documentElement.insertBefore(newNode, book)
            Exit For
        End If
        AddToBooks = AddToBooks + 1
    Next book
    If Not added Then
        Call gBooks.documentElement.appendChild(newNode)
    End If
    Call gBooks.Save(gBooks.url)
    Call LoadBooks
End Function

<b>Private Sub SetupRecent()</b>
    On Error Resume Next
    Dim fso As FileSystemObject
    Dim b() As Byte
    Dim ts As TextStream
    
    Set fso = New FileSystemObject
    If Not fso.FileExists(modPath.nonRoamingSettingsPath & "\recent.xml") Then
        b() = VB.LoadResData("COMMON", "RECENT")
        Set ts = fso.CreateTextFile(modPath.nonRoamingSettingsPath & "\recent.xml", True)
        Call ts.write(StrConv(b(), vbUnicode))
        Call ts.Close
    End If
    Set mRecent = New DOMDocument30
    mRecent.async = False
    
    Call mRecent.Load(modPath.nonRoamingSettingsPath & "\recent.xml")
    Call DisplayRecent
<b>End Sub</b>

<b>Private Sub DisplayRecent()</b>
    On Error Resume Next
    Dim recentIterator As IXMLDOMNode
    Dim i As Long
    
    'clear recent
    For i = mnuRecent.UBound To 1 Step -1
        Call Unload(mnuRecent(i))
    Next i
    mnuRecent(0).Visible = False
    'load new
    i = 0
    'Debug.Print "mRecent" & vbNewLine & mRecent.xml
    For Each recentIterator In mRecent.documentElement.selectNodes("recent")
        i = i + 1
        If i - 1 > mnuRecent.UBound Then
            Call Load(mnuRecent(i - 1))
        End If
        mnuRecent(i - 1).Visible = True
    Next recentIterator
    i = 0
    For Each recentIterator In mRecent.documentElement.selectNodes("recent")
        'Debug.Print "RX" & recentIterator.xml
        mnuRecent(i).caption = "&" & (i + 1) & " " & recentIterator.selectSingleNode("name").text
        i = i + 1
    Next recentIterator
    mnuBar.Visible = mnuRecent(0).Visible
<b>End Sub</b>

<b>Private Sub AddRecent(name As String, filename As String)</b>
    On Error Resume Next
    Dim newNode As IXMLDOMNode
    Dim nodeIterator As IXMLDOMNode
    Dim needsToBeAdded As Boolean
    
    'first see if we already have the filename
    needsToBeAdded = True
    
    For Each nodeIterator In mRecent.documentElement.selectNodes("recent")
        If nodeIterator.selectSingleNode("filename").text = filename Then
            'we already have this in the recent list: rest easy
            needsToBeAdded = False
            Exit For
        End If
    Next nodeIterator
    'okay, is this something new to add?
    If needsToBeAdded Then
        'yes, it is!
        Set newNode = mRecent.createNode(NODE_ELEMENT, "recent", "")
        Call newNode.appendChild(mRecent.createNode(NODE_ELEMENT, "name", ""))
        newNode.selectSingleNode("name").text = name
        Call newNode.appendChild(mRecent.createNode(NODE_ELEMENT, "filename", ""))
        newNode.selectSingleNode("filename").text = filename
        'add to beginning
        Call mRecent.documentElement.insertBefore(newNode, mRecent.documentElement.selectNodes("recent").Item(0))
        'remove last one if > MAX_RECENT_LIST
        If mRecent.documentElement.selectNodes("recent").length > MAX_RECENT_LIST Then
            Call mRecent.documentElement.removeChild(mRecent.documentElement.selectNodes("recent").Item(5))
        End If
        'save amended file
        Call mRecent.Save(modPath.nonRoamingSettingsPath & "\recent.xml")
        'show list
    End If
    Call DisplayRecent
<b>End Sub</b>

<b>Private Sub RemoveRecent(filename As String)</b>
    On Error Resume Next
<font color="green">'removes an item from the recent list because it's been deleted</font>
    Dim recentIterator As IXMLDOMNode
    
    For Each recentIterator In mRecent.documentElement.selectNodes("recent")
        If recentIterator.selectSingleNode("filename").text = filename Then
            'remove node
            Call mRecent.documentElement.removeChild(recentIterator)
            Call mRecent.Save(mRecent.url)
            Call DisplayRecent
            Exit For
        End If
    Next recentIterator
<b>End Sub</b>

<b>Private Sub SetupDirectory()</b>
    On Error Resume Next
    Dim i As Integer
    Call tvwMain.Nodes.Clear
    Call tvwMain.Nodes.Add(, , "home", "Gutenberg Directory")
    Call tvwMain.Nodes.Add("home", tvwChild, "authors", "Books by Author")
    Call tvwMain.Nodes.Add("home", tvwChild, "titles", "Books by Title")
    For i = vbKeyA To vbKeyZ
        Call tvwMain.Nodes.Add("authors", tvwChild, "authors-" & Chr(i), Chr(i))
        Call tvwMain.Nodes.Add("titles", tvwChild, "titles-" & Chr(i), Chr(i))
    Next i
<b>End Sub</b>

<b>Private Sub tvwMain_KeyDown(KeyCode As Integer, Shift As Integer)</b>
    On Error Resume Next
    If KeyCode = vbKeyRight Then
        If tvwMain.SelectedItem.children Then
            'already got this node
        Else
            KeyCode = 0
            Call tvwMain_KeyPress(vbKeyReturn)
        End If
    End If
<b>End Sub</b>

<b>Private Sub tvwMain_KeyPress(KeyAscii As Integer)</b>
    On Error Resume Next
    Dim href As String
    
    'This is where the main downloading activity is initiated.
    If KeyAscii = vbKeyReturn Then
        KeyAscii = 0
        If tvwMain.SelectedItem.children Then
            'already got this node - it's a container node.
        Else
            If InStr(1, tvwMain.SelectedItem.key, "authors-") > 0 Then
                'one of the author nodes
                staMain.SimpleText = "Getting list of authors..."
                'record which index letter we need.
                mGettingIndex = AscW(LCase(tvwMain.SelectedItem.text))
                mSection = "authorList"
                'load from Gutenberg: see DocumentComplete for processing
                Call frmAccessing.Show
                Call mBrowser.navigate("http://www.gutenberg.org/browse/authors/" & LCase(tvwMain.SelectedItem.text))
            ElseIf InStr(1, tvwMain.SelectedItem.key, "titles-") > 0 Then
                'one of the title nodes
                staMain.SimpleText = "Getting list of titles..."
                'record which index letter we need.
                mGettingIndex = AscW(LCase(tvwMain.SelectedItem.text))
                mSection = "titleList"
                'load from Gutenberg: see DocumentComplete for processing
                Call frmAccessing.Show
                Call mBrowser.navigate("http://www.gutenberg.org/browse/titles/" & LCase(tvwMain.SelectedItem.text))
            Else
                'got a book to download. Have we downloaded this already?
                href = mHREFIndex.Item(tvwMain.SelectedItem.key)
                gLoadingID = Right(href, Len(href) - InStrRev(href, "/"))
                If gBooks.documentElement.selectNodes("book[@id=""" & gLoadingID & """]").length > 0 Then
                    'we've already downloaded this
                    Call LoadSelectedBook(gLoadingID)
                Else
                    'download
                    mSection = "book"
                    Call frmAccessing.Show
                    Call mBrowser.Navigate2(mHREFIndex.Item(tvwMain.SelectedItem.key))
                    'MsgBox "HREF:" & mHREFIndex.item(tvwMain.SelectedItem.key)
                End If
            End If
        End If
        KeyAscii = 0
    End If
<b>End Sub</b>

<b>Private Sub txtDummy_GotFocus()</b>
    On Error Resume Next
    Call Me.tvwMain.SetFocus
<b>End Sub</b>

</pre>
<h2>VB.Form frmHelp </h2>
<p>Filename: frmHelp.frm</p><p>Date last modified: Mon Jun 2009 22:18</p><!-- 
VERSION 5.00
Begin VB.Form frmHelp 
   Caption         =   "Accessible Gutenberg Help"
   ClientHeight    =   5175
   ClientLeft      =   60
   ClientTop       =   345
   ClientWidth     =   9930
   BeginProperty Font 
      Name            =   "Tahoma"
      Size            =   8.25
      Charset         =   0
      Weight          =   400
      Underline       =   0   'False
      Italic          =   0   'False
      Strikethrough   =   0   'False
   EndProperty
   Icon            =   "frmHelp.frx":0000
   LinkTopic       =   "Form1"
   ScaleHeight     =   5175
   ScaleWidth      =   9930
   StartUpPosition =   3  'Windows Default
   Tag             =   "frmHelp"
   Begin VB.CommandButton cmdOK 
      Cancel          =   -1  'True
      Caption         =   "OK"
      Default         =   -1  'True
      BeginProperty Font 
         Name            =   "Tahoma"
         Size            =   12
         Charset         =   0
         Weight          =   700
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Height          =   495
      Left            =   1680
      TabIndex        =   1
      Top             =   2760
      Width           =   1215
   End
   Begin VB.TextBox txtHelp 
      BeginProperty Font 
         Name            =   "Tahoma"
         Size            =   12
         Charset         =   0
         Weight          =   700
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
      Height          =   2655
      Left            =   0
      MultiLine       =   -1  'True
      ScrollBars      =   2  'Vertical
      TabIndex        =   0
      Top             =   0
      Width           =   4695
   End
End
Attribute VB_Name = "frmHelp"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Option Explicit

Private mManuallySet As Boolean

Private Sub cmdOK_Click()
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.SetFocus
End Sub

Private Sub Form_Activate()
    On Error Resume Next
    Call txtHelp.SetFocus
End Sub

Private Sub Form_Initialize()
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
End Sub

Private Sub Form_Load()
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    Call modRememberPosition.LoadPosition(Me)
End Sub

Private Sub Form_Resize()
    On Error Resume Next
    If Me.WindowState <> vbMinimized Then
        If Me.Height > cmdOK.Height Then
            cmdOK.Top = Me.ScaleHeight - cmdOK.Height - 90
            txtHelp.Height = Me.ScaleHeight - cmdOK.Height - 270
            txtHelp.Top = 90
        End If
        If Me.Width > cmdOK.Width + 180 Then
            txtHelp.Left = 90
            cmdOK.Left = Me.ScaleWidth / 2 - cmdOK.Width / 2
            txtHelp.Width = Me.ScaleWidth - 180
        End If
    End If
End Sub

Public Sub ShowLegal()
    On Error Resume Next
    txtHelp.text = modI18N.helpTopicText(1)
    Me.caption = modI18N.helpTopicTitle(1)
End Sub

Public Sub ShowHelp()
    On Error Resume Next
    txtHelp.text = modI18N.helpTopicText(0)
    Me.caption = modI18N.helpTopicTitle(0)
End Sub

Private Sub Form_Unload(Cancel As Integer)
    On Error Resume Next
    Call modRememberPosition.SavePosition(Me)
End Sub

-->
<pre id="0">
Option Explicit

Private mManuallySet As Boolean

<b>Private Sub cmdOK_Click()</b>
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.SetFocus
<b>End Sub</b>

<b>Private Sub Form_Activate()</b>
    On Error Resume Next
    Call txtHelp.SetFocus
<b>End Sub</b>

<b>Private Sub Form_Initialize()</b>
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
<b>End Sub</b>

<b>Private Sub Form_Load()</b>
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    Call modRememberPosition.LoadPosition(Me)
<b>End Sub</b>

<b>Private Sub Form_Resize()</b>
    On Error Resume Next
    If Me.WindowState &lt;> vbMinimized Then
        If Me.Height > cmdOK.Height Then
            cmdOK.Top = Me.ScaleHeight - cmdOK.Height - 90
            txtHelp.Height = Me.ScaleHeight - cmdOK.Height - 270
            txtHelp.Top = 90
        End If
        If Me.Width > cmdOK.Width + 180 Then
            txtHelp.Left = 90
            cmdOK.Left = Me.ScaleWidth / 2 - cmdOK.Width / 2
            txtHelp.Width = Me.ScaleWidth - 180
        End If
    End If
<b>End Sub</b>

<b>Public Sub ShowLegal()</b>
    On Error Resume Next
    txtHelp.text = modI18N.helpTopicText(1)
    Me.caption = modI18N.helpTopicTitle(1)
<b>End Sub</b>

<b>Public Sub ShowHelp()</b>
    On Error Resume Next
    txtHelp.text = modI18N.helpTopicText(0)
    Me.caption = modI18N.helpTopicTitle(0)
<b>End Sub</b>

<b>Private Sub Form_Unload(Cancel As Integer)</b>
    On Error Resume Next
    Call modRememberPosition.SavePosition(Me)
<b>End Sub</b>

</pre>
<h2>VB.Form frmBook </h2>
<p>Filename: frmBook.frm</p><p>Date last modified: Mon Jun 2009 22:18</p><!-- 
VERSION 5.00
Object = "{3B7C8863-D78F-101B-B9B5-04021C009402}#1.2#0"; "Richtx32.ocx"
Object = "{F9043C88-F6F2-101A-A3C9-08002B2F49FB}#1.2#0"; "comdlg32.ocx"
Begin VB.Form frmBook 
   Caption         =   "Book"
   ClientHeight    =   3195
   ClientLeft      =   225
   ClientTop       =   825
   ClientWidth     =   4680
   Icon            =   "frmBook.frx":0000
   LinkTopic       =   "Form1"
   ScaleHeight     =   3195
   ScaleWidth      =   4680
   StartUpPosition =   3  'Windows Default
   Begin MSComDlg.CommonDialog cdlgFont 
      Left            =   2160
      Top             =   1320
      _ExtentX        =   847
      _ExtentY        =   847
      _Version        =   393216
      CancelError     =   -1  'True
   End
   Begin VB.CommandButton cmdOK 
      Cancel          =   -1  'True
      Caption         =   "Close"
      Default         =   -1  'True
      Height          =   495
      Left            =   1800
      TabIndex        =   1
      Top             =   2520
      Width           =   1215
   End
   Begin RichTextLib.RichTextBox rtfMain 
      Height          =   2295
      Left            =   120
      TabIndex        =   0
      Top             =   120
      Width           =   4455
      _ExtentX        =   7858
      _ExtentY        =   4048
      _Version        =   393217
      ScrollBars      =   2
      TextRTF         =   $"frmBook.frx":0442
      BeginProperty Font {0BE35203-8F91-11CE-9DE3-00AA004BB851} 
         Name            =   "Arial"
         Size            =   13.5
         Charset         =   204
         Weight          =   700
         Underline       =   0   'False
         Italic          =   0   'False
         Strikethrough   =   0   'False
      EndProperty
   End
   Begin VB.Menu mnuFile 
      Caption         =   "&File"
      Begin VB.Menu mnuFileOpen 
         Caption         =   "&Open"
         Shortcut        =   ^O
      End
      Begin VB.Menu mnuFileExit 
         Caption         =   "E&xit"
      End
   End
   Begin VB.Menu mnuEdit 
      Caption         =   "&Edit"
      Begin VB.Menu mnuEditCut 
         Caption         =   "C&ut"
         Shortcut        =   ^X
      End
      Begin VB.Menu mnuEditCopy 
         Caption         =   "&Copy"
         Shortcut        =   ^C
      End
      Begin VB.Menu mnuEditPaste 
         Caption         =   "&Paste"
         Shortcut        =   ^V
      End
      Begin VB.Menu mnuEditFind 
         Caption         =   "&Find"
         Shortcut        =   ^F
      End
      Begin VB.Menu mnuEditFindnext 
         Caption         =   "Find &next"
         Shortcut        =   {F3}
      End
      Begin VB.Menu mnuEditSelectall 
         Caption         =   "Select &all"
         Shortcut        =   ^A
      End
   End
   Begin VB.Menu mnuView 
      Caption         =   "&View"
      Begin VB.Menu mnuViewWhat 
         Caption         =   "&Catalogue"
         Index           =   0
         Shortcut        =   ^L
      End
      Begin VB.Menu mnuViewWhat 
         Caption         =   "&Book"
         Index           =   1
         Shortcut        =   ^B
      End
      Begin VB.Menu mnuViewWhat 
         Caption         =   "&Downloaded books"
         Index           =   2
         Shortcut        =   ^D
      End
   End
   Begin VB.Menu mnuOptions 
      Caption         =   "&Options"
      Begin VB.Menu mnuOptionsFont 
         Caption         =   "&Font"
      End
   End
   Begin VB.Menu mnuHelp 
      Caption         =   "&Help"
      Begin VB.Menu mnuHelpManual 
         Caption         =   "&Manual"
         Shortcut        =   {F1}
      End
      Begin VB.Menu mnuHelpLegal 
         Caption         =   "&Legal"
      End
      Begin VB.Menu mnuHelpAbout 
         Caption         =   "&About"
      End
   End
End
Attribute VB_Name = "frmBook"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Option Explicit

Private mFind As String

Private Sub cmdOK_Click()
    On Error Resume Next
    Call Me.Hide
End Sub

Private Sub Form_Initialize()
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
End Sub

Private Sub Form_Load()
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    rtfMain.Font.bold = CBool(modPath.GetSettingIni(App.EXEName, "Font", "Bold", "True"))
    rtfMain.Font.name = modPath.GetSettingIni(App.EXEName, "Font", "Name", "Tahoma")
    rtfMain.Font.Charset = CInt(modPath.GetSettingIni(App.EXEName, "Font", "Charset", "0"))
    rtfMain.Font.Italic = CBool(modPath.GetSettingIni(App.EXEName, "Font", "Italic", "False"))
    rtfMain.Font.size = CInt(modPath.GetSettingIni(App.EXEName, "Font", "Size", "14"))
End Sub

Private Sub Form_Resize()
    On Error Resume Next
    Me.Left = frmGutenberg.Left
    Me.Top = frmGutenberg.Top
    Me.Width = frmGutenberg.Width
    Me.Height = frmGutenberg.Height
    rtfMain.Left = 0
    rtfMain.Top = 0
    rtfMain.Height = Me.ScaleHeight - cmdOK.Height - GAP - GAP
    rtfMain.Width = Me.ScaleWidth
    cmdOK.Left = Me.ScaleWidth / 2 - cmdOK.Width / 2
    cmdOK.Top = Me.ScaleHeight - GAP - cmdOK.Height
End Sub

Private Sub Form_Unload(Cancel As Integer)
    On Error Resume Next
    'save current cursor position
    Call SaveCurrentCursorPosition
    If rtfMain.filename <> "" Then Call rtfMain.SaveFile(rtfMain.filename)
    Call modPath.SaveSettingIni(App.EXEName, "Font", "Bold", CStr(rtfMain.Font.bold))
    Call modPath.SaveSettingIni(App.EXEName, "Font", "Name", rtfMain.Font.name)
    Call modPath.SaveSettingIni(App.EXEName, "Font", "Charset", rtfMain.Font.Charset)
    Call modPath.GetSettingIni(App.EXEName, "Font", "Italic", rtfMain.Font.Italic)
    Call modPath.GetSettingIni(App.EXEName, "Font", "Size", rtfMain.Font.size)
End Sub

Private Sub mnuEditCopy_Click()
    On Error Resume Next
    Call SendKeys("^C")
End Sub

Private Sub mnuEditCut_Click()
    On Error Resume Next
    Call SendKeys("^X")
End Sub

Private Sub mnuEditFind_Click()
    On Error Resume Next
    Dim s As String
    s = InputBox("Find what:", "Find", mFind)
    If Len(s) > 0 Then
        mFind = s
        Call Find(s)
    End If
End Sub

Private Sub Find(what As String)
    On Error Resume Next
    Dim found As Long
    
    found = InStr(rtfMain.SelStart + 2, rtfMain.text, what, vbTextCompare)
    If found > 0 Then
        rtfMain.SelStart = found - 1
        rtfMain.SelLength = Len(what)
        rtfMain.SetFocus
    Else
        found = InStr(1, rtfMain.text, what, vbTextCompare)
        If found > 0 Then
            rtfMain.SelStart = found
            rtfMain.SelLength = Len(what)
            rtfMain.SetFocus
        Else
            MsgBox "Cannot find " & what, vbInformation
        End If
    End If
End Sub

Private Sub mnuEditFindnext_Click()
    On Error Resume Next
    Call Find(mFind)
End Sub

Private Sub mnuEditPaste_Click()
    On Error Resume Next
    Call SendKeys("^V")
End Sub

Private Sub mnuEditSelectall_Click()
    On Error Resume Next
    Call SendKeys("^A")
End Sub

Private Sub mnuFileExit_Click()
    On Error Resume Next
    Call Unload(Me)
End Sub

Private Sub mnuFileOpen_Click()
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuFileOpen_Click
End Sub

Private Sub mnuHelpAbout_Click()
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuHelpAbout_Click
End Sub

Private Sub mnuHelpLegal_Click()
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuHelpLegal_Click
End Sub

Private Sub mnuHelpManual_Click()
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuHelpManual_Click
End Sub

Private Sub mnuOptionsFont_Click()
    On Error Resume Next
    Dim sel As Long
    Dim selL As Long
    cdlgFont.Flags = cdlCFEffects
    cdlgFont.Color = rtfMain.SelColor
    On Error GoTo CancelError:
    cdlgFont.ShowFont
    On Error Resume Next
    sel = rtfMain.SelStart
    selL = rtfMain.SelLength
    rtfMain.SelStart = 0
    rtfMain.SelLength = Len(rtfMain.text)
    rtfMain.Font.bold = cdlgFont.FontBold
    rtfMain.Font.name = cdlgFont.FontName
    rtfMain.Font.size = cdlgFont.FontSize
    rtfMain.Font.Underline = cdlgFont.FontUnderline
    rtfMain.SelStart = sel
    rtfMain.SelLength = selL
CancelError:
End Sub

Private Sub mnuViewWhat_Click(index As Integer)
    On Error Resume Next
    If index <> 1 Then
        'back to main form
        Call Me.Hide
        Call frmGutenberg.mnuViewWhat_Click(index)
    End If
End Sub

Private Sub rtfMain_KeyDown(KeyCode As Integer, Shift As Integer)
'    On Error Resume Next
'    Dim start As Long
'    Dim what As String
'
'    If KeyCode = vbKeyF And (Shift And vbCtrlMask) > 0 Then
'        what = InputBox("Find what:", "Find", mFind)
'        If Len(what) > 0 Then
'            mFind = what
'            start = frmBook.rtfMain.SelStart + 2
'            If start > Len(rtfMain.text) Then start = Len(rtfMain.text)
'            start = InStr(start, rtfMain.text, what, vbTextCompare)
'            If start = 0 Then
'                'not found, start from beginning again
'                start = InStr(1, rtfMain.text, what, vbTextCompare)
'                If start = 0 Or start = rtfMain.SelStart Then
'                    'not found at all
'                    Call Beep
'                Else
'                    rtfMain.SelStart = start
'                    rtfMain.SelLength = Len(mFind)
'                End If
'            Else
'                'found!
'                rtfMain.SelStart = start - 1
'                rtfMain.SelLength = Len(mFind)
'            End If
'            Call rtfMain.SetFocus
'        End If
'    End If
End Sub

Private Sub rtfMain_LostFocus()
    On Error Resume Next
    If Len(rtfMain.text) > 100 Then
        Call SaveCurrentCursorPosition
    End If
End Sub

Private Sub SaveCurrentCursorPosition()
    On Error Resume Next
    'saves the cursor position in the current book, if any
    If gLoadedIndex > -1 And gLoadedIndex < gBooks.documentElement.selectNodes("book").length Then
        gBooks.documentElement.selectNodes("book").Item(gLoadedIndex).selectSingleNode("cursorPos").text = frmBook.rtfMain.SelStart
    End If
End Sub


-->
<pre id="0">
Option Explicit

Private mFind As String

<b>Private Sub cmdOK_Click()</b>
    On Error Resume Next
    Call Me.Hide
<b>End Sub</b>

<b>Private Sub Form_Initialize()</b>
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
<b>End Sub</b>

<b>Private Sub Form_Load()</b>
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    rtfMain.Font.bold = CBool(modPath.GetSettingIni(App.EXEName, "Font", "Bold", "True"))
    rtfMain.Font.name = modPath.GetSettingIni(App.EXEName, "Font", "Name", "Tahoma")
    rtfMain.Font.Charset = CInt(modPath.GetSettingIni(App.EXEName, "Font", "Charset", "0"))
    rtfMain.Font.Italic = CBool(modPath.GetSettingIni(App.EXEName, "Font", "Italic", "False"))
    rtfMain.Font.size = CInt(modPath.GetSettingIni(App.EXEName, "Font", "Size", "14"))
<b>End Sub</b>

<b>Private Sub Form_Resize()</b>
    On Error Resume Next
    Me.Left = frmGutenberg.Left
    Me.Top = frmGutenberg.Top
    Me.Width = frmGutenberg.Width
    Me.Height = frmGutenberg.Height
    rtfMain.Left = 0
    rtfMain.Top = 0
    rtfMain.Height = Me.ScaleHeight - cmdOK.Height - GAP - GAP
    rtfMain.Width = Me.ScaleWidth
    cmdOK.Left = Me.ScaleWidth / 2 - cmdOK.Width / 2
    cmdOK.Top = Me.ScaleHeight - GAP - cmdOK.Height
<b>End Sub</b>

<b>Private Sub Form_Unload(Cancel As Integer)</b>
    On Error Resume Next
    'save current cursor position
    Call SaveCurrentCursorPosition
    If rtfMain.filename &lt;> "" Then Call rtfMain.SaveFile(rtfMain.filename)
    Call modPath.SaveSettingIni(App.EXEName, "Font", "Bold", CStr(rtfMain.Font.bold))
    Call modPath.SaveSettingIni(App.EXEName, "Font", "Name", rtfMain.Font.name)
    Call modPath.SaveSettingIni(App.EXEName, "Font", "Charset", rtfMain.Font.Charset)
    Call modPath.GetSettingIni(App.EXEName, "Font", "Italic", rtfMain.Font.Italic)
    Call modPath.GetSettingIni(App.EXEName, "Font", "Size", rtfMain.Font.size)
<b>End Sub</b>

<b>Private Sub mnuEditCopy_Click()</b>
    On Error Resume Next
    Call SendKeys("^C")
<b>End Sub</b>

<b>Private Sub mnuEditCut_Click()</b>
    On Error Resume Next
    Call SendKeys("^X")
<b>End Sub</b>

<b>Private Sub mnuEditFind_Click()</b>
    On Error Resume Next
    Dim s As String
    s = InputBox("Find what:", "Find", mFind)
    If Len(s) > 0 Then
        mFind = s
        Call Find(s)
    End If
<b>End Sub</b>

<b>Private Sub Find(what As String)</b>
    On Error Resume Next
    Dim found As Long
    
    found = InStr(rtfMain.SelStart + 2, rtfMain.text, what, vbTextCompare)
    If found > 0 Then
        rtfMain.SelStart = found - 1
        rtfMain.SelLength = Len(what)
        rtfMain.SetFocus
    Else
        found = InStr(1, rtfMain.text, what, vbTextCompare)
        If found > 0 Then
            rtfMain.SelStart = found
            rtfMain.SelLength = Len(what)
            rtfMain.SetFocus
        Else
            MsgBox "Cannot find " & what, vbInformation
        End If
    End If
<b>End Sub</b>

<b>Private Sub mnuEditFindnext_Click()</b>
    On Error Resume Next
    Call Find(mFind)
<b>End Sub</b>

<b>Private Sub mnuEditPaste_Click()</b>
    On Error Resume Next
    Call SendKeys("^V")
<b>End Sub</b>

<b>Private Sub mnuEditSelectall_Click()</b>
    On Error Resume Next
    Call SendKeys("^A")
<b>End Sub</b>

<b>Private Sub mnuFileExit_Click()</b>
    On Error Resume Next
    Call Unload(Me)
<b>End Sub</b>

<b>Private Sub mnuFileOpen_Click()</b>
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuFileOpen_Click
<b>End Sub</b>

<b>Private Sub mnuHelpAbout_Click()</b>
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuHelpAbout_Click
<b>End Sub</b>

<b>Private Sub mnuHelpLegal_Click()</b>
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuHelpLegal_Click
<b>End Sub</b>

<b>Private Sub mnuHelpManual_Click()</b>
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.mnuHelpManual_Click
<b>End Sub</b>

<b>Private Sub mnuOptionsFont_Click()</b>
    On Error Resume Next
    Dim sel As Long
    Dim selL As Long
    cdlgFont.Flags = cdlCFEffects
    cdlgFont.Color = rtfMain.SelColor
    On Error GoTo CancelError:
    cdlgFont.ShowFont
    On Error Resume Next
    sel = rtfMain.SelStart
    selL = rtfMain.SelLength
    rtfMain.SelStart = 0
    rtfMain.SelLength = Len(rtfMain.text)
    rtfMain.Font.bold = cdlgFont.FontBold
    rtfMain.Font.name = cdlgFont.FontName
    rtfMain.Font.size = cdlgFont.FontSize
    rtfMain.Font.Underline = cdlgFont.FontUnderline
    rtfMain.SelStart = sel
    rtfMain.SelLength = selL
CancelError:
<b>End Sub</b>

<b>Private Sub mnuViewWhat_Click(index As Integer)</b>
    On Error Resume Next
    If index &lt;> 1 Then
        'back to main form
        Call Me.Hide
        Call frmGutenberg.mnuViewWhat_Click(index)
    End If
<b>End Sub</b>

<b>Private Sub rtfMain_KeyDown(KeyCode As Integer, Shift As Integer)</b>
<font color="green">'    On Error Resume Next</font>
<font color="green">'    Dim start As Long</font>
<font color="green">'    Dim what As String</font>
<font color="green">'</font>
<font color="green">'    If KeyCode = vbKeyF And (Shift And vbCtrlMask) > 0 Then</font>
<font color="green">'        what = InputBox("Find what:", "Find", mFind)</font>
<font color="green">'        If Len(what) > 0 Then</font>
<font color="green">'            mFind = what</font>
<font color="green">'            start = frmBook.rtfMain.SelStart + 2</font>
<font color="green">'            If start > Len(rtfMain.text) Then start = Len(rtfMain.text)</font>
<font color="green">'            start = InStr(start, rtfMain.text, what, vbTextCompare)</font>
<font color="green">'            If start = 0 Then</font>
<font color="green">'                'not found, start from beginning again</font>
<font color="green">'                start = InStr(1, rtfMain.text, what, vbTextCompare)</font>
<font color="green">'                If start = 0 Or start = rtfMain.SelStart Then</font>
<font color="green">'                    'not found at all</font>
<font color="green">'                    Call Beep</font>
<font color="green">'                Else</font>
<font color="green">'                    rtfMain.SelStart = start</font>
<font color="green">'                    rtfMain.SelLength = Len(mFind)</font>
<font color="green">'                End If</font>
<font color="green">'            Else</font>
<font color="green">'                'found!</font>
<font color="green">'                rtfMain.SelStart = start - 1</font>
<font color="green">'                rtfMain.SelLength = Len(mFind)</font>
<font color="green">'            End If</font>
<font color="green">'            Call rtfMain.SetFocus</font>
<font color="green">'        End If</font>
<font color="green">'    End If</font>
<b>End Sub</b>

<b>Private Sub rtfMain_LostFocus()</b>
    On Error Resume Next
    If Len(rtfMain.text) > 100 Then
        Call SaveCurrentCursorPosition
    End If
<b>End Sub</b>

<b>Private Sub SaveCurrentCursorPosition()</b>
    On Error Resume Next
    'saves the cursor position in the current book, if any
    If gLoadedIndex > -1 And gLoadedIndex &lt; gBooks.documentElement.selectNodes("book").length Then
        gBooks.documentElement.selectNodes("book").Item(gLoadedIndex).selectSingleNode("cursorPos").text = frmBook.rtfMain.SelStart
    End If
<b>End Sub</b>


</pre>
<h2>VB.Form frmProgress </h2>
<p>Filename: frmProgress.frm</p><p>Date last modified: Mon Jun 2009 21:47</p><!-- 
VERSION 5.00
Object = "{6B7E6392-850A-101B-AFC0-4210102A8DA7}#1.3#0"; "comctl32.ocx"
Begin VB.Form frmProgress 
   BorderStyle     =   3  'Fixed Dialog
   Caption         =   "Book download progress"
   ClientHeight    =   1170
   ClientLeft      =   45
   ClientTop       =   435
   ClientWidth     =   6915
   ControlBox      =   0   'False
   Icon            =   "frmProgress.frx":0000
   LinkTopic       =   "Form1"
   MaxButton       =   0   'False
   MinButton       =   0   'False
   ScaleHeight     =   1170
   ScaleWidth      =   6915
   ShowInTaskbar   =   0   'False
   StartUpPosition =   3  'Windows Default
   Begin ComctlLib.ProgressBar prgDownload 
      Height          =   375
      Left            =   90
      TabIndex        =   1
      Top             =   480
      Width           =   6735
      _ExtentX        =   11880
      _ExtentY        =   661
      _Version        =   327682
      Appearance      =   1
   End
   Begin VB.Label lblProgress 
      AutoSize        =   -1  'True
      Caption         =   "&Progress"
      Height          =   195
      Left            =   120
      TabIndex        =   0
      Top             =   120
      Width           =   615
   End
End
Attribute VB_Name = "frmProgress"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Option Explicit

Private WithEvents mDownloader As clsDownloader
Attribute mDownloader.VB_VarHelpID = -1
Private mURL As String
Private mFilename As String
Private mName As String

Private Sub Form_Activate()
    On Error Resume Next
    Call mDownloader.Download(mURL, mFilename)
End Sub

Private Sub Form_Initialize()
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
End Sub

Private Sub Form_Load()
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    Set mDownloader = New clsDownloader
    Call modRememberPosition.LoadPosition(Me)
End Sub

Private Sub Form_Resize()
    On Error Resume Next
    lblProgress.Left = GAP
    lblProgress.Top = GAP
    prgDownload.Left = lblProgress.Left
    prgDownload.Top = lblProgress.Top + lblProgress.Height + GAP
    Me.Left = Screen.Width / 2 - Me.Width / 2
    Me.Top = Screen.Height / 2 - Me.Height / 2
    Call Me.Refresh
End Sub

Public Sub SetDownload(url As String, filename As String, Optional name As String)
    On Error Resume Next
    prgDownload.value = 0
    mURL = url
    mFilename = filename
    mName = name
End Sub

Private Sub Form_Unload(Cancel As Integer)
    On Error Resume Next
    Call modRememberPosition.SavePosition(Me)
End Sub

Private Sub mDownloader_Complete(filename As String, url As String)
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.BookDownloaded(filename, url)
End Sub

Private Sub mDownloader_Failed(message As String)
    On Error Resume Next
    MsgBox message, vbExclamation
    Call Me.Hide
End Sub

Private Sub mDownloader_Progress(retrieved As Long, total As Long)
    On Error Resume Next
    Dim s As String
    s = Round(retrieved / total, 2) * 100 & "% "
    If Len(mName) > 0 Then
        s = s & modI18N.GetText("of") & " " & mName
    End If
    lblProgress.Caption = s
    prgDownload.value = Round(retrieved / total, 2) * 100
End Sub

-->
<pre id="0">
Option Explicit

Private WithEvents mDownloader As clsDownloader
Attribute mDownloader.VB_VarHelpID = -1
Private mURL As String
Private mFilename As String
Private mName As String

<b>Private Sub Form_Activate()</b>
    On Error Resume Next
    Call mDownloader.Download(mURL, mFilename)
<b>End Sub</b>

<b>Private Sub Form_Initialize()</b>
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
<b>End Sub</b>

<b>Private Sub Form_Load()</b>
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
    Set mDownloader = New clsDownloader
    Call modRememberPosition.LoadPosition(Me)
<b>End Sub</b>

<b>Private Sub Form_Resize()</b>
    On Error Resume Next
    lblProgress.Left = GAP
    lblProgress.Top = GAP
    prgDownload.Left = lblProgress.Left
    prgDownload.Top = lblProgress.Top + lblProgress.Height + GAP
    Me.Left = Screen.Width / 2 - Me.Width / 2
    Me.Top = Screen.Height / 2 - Me.Height / 2
    Call Me.Refresh
<b>End Sub</b>

<b>Public Sub SetDownload(url As String, filename As String, Optional name As String)</b>
    On Error Resume Next
    prgDownload.value = 0
    mURL = url
    mFilename = filename
    mName = name
<b>End Sub</b>

<b>Private Sub Form_Unload(Cancel As Integer)</b>
    On Error Resume Next
    Call modRememberPosition.SavePosition(Me)
<b>End Sub</b>

<b>Private Sub mDownloader_Complete(filename As String, url As String)</b>
    On Error Resume Next
    Call Me.Hide
    Call frmGutenberg.BookDownloaded(filename, url)
<b>End Sub</b>

<b>Private Sub mDownloader_Failed(message As String)</b>
    On Error Resume Next
    MsgBox message, vbExclamation
    Call Me.Hide
<b>End Sub</b>

<b>Private Sub mDownloader_Progress(retrieved As Long, total As Long)</b>
    On Error Resume Next
    Dim s As String
    s = Round(retrieved / total, 2) * 100 & "% "
    If Len(mName) > 0 Then
        s = s & modI18N.GetText("of") & " " & mName
    End If
    lblProgress.Caption = s
    prgDownload.value = Round(retrieved / total, 2) * 100
<b>End Sub</b>

</pre>
<h2>VB.Form frmAccessing </h2>
<p>Filename: frmAccessing.frm</p><p>Date last modified: Mon Jun 2009 22:21</p><!-- 
VERSION 5.00
Begin VB.Form frmAccessing 
   BorderStyle     =   0  'None
   Caption         =   "Accessing Gutenberg..."
   ClientHeight    =   3090
   ClientLeft      =   0
   ClientTop       =   0
   ClientWidth     =   4680
   BeginProperty Font 
      Name            =   "Arial"
      Size            =   12
      Charset         =   204
      Weight          =   700
      Underline       =   0   'False
      Italic          =   0   'False
      Strikethrough   =   0   'False
   EndProperty
   LinkTopic       =   "Form1"
   MaxButton       =   0   'False
   MinButton       =   0   'False
   ScaleHeight     =   3090
   ScaleWidth      =   4680
   StartUpPosition =   3  'Windows Default
   Begin VB.Line linRight 
      X1              =   4680
      X2              =   4680
      Y1              =   0
      Y2              =   360
   End
   Begin VB.Line linLeft 
      BorderWidth     =   2
      X1              =   0
      X2              =   0
      Y1              =   0
      Y2              =   1680
   End
   Begin VB.Line linBottom 
      X1              =   0
      X2              =   4680
      Y1              =   360
      Y2              =   360
   End
   Begin VB.Line linTop 
      X1              =   0
      X2              =   4680
      Y1              =   0
      Y2              =   0
   End
   Begin VB.Label lblAccessing 
      AutoSize        =   -1  'True
      BackStyle       =   0  'Transparent
      Caption         =   "Accessing Gutenberg, please wait..."
      Height          =   300
      Left            =   120
      TabIndex        =   0
      Top             =   0
      Width           =   4335
   End
End
Attribute VB_Name = "frmAccessing"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Option Explicit

Private Sub Form_Initialize()
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
End Sub

Private Sub Form_Load()
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
End Sub

Private Sub Form_Resize()
    On Error Resume Next
    lblAccessing.Left = GAP
    lblAccessing.Top = GAP
    Me.Width = lblAccessing.Width + GAP + GAP
    Me.Height = lblAccessing.Height + GAP + GAP
    Me.Left = Screen.Width / 2 - Me.Width / 2
    Me.Top = Screen.Height / 2 - Me.Height / 2
    linTop.X1 = 0
    linTop.X2 = Me.Width
    linTop.Y1 = 0
    linTop.Y2 = 0
    'linLeft.X1 = 1
    'linLeft.X2 = 1
    'linLeft.Y1 = -100
    'linLeft.Y1 = Me.Height
    linRight.X1 = Me.Width - Screen.TwipsPerPixelX
    linRight.X2 = Me.Width - Screen.TwipsPerPixelX
    linRight.Y1 = 0
    linRight.Y2 = Me.Height
    linBottom.X1 = 0
    linBottom.X2 = Me.Width
    linBottom.Y1 = Me.Height - Screen.TwipsPerPixelY
    linBottom.Y2 = Me.Height - Screen.TwipsPerPixelY
End Sub

-->
<pre id="0">
Option Explicit

<b>Private Sub Form_Initialize()</b>
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
<b>End Sub</b>

<b>Private Sub Form_Load()</b>
    On Error Resume Next
    Call modI18N.ApplyUILanguageToThisForm(Me)
    Call modLargeFonts.ApplySystemSettingsToForm(Me, , True)
<b>End Sub</b>

<b>Private Sub Form_Resize()</b>
    On Error Resume Next
    lblAccessing.Left = GAP
    lblAccessing.Top = GAP
    Me.Width = lblAccessing.Width + GAP + GAP
    Me.Height = lblAccessing.Height + GAP + GAP
    Me.Left = Screen.Width / 2 - Me.Width / 2
    Me.Top = Screen.Height / 2 - Me.Height / 2
    linTop.X1 = 0
    linTop.X2 = Me.Width
    linTop.Y1 = 0
    linTop.Y2 = 0
    'linLeft.X1 = 1
    'linLeft.X2 = 1
    'linLeft.Y1 = -100
    'linLeft.Y1 = Me.Height
    linRight.X1 = Me.Width - Screen.TwipsPerPixelX
    linRight.X2 = Me.Width - Screen.TwipsPerPixelX
    linRight.Y1 = 0
    linRight.Y2 = Me.Height
    linBottom.X1 = 0
    linBottom.X2 = Me.Width
    linBottom.Y1 = Me.Height - Screen.TwipsPerPixelY
    linBottom.Y2 = Me.Height - Screen.TwipsPerPixelY
<b>End Sub</b>

</pre>
<h2>VB.Form frmLargeFonts </h2>
<p>Filename: ..\Common\frmLargeFonts.frm</p><p>Date last modified: Fri Aug 2009 09:01</p><!-- 
VERSION 5.00
Begin VB.Form frmLargeFonts 
   Caption         =   "Large Fonts"
   ClientHeight    =   3060
   ClientLeft      =   60
   ClientTop       =   600
   ClientWidth     =   4650
   LinkTopic       =   "Form1"
   ScaleHeight     =   3060
   ScaleWidth      =   4650
   StartUpPosition =   3  'Windows Default
   Begin VB.Label lblSizer 
      AutoSize        =   -1  'True
      Height          =   210
      Left            =   120
      TabIndex        =   0
      Top             =   120
      Width           =   45
   End
End
Attribute VB_Name = "frmLargeFonts"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
'Resizes controls to fit contents, typically for large fonts.

Option Explicit

Public Sub SizeToFit(ByRef c As Control)
    On Error Resume Next
    Dim newSize As Long
    Select Case TypeName(c)
        Case "CommandButton"
            Set lblSizer.Font = c.Font
            'Debug.Print
            'Debug.Print "Size before: " & lblSizer.width
            lblSizer.Caption = c.Caption
            lblSizer.Refresh
            'Debug.Print "Size after: " & lblSizer.width
            newSize = lblSizer.Width * 1.4
            'Debug.Print "Button size: " & c.width
            If c.Width < newSize Then c.Width = newSize
            newSize = lblSizer.Height * 1.8
            If c.Height < newSize Then c.Height = newSize
        Case "OptionButton"
            Set lblSizer.Font = c.Font
            lblSizer.Caption = c.Caption
            lblSizer.Refresh
            newSize = lblSizer.Width * 1 + 600
            If c.Width < newSize Then
                c.Width = newSize
            End If
            newSize = lblSizer.Height * 1.8
            If c.Height < newSize Then c.Height = newSize
        Case "CheckBox"
            Set lblSizer.Font = c.Font
            lblSizer.Caption = c.Caption
            lblSizer.Refresh
            newSize = lblSizer.Width * 1 + 500
            If c.Width < newSize Then
                c.Width = newSize
            End If
            newSize = lblSizer.Height * 1.8
            If c.Height < newSize Then c.Height = newSize
        Case "TextBox"
            Set lblSizer.Font = c.Font
            lblSizer.Caption = "Test"
            lblSizer.Refresh
            newSize = lblSizer.Height * 1.8
            If c.Height < newSize Then c.Height = newSize
        Case Else
            'Debug.Print "TypenName:" & TypeName(c)
    End Select
End Sub

Private Sub Form_Initialize()
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
End Sub


-->
<pre id="0">
Option Explicit

<b>Public Sub SizeToFit(ByRef c As Control)</b>
    On Error Resume Next
    Dim newSize As Long
    Select Case TypeName(c)
        Case "CommandButton"
            Set lblSizer.Font = c.Font
            'Debug.Print
            'Debug.Print "Size before: " & lblSizer.width
            lblSizer.Caption = c.Caption
            lblSizer.Refresh
            'Debug.Print "Size after: " & lblSizer.width
            newSize = lblSizer.Width * 1.4
            'Debug.Print "Button size: " & c.width
            If c.Width &lt; newSize Then c.Width = newSize
            newSize = lblSizer.Height * 1.8
            If c.Height &lt; newSize Then c.Height = newSize
        Case "OptionButton"
            Set lblSizer.Font = c.Font
            lblSizer.Caption = c.Caption
            lblSizer.Refresh
            newSize = lblSizer.Width * 1 + 600
            If c.Width &lt; newSize Then
                c.Width = newSize
            End If
            newSize = lblSizer.Height * 1.8
            If c.Height &lt; newSize Then c.Height = newSize
        Case "CheckBox"
            Set lblSizer.Font = c.Font
            lblSizer.Caption = c.Caption
            lblSizer.Refresh
            newSize = lblSizer.Width * 1 + 500
            If c.Width &lt; newSize Then
                c.Width = newSize
            End If
            newSize = lblSizer.Height * 1.8
            If c.Height &lt; newSize Then c.Height = newSize
        Case "TextBox"
            Set lblSizer.Font = c.Font
            lblSizer.Caption = "Test"
            lblSizer.Refresh
            newSize = lblSizer.Height * 1.8
            If c.Height &lt; newSize Then c.Height = newSize
        Case Else
            'Debug.Print "TypenName:" & TypeName(c)
    End Select
<b>End Sub</b>

<b>Private Sub Form_Initialize()</b>
    On Error Resume Next
    Call modXPStyle.InitCommonControlsVB
<b>End Sub</b>


</pre>
<h2>Module Globals</h2>
<p>Filename: Globals.bas</p><p>Date last modified: Wed Jan 2009 23:01</p><!-- 
Attribute VB_Name = "Globals"
Option Explicit

Public gBooks As DOMDocument30 ' index for the saved books
Public gLoadedIndex As Long  ' which book is currently loaded
Public gLoadingID As String

Public Function GetUniqueKey() As String
'Generates a unique key for naming nodes in the tvwDirectory.
    On Error Resume Next
    Static keyCount As Long
    keyCount = keyCount + 1
    GetUniqueKey = "uk-" & keyCount
End Function

-->
<pre id="0">
Option Explicit

Public gBooks As DOMDocument30 ' index for the saved books
Public gLoadedIndex As Long  ' which book is currently loaded
Public gLoadingID As String

<b>Public Function GetUniqueKey() As String</b>
<font color="green">'Generates a unique key for naming nodes in the tvwDirectory.</font>
    On Error Resume Next
    Static keyCount As Long
    keyCount = keyCount + 1
    GetUniqueKey = "uk-" & keyCount
End Function

</pre>
<h2>Module modRememberPosition</h2>
<p>Filename: ..\Common\modRememberPosition.bas</p><p>Date last modified: Mon Mar 2009 19:16</p><!-- 
Attribute VB_Name = "modRememberPosition"
'Code to ensure your form is correctly positioned according to where you previously
'put it.

'23 Mar 2009
'   Updated to prevent settings being saved when form exits minimized.

Option Explicit

Public Sub LoadPosition(f As Form)
'Load position of f from ini file. Call in Form_Load.
    On Error Resume Next
    If CInt(modPath.GetSettingIni(App.EXEName, f.name & "Position", "Maximised", vbMaximized)) = vbMaximized Then f.WindowState = vbMaximized
    f.left = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Left", f.left)
    If f.left < 0 Then f.left = 0
    f.Top = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Top", f.Top)
    If f.Top < 0 Then f.Top = 0
    f.width = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Width", f.width)
    f.height = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Height", f.height)
    
End Sub

Public Sub SavePosition(f As Form)
'Save position of f to ini file. Call in Form_Unload.
    On Error Resume Next
    If f.WindowState = vbMinimized Then
        'Don't save settings, we're just closed from start bar.
    Else
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Left", f.left)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Top", f.Top)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Width", f.width)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Height", f.height)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Maximised", CStr(f.WindowState))
    End If
End Sub

-->
<pre id="0">
Option Explicit

<b>Public Sub LoadPosition(f As Form)</b>
<font color="green">'Load position of f from ini file. Call in Form_Load.</font>
    On Error Resume Next
    If CInt(modPath.GetSettingIni(App.EXEName, f.name & "Position", "Maximised", vbMaximized)) = vbMaximized Then f.WindowState = vbMaximized
    f.left = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Left", f.left)
    If f.left &lt; 0 Then f.left = 0
    f.Top = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Top", f.Top)
    If f.Top &lt; 0 Then f.Top = 0
    f.width = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Width", f.width)
    f.height = modPath.GetSettingIni(App.EXEName, f.name & "Position", "Height", f.height)
    
<b>End Sub</b>

<b>Public Sub SavePosition(f As Form)</b>
<font color="green">'Save position of f to ini file. Call in Form_Unload.</font>
    On Error Resume Next
    If f.WindowState = vbMinimized Then
        'Don't save settings, we're just closed from start bar.
    Else
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Left", f.left)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Top", f.Top)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Width", f.width)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Height", f.height)
        Call modPath.SaveSettingIni(App.EXEName, f.name & "Position", "Maximised", CStr(f.WindowState))
    End If
<b>End Sub</b>

</pre>
<h2>Module modLargeFonts</h2>
<p>Filename: ..\Common\modLargeFonts.bas</p><p>Date last modified: Fri Aug 2009 09:05</p><!-- 
Attribute VB_Name = "modLargeFonts"
Option Explicit
'Gets font size in Windows, for handling large fonts settings.

'From http://www.vbaccelerator.com/home/VB/Tips/Get_System_Display_Fonts_and_Non-Client_Area_Sizes/article.asp
'See also http://msdn2.microsoft.com/en-us/library/ms724506.aspx

'HOW TO USE
'1 Add this module to your project.
'2 Add frmLargeFonts to your project.
'3 For each font call this module in Form_Load:
'   Call modLargeFonts.ApplySystemSettingsToForm(Me)
'4 Write Form_Resize code to handle when all your labels etc. change size...
    
Private Const SPI_GETICONMETRICS = 45
Private Const SPI_GETICONTITLELOGFONT = 31
Private Const LF_FACESIZE = 32
Private Const LF_FULLFACESIZE = 64

Private Const HASNOT_FONT As String = "*WebBrowser*Winsock*CommonDialog*Timer*Menu*ProgressBar*Slider*WindowsMediaPlayer*"
Private Const HAS_FONT As String = "*Label*DUniLabel*UniLabel*ComboBox*TextBox*Frame*CommandButton*CheckBox*OptionButton*ListBox*TabStrip*Toolbar*StatusBar*TreeView*ListView*ImageCombo*DUniText*DUniList*DUniCombo*"

' Normal log font structure:
Private Type LOGFONT
   lfHeight As Long
   lfWidth As Long
   lfEscapement As Long
   lfOrientation As Long
   lfWeight As Long
   lfItalic As Byte
   lfUnderline As Byte
   lfStrikeOut As Byte
   lfCharSet As Byte
   lfOutPrecision As Byte
   lfClipPrecision As Byte
   lfQuality As Byte
   lfPitchAndFamily As Byte
   lfFaceName(LF_FACESIZE) As Byte
End Type
Private Enum CNCMetricsFontWeightConstants
   FW_DONTCARE = 0
   FW_THIN = 100
   FW_EXTRALIGHT = 200
   FW_ULTRALIGHT = 200
   FW_LIGHT = 300
   FW_NORMAL = 400
   FW_REGULAR = 400
   FW_MEDIUM = 500
   FW_SEMIBOLD = 600
   FW_DEMIBOLD = 600
   FW_BOLD = 700
   FW_EXTRABOLD = 800
   FW_ULTRABOLD = 800
   FW_HEAVY = 900
   FW_BLACK = 900
End Enum
' For some bizarre reason, maybe to do with byte
' alignment, the LOGFONT structure we must apply
' to NONCLIENTMETRICS seems to require an LF_FACESIZE
' 4 bytes smaller than normal:
Private Type NMLOGFONT
   lfHeight As Long
   lfWidth As Long
   lfEscapement As Long
   lfOrientation As Long
   lfWeight As Long
   lfItalic As Byte
   lfUnderline As Byte
   lfStrikeOut As Byte
   lfCharSet As Byte
   lfOutPrecision As Byte
   lfClipPrecision As Byte
   lfQuality As Byte
   lfPitchAndFamily As Byte
   lfFaceName(LF_FACESIZE - 4) As Byte
End Type
Private Type NONCLIENTMETRICS
   cbSize As Long
   iBorderWidth As Long
   iScrollWidth As Long
   iScrollHeight As Long
   iCaptionWidth As Long
   iCaptionHeight As Long
   lfCaptionFont As NMLOGFONT
   iSMCaptionWidth As Long
   iSMCaptionHeight As Long
   lfSMCaptionFont As NMLOGFONT
   iMenuWidth As Long
   iMenuHeight As Long
   lfMenuFont As NMLOGFONT
   lfStatusFont As NMLOGFONT
   lfMessageFont As NMLOGFONT
End Type
Private Const SPI_GETNONCLIENTMETRICS = 41
Private Const SPI_SETNONCLIENTMETRICS = 42
Private Declare Function SystemParametersInfo Lib "USER32" Alias "SystemParametersInfoA" ( _
   ByVal uAction As Long, _
   ByVal uParam As Long, _
    lpvParam As Any, _
   ByVal fuWinIni As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
   lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
Private Const LOGPIXELSY = 90 ' Logical pixels/inch in Y
Private Declare Function CreateFontIndirect Lib "gdi32" Alias "CreateFontIndirectA" (lpLogFont As LOGFONT) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long

Private m_tNCM As NONCLIENTMETRICS
Private m_tLF As LOGFONT

Private Enum CNCMetricsFontTypes
   IconFont = 1
   CaptionFont = 2
   SMCaptionFont = 3
   MenuFont = 4
   StatusFont = 5
   MessageFont = 6
End Enum

Private Function GetMetrics() As Boolean
    Dim lR As Long
   ' Get Non-client metrics:
   m_tNCM.cbSize = 340
   lR = SystemParametersInfo( _
     SPI_GETNONCLIENTMETRICS, _
     0, _
     m_tNCM, _
     0)
   If (lR <> 0) Then
     ' Get icon font:
     lR = SystemParametersInfo( _
       SPI_GETICONTITLELOGFONT, _
       0, _
       m_tLF, _
       0)
     GetMetrics = (lR <> 0)
   End If
End Function

Private Function GetFont( _
     ByVal hDC As Long, _
     ByVal eFontNum As CNCMetricsFontTypes _
   ) As StdFont
   
Dim tLF As LOGFONT

   Select Case eFontNum
   Case StatusFont
     CopyMemory tLF, m_tNCM.lfStatusFont, LenB(m_tNCM.lfStatusFont)
   Case SMCaptionFont
     CopyMemory tLF, m_tNCM.lfSMCaptionFont, LenB(m_tNCM.lfSMCaptionFont)
   Case MessageFont
     CopyMemory tLF, m_tNCM.lfMessageFont, LenB(m_tNCM.lfMessageFont)
   Case MenuFont
     CopyMemory tLF, m_tNCM.lfMenuFont, LenB(m_tNCM.lfMenuFont)
   Case IconFont
     CopyMemory tLF, m_tLF, LenB(m_tLF)
   Case CaptionFont
     CopyMemory tLF, m_tNCM.lfCaptionFont, LenB(m_tNCM.lfCaptionFont)
   Case Else
     Exit Function
   End Select

   ' This demonstrates how to return a VB style font.
   ' If you want an API hFont, just do this:
   ' hFont = CreateFontIndirect(tLF)
   ' Remember to use DeleteObject hFont when you've
   ' finished with it.
   Dim sFnt As New StdFont
   pLogFontToStdFont tLF, hDC, sFnt
   Set GetFont = sFnt

End Function

Private Sub pLogFontToStdFont(ByRef tLF As LOGFONT, ByVal hDC As Long, ByRef sFnt As StdFont)
   With sFnt
     .name = StrConv(tLF.lfFaceName, vbUnicode)
     If tLF.lfHeight < 1 Then
        If tLF.lfHeight <> 0 Then
            .size = Abs((72# / GetDeviceCaps(hDC, LOGPIXELSY)) * tLF.lfHeight)
        End If
     Else
       .size = tLF.lfHeight
     End If
     .Charset = tLF.lfCharSet
     .Italic = Not (tLF.lfItalic = 0)
     .Underline = Not (tLF.lfUnderline = 0)
     .Strikethrough = Not (tLF.lfStrikeOut = 0)
     .bold = (tLF.lfWeight > FW_REGULAR)
   End With
End Sub

Private Function GetCaptionHeight() As Long
   GetCaptionHeight = m_tNCM.iCaptionHeight
End Function
Private Function GetCaptionWIdth() As Long
   GetCaptionWIdth = m_tNCM.iCaptionWidth
End Function
Private Function GetMenuHeight() As Long
   GetMenuHeight = m_tNCM.iMenuHeight
End Function
Private Function GetMenuWidth() As Long
   GetMenuWidth = m_tNCM.iMenuWidth
End Function
Private Function GetScrollHeight() As Long
   GetScrollHeight = m_tNCM.iScrollHeight
End Function
Private Function GetScrollWidth() As Long
   GetScrollWidth = m_tNCM.iScrollWidth
End Function
Private Function GetSMCaptionHeight() As Long
   GetSMCaptionHeight = m_tNCM.iSMCaptionHeight
End Function
Private Function GetSMCaptionWIdth() As Long
   GetSMCaptionWIdth = m_tNCM.iSMCaptionWidth
End Function
Private Function GetBorderWidth() As Long
   GetBorderWidth = m_tNCM.iBorderWidth
End Function

Public Sub ApplySystemSettingsToForm(aForm As Form, Optional controlsExcluded As String, Optional retainLargerFonts As Boolean = False)
    On Error Resume Next
    Dim c As Control
    Dim statusF As StdFont
    Dim messageF As StdFont
    
    'Remember existing font size
    Call GetMetrics
    Set statusF = GetFont(aForm.hDC, StatusFont)
    Set messageF = GetFont(aForm.hDC, MessageFont)
    Call ApplyFont(aForm, messageF, retainLargerFonts)
    Load frmLargeFonts
    For Each c In aForm.Controls
        'check this isn't a control the user has indicated shouldn't be operated on
        If InStr(1, controlsExcluded, c.name) = 0 Then
            Select Case TypeName(c)
                Case "StatusBar"
                    Call ApplyFont(c, statusF, retainLargerFonts)
                Case Else
                    If HasFont(c) Then
                        Call ApplyFont(c, messageF, retainLargerFonts)
                    End If
            End Select
            Call frmLargeFonts.SizeToFit(c)
        End If
    Next c
    Call Unload(frmLargeFonts)
    Exit Sub
End Sub

Private Function HasFont(c As Control) As Boolean
    On Error Resume Next
    HasFont = (InStr(1, HAS_FONT, TypeName(c)) > 0)
End Function

Private Sub ApplyFont(uiObject As Object, newFont As StdFont, retainLargerFonts As Boolean)
'Applies the font newFont to the form or control uiObject, but checks bold and font size against
'existing bold and font size and keeps the "more visible" ones if retainLargerFonts is true
    On Error Resume Next
    Dim size As Single
    Dim bold As Boolean
    
    If TypeName(uiObject) = "Toolbar" Then
        'No font object to manipulate
    Else
        size = newFont.size
        size = uiObject.Font.size
        bold = uiObject.Font.bold
        Set uiObject.Font = newFont
        If retainLargerFonts Then
            If uiObject.Font.size < size Then uiObject.Font.size = size
            If (Not uiObject.Font.bold) And bold Then uiObject.Font.bold = True
        End If
    End If
        
    
End Sub



-->
<pre id="0">
Option Explicit
<font color="green">'Gets font size in Windows, for handling large fonts settings.</font>

<font color="green">'From http://www.vbaccelerator.com/home/VB/Tips/Get_System_Display_Fonts_and_Non-Client_Area_Sizes/article.asp</font>
<font color="green">'See also http://msdn2.microsoft.com/en-us/library/ms724506.aspx</font>

<font color="green">'HOW TO USE</font>
<font color="green">'1 Add this module to your project.</font>
<font color="green">'2 Add frmLargeFonts to your project.</font>
<font color="green">'3 For each font call this module in Form_Load:</font>
<font color="green">'   Call modLargeFonts.ApplySystemSettingsToForm(Me)</font>
<font color="green">'4 Write Form_Resize code to handle when all your labels etc. change size...</font>
    
Private Const SPI_GETICONMETRICS = 45
Private Const SPI_GETICONTITLELOGFONT = 31
Private Const LF_FACESIZE = 32
Private Const LF_FULLFACESIZE = 64

Private Const HASNOT_FONT As String = "*WebBrowser*Winsock*CommonDialog*Timer*Menu*ProgressBar*Slider*WindowsMediaPlayer*"
Private Const HAS_FONT As String = "*Label*DUniLabel*UniLabel*ComboBox*TextBox*Frame*CommandButton*CheckBox*OptionButton*ListBox*TabStrip*Toolbar*StatusBar*TreeView*ListView*ImageCombo*DUniText*DUniList*DUniCombo*"

<font color="green">' Normal log font structure:</font>
Private Type LOGFONT
   lfHeight As Long
   lfWidth As Long
   lfEscapement As Long
   lfOrientation As Long
   lfWeight As Long
   lfItalic As Byte
   lfUnderline As Byte
   lfStrikeOut As Byte
   lfCharSet As Byte
   lfOutPrecision As Byte
   lfClipPrecision As Byte
   lfQuality As Byte
   lfPitchAndFamily As Byte
   lfFaceName(LF_FACESIZE) As Byte
End Type
Private Enum CNCMetricsFontWeightConstants
   FW_DONTCARE = 0
   FW_THIN = 100
   FW_EXTRALIGHT = 200
   FW_ULTRALIGHT = 200
   FW_LIGHT = 300
   FW_NORMAL = 400
   FW_REGULAR = 400
   FW_MEDIUM = 500
   FW_SEMIBOLD = 600
   FW_DEMIBOLD = 600
   FW_BOLD = 700
   FW_EXTRABOLD = 800
   FW_ULTRABOLD = 800
   FW_HEAVY = 900
   FW_BLACK = 900
End Enum
<font color="green">' For some bizarre reason, maybe to do with byte</font>
<font color="green">' alignment, the LOGFONT structure we must apply</font>
<font color="green">' to NONCLIENTMETRICS seems to require an LF_FACESIZE</font>
<font color="green">' 4 bytes smaller than normal:</font>
Private Type NMLOGFONT
   lfHeight As Long
   lfWidth As Long
   lfEscapement As Long
   lfOrientation As Long
   lfWeight As Long
   lfItalic As Byte
   lfUnderline As Byte
   lfStrikeOut As Byte
   lfCharSet As Byte
   lfOutPrecision As Byte
   lfClipPrecision As Byte
   lfQuality As Byte
   lfPitchAndFamily As Byte
   lfFaceName(LF_FACESIZE - 4) As Byte
End Type
Private Type NONCLIENTMETRICS
   cbSize As Long
   iBorderWidth As Long
   iScrollWidth As Long
   iScrollHeight As Long
   iCaptionWidth As Long
   iCaptionHeight As Long
   lfCaptionFont As NMLOGFONT
   iSMCaptionWidth As Long
   iSMCaptionHeight As Long
   lfSMCaptionFont As NMLOGFONT
   iMenuWidth As Long
   iMenuHeight As Long
   lfMenuFont As NMLOGFONT
   lfStatusFont As NMLOGFONT
   lfMessageFont As NMLOGFONT
End Type
Private Const SPI_GETNONCLIENTMETRICS = 41
Private Const SPI_SETNONCLIENTMETRICS = 42
Private Declare Function SystemParametersInfo Lib "USER32" Alias "SystemParametersInfoA" ( _
   ByVal uAction As Long, _
   ByVal uParam As Long, _
    lpvParam As Any, _
   ByVal fuWinIni As Long) As Long
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
   lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
Private Const LOGPIXELSY = 90 ' Logical pixels/inch in Y
Private Declare Function CreateFontIndirect Lib "gdi32" Alias "CreateFontIndirectA" (lpLogFont As LOGFONT) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long

Private m_tNCM As NONCLIENTMETRICS
Private m_tLF As LOGFONT

Private Enum CNCMetricsFontTypes
   IconFont = 1
   CaptionFont = 2
   SMCaptionFont = 3
   MenuFont = 4
   StatusFont = 5
   MessageFont = 6
End Enum

<b>Private Function GetMetrics() As Boolean</b>
    Dim lR As Long
   ' Get Non-client metrics:
   m_tNCM.cbSize = 340
   lR = SystemParametersInfo( _
     SPI_GETNONCLIENTMETRICS, _
     0, _
     m_tNCM, _
     0)
   If (lR &lt;> 0) Then
     ' Get icon font:
     lR = SystemParametersInfo( _
       SPI_GETICONTITLELOGFONT, _
       0, _
       m_tLF, _
       0)
     GetMetrics = (lR &lt;> 0)
   End If
End Function

<b>Private Function GetFont( _</b>
     ByVal hDC As Long, _
     ByVal eFontNum As CNCMetricsFontTypes _
   ) As StdFont
   
Dim tLF As LOGFONT

   Select Case eFontNum
   Case StatusFont
     CopyMemory tLF, m_tNCM.lfStatusFont, LenB(m_tNCM.lfStatusFont)
   Case SMCaptionFont
     CopyMemory tLF, m_tNCM.lfSMCaptionFont, LenB(m_tNCM.lfSMCaptionFont)
   Case MessageFont
     CopyMemory tLF, m_tNCM.lfMessageFont, LenB(m_tNCM.lfMessageFont)
   Case MenuFont
     CopyMemory tLF, m_tNCM.lfMenuFont, LenB(m_tNCM.lfMenuFont)
   Case IconFont
     CopyMemory tLF, m_tLF, LenB(m_tLF)
   Case CaptionFont
     CopyMemory tLF, m_tNCM.lfCaptionFont, LenB(m_tNCM.lfCaptionFont)
   Case Else
     Exit Function
   End Select

   ' This demonstrates how to return a VB style font.
   ' If you want an API hFont, just do this:
   ' hFont = CreateFontIndirect(tLF)
   ' Remember to use DeleteObject hFont when you've
   ' finished with it.
   Dim sFnt As New StdFont
   pLogFontToStdFont tLF, hDC, sFnt
   Set GetFont = sFnt

End Function

<b>Private Sub pLogFontToStdFont(ByRef tLF As LOGFONT, ByVal hDC As Long, ByRef sFnt As StdFont)</b>
   With sFnt
     .name = StrConv(tLF.lfFaceName, vbUnicode)
     If tLF.lfHeight &lt; 1 Then
        If tLF.lfHeight &lt;> 0 Then
            .size = Abs((72# / GetDeviceCaps(hDC, LOGPIXELSY)) * tLF.lfHeight)
        End If
     Else
       .size = tLF.lfHeight
     End If
     .Charset = tLF.lfCharSet
     .Italic = Not (tLF.lfItalic = 0)
     .Underline = Not (tLF.lfUnderline = 0)
     .Strikethrough = Not (tLF.lfStrikeOut = 0)
     .bold = (tLF.lfWeight > FW_REGULAR)
   End With
<b>End Sub</b>

<b>Private Function GetCaptionHeight() As Long</b>
   GetCaptionHeight = m_tNCM.iCaptionHeight
End Function
<b>Private Function GetCaptionWIdth() As Long</b>
   GetCaptionWIdth = m_tNCM.iCaptionWidth
End Function
<b>Private Function GetMenuHeight() As Long</b>
   GetMenuHeight = m_tNCM.iMenuHeight
End Function
<b>Private Function GetMenuWidth() As Long</b>
   GetMenuWidth = m_tNCM.iMenuWidth
End Function
<b>Private Function GetScrollHeight() As Long</b>
   GetScrollHeight = m_tNCM.iScrollHeight
End Function
<b>Private Function GetScrollWidth() As Long</b>
   GetScrollWidth = m_tNCM.iScrollWidth
End Function
<b>Private Function GetSMCaptionHeight() As Long</b>
   GetSMCaptionHeight = m_tNCM.iSMCaptionHeight
End Function
<b>Private Function GetSMCaptionWIdth() As Long</b>
   GetSMCaptionWIdth = m_tNCM.iSMCaptionWidth
End Function
<b>Private Function GetBorderWidth() As Long</b>
   GetBorderWidth = m_tNCM.iBorderWidth
End Function

<b>Public Sub ApplySystemSettingsToForm(aForm As Form, Optional controlsExcluded As String, Optional retainLargerFonts As Boolean = False)</b>
    On Error Resume Next
    Dim c As Control
    Dim statusF As StdFont
    Dim messageF As StdFont
    
    'Remember existing font size
    Call GetMetrics
    Set statusF = GetFont(aForm.hDC, StatusFont)
    Set messageF = GetFont(aForm.hDC, MessageFont)
    Call ApplyFont(aForm, messageF, retainLargerFonts)
    Load frmLargeFonts
    For Each c In aForm.Controls
        'check this isn't a control the user has indicated shouldn't be operated on
        If InStr(1, controlsExcluded, c.name) = 0 Then
            Select Case TypeName(c)
                Case "StatusBar"
                    Call ApplyFont(c, statusF, retainLargerFonts)
                Case Else
                    If HasFont(c) Then
                        Call ApplyFont(c, messageF, retainLargerFonts)
                    End If
            End Select
            Call frmLargeFonts.SizeToFit(c)
        End If
    Next c
    Call Unload(frmLargeFonts)
    Exit Sub
<b>End Sub</b>

<b>Private Function HasFont(c As Control) As Boolean</b>
    On Error Resume Next
    HasFont = (InStr(1, HAS_FONT, TypeName(c)) > 0)
End Function

<b>Private Sub ApplyFont(uiObject As Object, newFont As StdFont, retainLargerFonts As Boolean)</b>
<font color="green">'Applies the font newFont to the form or control uiObject, but checks bold and font size against</font>
<font color="green">'existing bold and font size and keeps the "more visible" ones if retainLargerFonts is true</font>
    On Error Resume Next
    Dim size As Single
    Dim bold As Boolean
    
    If TypeName(uiObject) = "Toolbar" Then
        'No font object to manipulate
    Else
        size = newFont.size
        size = uiObject.Font.size
        bold = uiObject.Font.bold
        Set uiObject.Font = newFont
        If retainLargerFonts Then
            If uiObject.Font.size &lt; size Then uiObject.Font.size = size
            If (Not uiObject.Font.bold) And bold Then uiObject.Font.bold = True
        End If
    End If
        
    
<b>End Sub</b>



</pre>
<h2>Module modPath</h2>
<p>Filename: ..\Common\modPath.bas</p><p>Date last modified: Fri Aug 2009 08:59</p><!-- 
Attribute VB_Name = "modPath"
Option Explicit

'Copyright (c) 2007, Alasdair King
'All rights reserved.
'
'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
'
'    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
'    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
'    * Neither the name of [Alasdair] nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
'
'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'Changelog
'	28 Aug 2009		Made GetAppPath return String explicitly.

Public settingsPath As String ' the settings directory for the application
Public runningLocal As Boolean ' whether we're running off the local folder
    'only
Public commonSettingsPath As String ' the settings directory for the WebbIE applications
Public nonRoamingSettingsPath As String ' the settings directory for non-roaming data
    '(e.g. Local Settings)

'SHGetSpecialFolderLocation
'Returns the Folder ID of the user's My Documents folder (or another folder indicated
'by CSIDL)
Private Declare Function SHGetSpecialFolderLocation Lib "Shell32" (ByVal hwnd As Long, ByVal nFolder As Long, ppidl As Long) As Long
'SHGetPathFromIDList
'Returns the path (string) from the folder ID obtained by SHGetSpecialFolderLocation
Public Declare Function SHGetPathFromIDList Lib "Shell32" Alias "SHGetPathFromIDListA" (ByVal Pidl As Long, ByVal pszPath As String) As Long

' constants for Shell.NameSpace method -- these are the "special folders"
'contained in the Windows shell
Public Const CSIDL_DESKTOP = &H0 ' Desktop
Public Const CSIDL_INTERNET = &H1 ' The internet
Public Const CSIDL_PROGRAMS = &H2 ' Shortcuts in the Programs menu
Public Const CSIDL_CONTROLS = &H3 ' Control Panel
Public Const CSIDL_PRINTERS = &H4 ' Printers
Public Const CSIDL_PERSONAL = &H5 ' Shortcuts to Personal files
Public Const CSIDL_FAVORITES = &H6 ' Shortcuts to favorite folders
Public Const CSIDL_STARTUP = &H7 ' Shortcuts to apps that start at boot Time
Public Const CSIDL_RECENT = &H8 ' Shortcuts to recently used docs
Public Const CSIDL_SENDTO = &H9 ' Shortcuts for the SendTo menu
Public Const CSIDL_BITBUCKET = &HA ' Recycle Bin
Public Const CSIDL_STARTMENU = &HB ' User-defined items in Start Menu
Public Const CSIDL_DESKTOPDIRECTORY = &H10 ' Directory with all the desktop shortcuts
Public Const CSIDL_DRIVES = &H11 ' My Computer
Public Const CSIDL_NETWORK = &H12 ' Network Neighborhood virtual folder
Public Const CSIDL_NETHOOD = &H13 ' Directory containing objects in the network neighborhood
Public Const CSIDL_FONTS = &H14 ' Installed fonts
Public Const CSIDL_TEMPLATES = &H15 ' Shortcuts to document templates
Public Const CSIDL_COMMON_STARTMENU = &H16 ' Directory with items in the Start menu for all users
Public Const CSIDL_COMMON_PROGRAMS = &H17 ' Directory with items in the Programs menu for all users
Public Const CSIDL_COMMON_STARTUP = &H18 ' Directory with items in the StartUp submenu for all users
Public Const CSIDL_COMMON_DESKTOPDIRECTORY = &H19 ' Directory with items on the desktop of all users
Public Const CSIDL_APPDATA = &H1A ' Folder for application-specific data
Public Const CSIDL_PRINTHOOD = &H1B ' Directory with references to printer links
Public Const CSIDL_LOCAL_APPDATA = &H1C          '{user name}\Local Settings\Application Data (non roaming)
Public Const CSIDL_ALTSTARTUP = &H1D ' (DBCS) Directory corresponding to user 's nonlocalized Startup program group
Public Const CSIDL_COMMON_ALTSTARTUP = &H1E ' (DBCS) Directory with Startup items for all users
Public Const CSIDL_COMMON_FAVORITES = &H1F ' Directory with all user's favorit items
Public Const CSIDL_INTERNET_CACHE = &H20 ' Directory for temporary internet Files
Public Const CSIDL_COOKIES = &H21 ' Directory for Internet cookies
Public Const CSIDL_HISTORY = &H22 ' Directory for Internet history items
Public Const CSIDL_COMMON_APPDATA = &H23          'All Users\Application Data
Public Const CSIDL_WINDOWS = &H24                 'GetWindowsDirectory()
Public Const CSIDL_SYSTEM = &H25                  'GetSystemDirectory()
Public Const CSIDL_PROGRAM_FILES = &H26           'C:\Program Files
Public Const CSIDL_MYPICTURES = &H27                 'C:\Program Files\My Pictures
Public Const CSIDL_PROFILE = &H28                 'USERPROFILE
Public Const CSIDL_SYSTEMX86 = &H29               'x86 system directory on RISC
Public Const CSIDL_PROGRAM_FILESX86 = &H2A        'x86 C:\Program Files on RISC
Public Const CSIDL_PROGRAM_FILES_COMMON = &H2B    'C:\Program Files\Common
Public Const CSIDL_PROGRAM_FILES_COMMONX86 = &H2C 'x86 Program Files\Common on RISC
Public Const CSIDL_COMMON_TEMPLATES = &H2D        'All Users\Templates
Public Const CSIDL_COMMON_DOCUMENTS = &H2E        'All Users\Documents
Public Const CSIDL_COMMON_ADMINTOOLS = &H2F       'All Users\Start Menu\Programs\Administrative Tools
Public Const CSIDL_ADMINTOOLS = &H30              '{user name}\Start Menu\Programs\Administrative Tools

Public Const CSIDL_FLAG_CREATE = &H8000           'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_DONT_VERIFY = &H4000      'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_MASK = &HFF00             'mask for all possible flag values

Private Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpSectionName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long


Public Sub DetermineSettingsPath(Optional ByVal companyName As String, Optional ByVal productName As String, Optional ByVal version As String)
    'works out whether we are running on a memory stick/standalone or as an
    'installed application.
    On Error Resume Next
    Dim fso As FileSystemObject
    Dim got As String
    Dim gotLen As Long
    Dim key As String
    Dim section As String
    Dim Path As String
    
    'Get any override values for company, version and application name from the program .ini file, if any.
    'Otherwise use the values passed.
    got = Space(255) & Chr(0)
    gotLen = GetPrivateProfileString("ApplicationDataPath", "Company", companyName, got, Len(got), GetAppPath & "\" & App.EXEName & ".ini")
    got = Trim(left(got, gotLen))
    If Len(companyName) = 0 Then
        If Len(got) > 0 Then companyName = got Else companyName = App.companyName
    End If
    got = Space(255) & Chr(0)
    gotLen = GetPrivateProfileString("ApplicationDataPath", "ApplicationName", productName, got, Len(got), GetAppPath & "\" & App.EXEName & ".ini")
    got = Trim(left(got, gotLen))
    If Len(productName) = 0 Then
        If Len(got) > 0 Then productName = got Else productName = App.productName
    End If
    got = Space(255) & Chr(0)
    gotLen = GetPrivateProfileString("ApplicationDataPath", "Version", version, got, Len(got), GetAppPath & "\" & App.EXEName & ".ini")
    got = Trim(left(got, gotLen))
    If Len(version) = 0 Then
        If Len(got) > 0 Then version = got Else version = App.Major
    End If

    Set fso = New FileSystemObject
    If fso.FileExists(GetAppPath & "\installed.ini") Then
        runningLocal = False
    Else
        'try checking for local INI file to indicate not running from stick
        got = Space(255) & Chr(0)
        key = "RunAsInstalled" & Chr(0)
        section = "Program" & Chr(0)
        Path = GetAppPath & "\" & App.EXEName & ".ini" & Chr(0)
        gotLen = GetPrivateProfileString(section, key, "0" & Chr(0), got, Len(got), Path)
        If gotLen > 0 Then got = left(got, gotLen)
        If CBool(got) Then
            'ini file indicates we should run as installed version
            runningLocal = False
        Else
            'running from a memory stick or other non-installed location
            runningLocal = True
        End If
    End If
    If runningLocal Then
        'running from a memory stick or other non-installed location
        settingsPath = GetAppPath & "\Settings"
        nonRoamingSettingsPath = settingsPath
        'need to create
        If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    Else
        'run as installed version
        settingsPath = GetSpecialFolderPath(CSIDL_APPDATA)
        nonRoamingSettingsPath = GetSpecialFolderPath(CSIDL_LOCAL_APPDATA)
    End If
    settingsPath = settingsPath & "\" & companyName
    If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    nonRoamingSettingsPath = nonRoamingSettingsPath & "\" & companyName
    If Not fso.FolderExists(nonRoamingSettingsPath) Then Call fso.CreateFolder(nonRoamingSettingsPath)
    commonSettingsPath = settingsPath & "\Common"
    If Not fso.FolderExists(commonSettingsPath) Then Call fso.CreateFolder(commonSettingsPath)
    settingsPath = settingsPath & "\" & productName
    If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    nonRoamingSettingsPath = nonRoamingSettingsPath & "\" & productName
    If Not fso.FolderExists(nonRoamingSettingsPath) Then Call fso.CreateFolder(nonRoamingSettingsPath)
    settingsPath = settingsPath & "\" & version
    If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    nonRoamingSettingsPath = nonRoamingSettingsPath & "\" & version
    If Not fso.FolderExists(nonRoamingSettingsPath) Then Call fso.CreateFolder(nonRoamingSettingsPath)
    Set fso = Nothing
End Sub

Public Function GetSpecialFolderPath(CSIDL As Long) As String
'returns the special folder indicated by the CSIDL constant
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to special folder
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetSpecialFolderPath = Path
End Function

Public Function GetAppPath() as string	
    On Error Resume Next
    'work out some paths for use
    GetAppPath = App.Path
    If right(GetAppPath, 1) = "\" Then
        GetAppPath = left(GetAppPath, Len(GetAppPath) - 1)
    End If
End Function

Public Function GetSettingIni(appName As String, section As String, key As String, default As String) As String
    On Error Resume Next
    Dim value As String
    Dim size As Long
    Dim nullTerminatedDefault As String
    Dim Path As String
    
    nullTerminatedDefault = default & Chr(0)
    section = section & Chr(0)
    key = key & Chr(0)
    value = Space(256) & Chr(0)
    Path = settingsPath & "\" & appName & ".ini" & Chr(0)
    size = GetPrivateProfileString(section, key, nullTerminatedDefault, value, Len(value), Path)
    If size = 0 Then
        'nothing read
        GetSettingIni = default
    Else
        'read okay
        GetSettingIni = left(value, size)
    End If
End Function

Public Sub SaveSettingIni(appName As String, section As String, key As String, value As String)
    On Error Resume Next
    Dim Path As String
    
    section = section & Chr(0)
    key = key & Chr(0)
    value = value & Chr(0)
    Path = settingsPath & "\" & appName & ".ini"
    
    Call WritePrivateProfileString(section, key, value, Path)
End Sub

Public Function ReadAppEXEIni(section As String, key As String, default As String) As String
    On Error Resume Next
    Dim iniFile As String
    Dim got As String
    
    iniFile = GetAppPath & "\" & App.EXEName & ".ini" & Chr(0)
    section = section & Chr(0)
    key = key & Chr(0)
    default = default & Chr(0)
    got = Space(255) & Chr(0)
    
    Call GetPrivateProfileString(section, key, default, got, Len(got), iniFile)
    got = Replace(got, Chr(0), "")
    got = Trim(got)
    ReadAppEXEIni = got
End Function

-->
<pre id="0">
Option Explicit

<font color="green">'Copyright (c) 2007, Alasdair King</font>
<font color="green">'All rights reserved.</font>
<font color="green">'</font>
<font color="green">'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</font>
<font color="green">'</font>
<font color="green">'    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</font>
<font color="green">'    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</font>
<font color="green">'    * Neither the name of [Alasdair] nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</font>
<font color="green">'</font>
<font color="green">'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</font>

<font color="green">'Changelog</font>
<font color="green">'	28 Aug 2009		Made GetAppPath return String explicitly.</font>

Public settingsPath As String ' the settings directory for the application
Public runningLocal As Boolean ' whether we're running off the local folder
    'only
Public commonSettingsPath As String ' the settings directory for the WebbIE applications
Public nonRoamingSettingsPath As String ' the settings directory for non-roaming data
    '(e.g. Local Settings)

<font color="green">'SHGetSpecialFolderLocation</font>
<font color="green">'Returns the Folder ID of the user's My Documents folder (or another folder indicated</font>
<font color="green">'by CSIDL)</font>
Private Declare Function SHGetSpecialFolderLocation Lib "Shell32" (ByVal hwnd As Long, ByVal nFolder As Long, ppidl As Long) As Long
<font color="green">'SHGetPathFromIDList</font>
<font color="green">'Returns the path (string) from the folder ID obtained by SHGetSpecialFolderLocation</font>
Public Declare Function SHGetPathFromIDList Lib "Shell32" Alias "SHGetPathFromIDListA" (ByVal Pidl As Long, ByVal pszPath As String) As Long

<font color="green">' constants for Shell.NameSpace method -- these are the "special folders"</font>
<font color="green">'contained in the Windows shell</font>
Public Const CSIDL_DESKTOP = &H0 ' Desktop
Public Const CSIDL_INTERNET = &H1 ' The internet
Public Const CSIDL_PROGRAMS = &H2 ' Shortcuts in the Programs menu
Public Const CSIDL_CONTROLS = &H3 ' Control Panel
Public Const CSIDL_PRINTERS = &H4 ' Printers
Public Const CSIDL_PERSONAL = &H5 ' Shortcuts to Personal files
Public Const CSIDL_FAVORITES = &H6 ' Shortcuts to favorite folders
Public Const CSIDL_STARTUP = &H7 ' Shortcuts to apps that start at boot Time
Public Const CSIDL_RECENT = &H8 ' Shortcuts to recently used docs
Public Const CSIDL_SENDTO = &H9 ' Shortcuts for the SendTo menu
Public Const CSIDL_BITBUCKET = &HA ' Recycle Bin
Public Const CSIDL_STARTMENU = &HB ' User-defined items in Start Menu
Public Const CSIDL_DESKTOPDIRECTORY = &H10 ' Directory with all the desktop shortcuts
Public Const CSIDL_DRIVES = &H11 ' My Computer
Public Const CSIDL_NETWORK = &H12 ' Network Neighborhood virtual folder
Public Const CSIDL_NETHOOD = &H13 ' Directory containing objects in the network neighborhood
Public Const CSIDL_FONTS = &H14 ' Installed fonts
Public Const CSIDL_TEMPLATES = &H15 ' Shortcuts to document templates
Public Const CSIDL_COMMON_STARTMENU = &H16 ' Directory with items in the Start menu for all users
Public Const CSIDL_COMMON_PROGRAMS = &H17 ' Directory with items in the Programs menu for all users
Public Const CSIDL_COMMON_STARTUP = &H18 ' Directory with items in the StartUp submenu for all users
Public Const CSIDL_COMMON_DESKTOPDIRECTORY = &H19 ' Directory with items on the desktop of all users
Public Const CSIDL_APPDATA = &H1A ' Folder for application-specific data
Public Const CSIDL_PRINTHOOD = &H1B ' Directory with references to printer links
Public Const CSIDL_LOCAL_APPDATA = &H1C          '{user name}\Local Settings\Application Data (non roaming)
Public Const CSIDL_ALTSTARTUP = &H1D ' (DBCS) Directory corresponding to user 's nonlocalized Startup program group
Public Const CSIDL_COMMON_ALTSTARTUP = &H1E ' (DBCS) Directory with Startup items for all users
Public Const CSIDL_COMMON_FAVORITES = &H1F ' Directory with all user's favorit items
Public Const CSIDL_INTERNET_CACHE = &H20 ' Directory for temporary internet Files
Public Const CSIDL_COOKIES = &H21 ' Directory for Internet cookies
Public Const CSIDL_HISTORY = &H22 ' Directory for Internet history items
Public Const CSIDL_COMMON_APPDATA = &H23          'All Users\Application Data
Public Const CSIDL_WINDOWS = &H24                 'GetWindowsDirectory()
Public Const CSIDL_SYSTEM = &H25                  'GetSystemDirectory()
Public Const CSIDL_PROGRAM_FILES = &H26           'C:\Program Files
Public Const CSIDL_MYPICTURES = &H27                 'C:\Program Files\My Pictures
Public Const CSIDL_PROFILE = &H28                 'USERPROFILE
Public Const CSIDL_SYSTEMX86 = &H29               'x86 system directory on RISC
Public Const CSIDL_PROGRAM_FILESX86 = &H2A        'x86 C:\Program Files on RISC
Public Const CSIDL_PROGRAM_FILES_COMMON = &H2B    'C:\Program Files\Common
Public Const CSIDL_PROGRAM_FILES_COMMONX86 = &H2C 'x86 Program Files\Common on RISC
Public Const CSIDL_COMMON_TEMPLATES = &H2D        'All Users\Templates
Public Const CSIDL_COMMON_DOCUMENTS = &H2E        'All Users\Documents
Public Const CSIDL_COMMON_ADMINTOOLS = &H2F       'All Users\Start Menu\Programs\Administrative Tools
Public Const CSIDL_ADMINTOOLS = &H30              '{user name}\Start Menu\Programs\Administrative Tools

Public Const CSIDL_FLAG_CREATE = &H8000           'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_DONT_VERIFY = &H4000      'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_MASK = &HFF00             'mask for all possible flag values

Private Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpSectionName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long


<b>Public Sub DetermineSettingsPath(Optional ByVal companyName As String, Optional ByVal productName As String, Optional ByVal version As String)</b>
    'works out whether we are running on a memory stick/standalone or as an
    'installed application.
    On Error Resume Next
    Dim fso As FileSystemObject
    Dim got As String
    Dim gotLen As Long
    Dim key As String
    Dim section As String
    Dim Path As String
    
    'Get any override values for company, version and application name from the program .ini file, if any.
    'Otherwise use the values passed.
    got = Space(255) & Chr(0)
    gotLen = GetPrivateProfileString("ApplicationDataPath", "Company", companyName, got, Len(got), GetAppPath & "\" & App.EXEName & ".ini")
    got = Trim(left(got, gotLen))
    If Len(companyName) = 0 Then
        If Len(got) > 0 Then companyName = got Else companyName = App.companyName
    End If
    got = Space(255) & Chr(0)
    gotLen = GetPrivateProfileString("ApplicationDataPath", "ApplicationName", productName, got, Len(got), GetAppPath & "\" & App.EXEName & ".ini")
    got = Trim(left(got, gotLen))
    If Len(productName) = 0 Then
        If Len(got) > 0 Then productName = got Else productName = App.productName
    End If
    got = Space(255) & Chr(0)
    gotLen = GetPrivateProfileString("ApplicationDataPath", "Version", version, got, Len(got), GetAppPath & "\" & App.EXEName & ".ini")
    got = Trim(left(got, gotLen))
    If Len(version) = 0 Then
        If Len(got) > 0 Then version = got Else version = App.Major
    End If

    Set fso = New FileSystemObject
    If fso.FileExists(GetAppPath & "\installed.ini") Then
        runningLocal = False
    Else
        'try checking for local INI file to indicate not running from stick
        got = Space(255) & Chr(0)
        key = "RunAsInstalled" & Chr(0)
        section = "Program" & Chr(0)
        Path = GetAppPath & "\" & App.EXEName & ".ini" & Chr(0)
        gotLen = GetPrivateProfileString(section, key, "0" & Chr(0), got, Len(got), Path)
        If gotLen > 0 Then got = left(got, gotLen)
        If CBool(got) Then
            'ini file indicates we should run as installed version
            runningLocal = False
        Else
            'running from a memory stick or other non-installed location
            runningLocal = True
        End If
    End If
    If runningLocal Then
        'running from a memory stick or other non-installed location
        settingsPath = GetAppPath & "\Settings"
        nonRoamingSettingsPath = settingsPath
        'need to create
        If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    Else
        'run as installed version
        settingsPath = GetSpecialFolderPath(CSIDL_APPDATA)
        nonRoamingSettingsPath = GetSpecialFolderPath(CSIDL_LOCAL_APPDATA)
    End If
    settingsPath = settingsPath & "\" & companyName
    If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    nonRoamingSettingsPath = nonRoamingSettingsPath & "\" & companyName
    If Not fso.FolderExists(nonRoamingSettingsPath) Then Call fso.CreateFolder(nonRoamingSettingsPath)
    commonSettingsPath = settingsPath & "\Common"
    If Not fso.FolderExists(commonSettingsPath) Then Call fso.CreateFolder(commonSettingsPath)
    settingsPath = settingsPath & "\" & productName
    If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    nonRoamingSettingsPath = nonRoamingSettingsPath & "\" & productName
    If Not fso.FolderExists(nonRoamingSettingsPath) Then Call fso.CreateFolder(nonRoamingSettingsPath)
    settingsPath = settingsPath & "\" & version
    If Not fso.FolderExists(settingsPath) Then Call fso.CreateFolder(settingsPath)
    nonRoamingSettingsPath = nonRoamingSettingsPath & "\" & version
    If Not fso.FolderExists(nonRoamingSettingsPath) Then Call fso.CreateFolder(nonRoamingSettingsPath)
    Set fso = Nothing
<b>End Sub</b>

<b>Public Function GetSpecialFolderPath(CSIDL As Long) As String</b>
<font color="green">'returns the special folder indicated by the CSIDL constant</font>
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to special folder
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetSpecialFolderPath = Path
End Function

<b>Public Function GetAppPath() as string	</b>
    On Error Resume Next
    'work out some paths for use
    GetAppPath = App.Path
    If right(GetAppPath, 1) = "\" Then
        GetAppPath = left(GetAppPath, Len(GetAppPath) - 1)
    End If
End Function

<b>Public Function GetSettingIni(appName As String, section As String, key As String, default As String) As String</b>
    On Error Resume Next
    Dim value As String
    Dim size As Long
    Dim nullTerminatedDefault As String
    Dim Path As String
    
    nullTerminatedDefault = default & Chr(0)
    section = section & Chr(0)
    key = key & Chr(0)
    value = Space(256) & Chr(0)
    Path = settingsPath & "\" & appName & ".ini" & Chr(0)
    size = GetPrivateProfileString(section, key, nullTerminatedDefault, value, Len(value), Path)
    If size = 0 Then
        'nothing read
        GetSettingIni = default
    Else
        'read okay
        GetSettingIni = left(value, size)
    End If
End Function

<b>Public Sub SaveSettingIni(appName As String, section As String, key As String, value As String)</b>
    On Error Resume Next
    Dim Path As String
    
    section = section & Chr(0)
    key = key & Chr(0)
    value = value & Chr(0)
    Path = settingsPath & "\" & appName & ".ini"
    
    Call WritePrivateProfileString(section, key, value, Path)
<b>End Sub</b>

<b>Public Function ReadAppEXEIni(section As String, key As String, default As String) As String</b>
    On Error Resume Next
    Dim iniFile As String
    Dim got As String
    
    iniFile = GetAppPath & "\" & App.EXEName & ".ini" & Chr(0)
    section = section & Chr(0)
    key = key & Chr(0)
    default = default & Chr(0)
    got = Space(255) & Chr(0)
    
    Call GetPrivateProfileString(section, key, default, got, Len(got), iniFile)
    got = Replace(got, Chr(0), "")
    got = Trim(got)
    ReadAppEXEIni = got
End Function

</pre>
<h2>Module modI18N</h2>
<p>Filename: ..\Common\modI18N.bas</p><p>Date last modified: Fri Aug 2009 09:05</p><!-- 
Attribute VB_Name = "modI18N"
'modLanguage
'Handles the internationalization of all user interface components.
'Usage: 1 Add to project
'       2 Ensure that Microsoft Scripting Runtime has a reference in the project
'       3 Ensure that Microsft XML has a reference in the project
'       NO LONGER 4 Ensure everything you want to internationalize has a unique .tag attribute
'       5 Add languages.xml to main program directory and populate with information
'       6 Change every string "example" to modi18n.GetText("example")
'       7 Create an instance of the object.
' Of course, this considerably under-states the work needed for step 5. You can use
' RegisterForm to help you.

'Copyright (c) 2007, Alasdair King
'All rights reserved.
'
'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
'
'    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
'    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
'    * Neither the name of [Alasdair] nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
'
'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'2 Feb 2007
'   Made it look up controls without tags: means I don't have to populate the
'   .tag attribute for every control.
'14 April 2008
'   Changed toolbar handling slightly: might need to check tags.
'7 Dec 2008
'   Added support for different XP and Vista fonts.

Option Explicit

Private mTranslator As New Scripting.Dictionary
Private mstrFontname As String
Private mintCharset As Integer
Private mLocaleID As Long
Private mUserLanguage As String
Private mLanguageDoc As DOMDocument30   ' The complete language document, holding information about
                                        ' the languages available.
Private mAppDoc As DOMDocument30        ' The application language document, holding translations
                                        ' for this particular application.
Private mLanguageFilesNotAvailable As Boolean  'If set then don't do any I18N. Set if fail to find or load application or
'   language file.
Private mRightToLeft As Boolean ' indicates this is a right-to-left language, like Hebrew or Arabic. Default it false.
                                        
Private Const BLANK As String = ""
Private Const DEFAULT_LANGUAGE_CODE As String = "en-gb"

'Add the class name of controls with captions or tooltiptext to these strings
Private Const HAS_CAPTION As String = "*Label*UniLabel*DUniLabel*OptionButton*Menu*CommandButton*Frame*CheckBox*ButtonPlus*FramePlus*SSTab*"
Private Const HAS_TOOLTIPTEXT As String = "*Label*OptionButton*CommandButton*Frame*CheckBox*DUniLabel*UniLabel*FramePlus*SSTab*TextBox*UniText*UniList*ComboBox*WebBrowser*ProgressBar*ButtonPlus*"
Private Const HASNOT_FONT As String = "*WebBrowser*Winsock*CommonDialog*Timer*Menu*ProgressBar*Slider*WindowsMediaPlayer*Toolbar*"
Private Const HAS_FONT As String = "*Label*DUniLabel*UniLabel*ComboBox*TextBox*Frame*CommandButton*CheckBox*OptionButton*ListBox*TabStrip*StatusBar*TreeView*ListView*ImageCombo*DUniText*DUniList*DUniCombo*ButtonPlus*FramePlus*SSTab*"

'To determine language if nothing is defined
Private Declare Function GetUserDefaultUILanguage Lib "kernel32" () As Integer
'See http://www.codenewsgroups.net/group/microsoft.public.vb.general.discussion/topic2255.aspx
Private Declare Function GetSystemDefaultLCID Lib "kernel32" () As Long
Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
Private Declare Function SetLocaleInfo Lib "kernel32" Alias "SetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String) As Long
Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SYSTEM_DEFAULT = &H800
Private Const LOCALE_ILANGUAGE             As Long = &H1     'language id
Private Const LOCALE_SLANGUAGE             As Long = &H2     'localized name of language
Private Const LOCALE_SENmodi18n          As Long = &H1001  'English name of language
Private Const LOCALE_SABBREVLANGNAME       As Long = &H3     'abbreviated language name
Private Const LOCALE_SNATIVELANGNAME       As Long = &H4     'native name of language

Private Const LOCALE_ICOUNTRY              As Long = &H5     'country code
Private Const LOCALE_SCOUNTRY              As Long = &H6     'localized name of country
Private Const LOCALE_SENGCOUNTRY           As Long = &H1002  'English name of country
Private Const LOCALE_SABBREVCTRYNAME       As Long = &H7     'abbreviated country name
Private Const LOCALE_SNATIVECTRYNAME       As Long = &H8     'native name of country

Private Const LOCALE_IDEFAULTLANGUAGE      As Long = &H9     'default language id
Private Const LOCALE_IDEFAULTCOUNTRY       As Long = &HA     'default country code
Private Const LOCALE_IDEFAULTCODEPAGE      As Long = &HB     'default oem code page
Private Const LOCALE_IDEFAULTANSICODEPAGE  As Long = &H1004  'default ansi code page
Private Const LOCALE_IDEFAULTMACCODEPAGE   As Long = &H1011  'default mac code page

Private Const LOCALE_SLIST                 As Long = &HC     'list item separator
Private Const LOCALE_IMEASURE              As Long = &HD     '0 = metric, 1 = US

Private Const LOCALE_SDECIMAL              As Long = &HE     'decimal separator
Private Const LOCALE_STHOUSAND             As Long = &HF     'thousand separator
Private Const LOCALE_SGROUPING             As Long = &H10    'digit grouping
Private Const LOCALE_IDIGITS               As Long = &H11    'number of fractional digits
Private Const LOCALE_ILZERO                As Long = &H12    'leading zeros for decimal
Private Const LOCALE_INEGNUMBER            As Long = &H1010  'negative number mode
Private Const LOCALE_SNATIVEDIGITS         As Long = &H13    'native ascii 0-9

Private Const LOCALE_SCURRENCY             As Long = &H14    'local monetary symbol
Private Const LOCALE_SINTLSYMBOL           As Long = &H15    'intl monetary symbol
Private Const LOCALE_SMONDECIMALSEP        As Long = &H16    'monetary decimal separator
Private Const LOCALE_SMONTHOUSANDSEP       As Long = &H17    'monetary thousand separator
Private Const LOCALE_SMONGROUPING          As Long = &H18    'monetary grouping
Private Const LOCALE_ICURRDIGITS           As Long = &H19    '# local monetary digits
Private Const LOCALE_IINTLCURRDIGITS       As Long = &H1A    '# intl monetary digits
Private Const LOCALE_ICURRENCY             As Long = &H1B    'positive currency mode
Private Const LOCALE_INEGCURR              As Long = &H1C    'negative currency mode

Private Const LOCALE_SDATE                 As Long = &H1D    'date separator
Private Const LOCALE_STIME                 As Long = &H1E    'time separator
Private Const LOCALE_SSHORTDATE            As Long = &H1F    'short date format string
Private Const LOCALE_SLONGDATE             As Long = &H20    'long date format string
Private Const LOCALE_STIMEFORMAT           As Long = &H1003  'time format string
Private Const LOCALE_IDATE                 As Long = &H21    'short date format ordering
Private Const LOCALE_ILDATE                As Long = &H22    'long date format ordering
Private Const LOCALE_ITIME                 As Long = &H23    'time format specifier
Private Const LOCALE_ITIMEMARKPOSN         As Long = &H1005  'time marker position
Private Const LOCALE_ICENTURY              As Long = &H24    'century format specifier (short date)
Private Const LOCALE_ITLZERO               As Long = &H25    'leading zeros in time field
Private Const LOCALE_IDAYLZERO             As Long = &H26    'leading zeros in day field (short date)
Private Const LOCALE_IMONLZERO             As Long = &H27    'leading zeros in month field (short date)
Private Const LOCALE_S1159                 As Long = &H28    'AM designator
Private Const LOCALE_S2359                 As Long = &H29    'PM designator

Private Const LOCALE_ICALENDARTYPE         As Long = &H1009  'type of calendar specifier
Private Const LOCALE_IOPTIONALCALENDAR     As Long = &H100B  'additional calendar types specifier
Private Const LOCALE_IFIRSTDAYOFWEEK       As Long = &H100C  'first day of week specifier
Private Const LOCALE_IFIRSTWEEKOFYEAR      As Long = &H100D  'first week of year specifier

Private Const LOCALE_SDAYNAME1             As Long = &H2A    'long name for Monday
Private Const LOCALE_SDAYNAME2             As Long = &H2B    'long name for Tuesday
Private Const LOCALE_SDAYNAME3             As Long = &H2C    'long name for Wednesday
Private Const LOCALE_SDAYNAME4             As Long = &H2D    'long name for Thursday
Private Const LOCALE_SDAYNAME5             As Long = &H2E    'long name for Friday
Private Const LOCALE_SDAYNAME6             As Long = &H2F    'long name for Saturday
Private Const LOCALE_SDAYNAME7             As Long = &H30    'long name for Sunday
Private Const LOCALE_SABBREVDAYNAME1       As Long = &H31    'abbreviated name for Monday
Private Const LOCALE_SABBREVDAYNAME2       As Long = &H32    'abbreviated name for Tuesday
Private Const LOCALE_SABBREVDAYNAME3       As Long = &H33    'abbreviated name for Wednesday
Private Const LOCALE_SABBREVDAYNAME4       As Long = &H34    'abbreviated name for Thursday
Private Const LOCALE_SABBREVDAYNAME5       As Long = &H35    'abbreviated name for Friday
Private Const LOCALE_SABBREVDAYNAME6       As Long = &H36    'abbreviated name for Saturday
Private Const LOCALE_SABBREVDAYNAME7       As Long = &H37    'abbreviated name for Sunday
Private Const LOCALE_SMONTHNAME1           As Long = &H38    'long name for January
Private Const LOCALE_SMONTHNAME2           As Long = &H39    'long name for February
Private Const LOCALE_SMONTHNAME3           As Long = &H3A    'long name for March
Private Const LOCALE_SMONTHNAME4           As Long = &H3B    'long name for April
Private Const LOCALE_SMONTHNAME5           As Long = &H3C    'long name for May
Private Const LOCALE_SMONTHNAME6           As Long = &H3D    'long name for June
Private Const LOCALE_SMONTHNAME7           As Long = &H3E    'long name for July
Private Const LOCALE_SMONTHNAME8           As Long = &H3F    'long name for August
Private Const LOCALE_SMONTHNAME9           As Long = &H40    'long name for September
Private Const LOCALE_SMONTHNAME10          As Long = &H41    'long name for October
Private Const LOCALE_SMONTHNAME11          As Long = &H42    'long name for November
Private Const LOCALE_SMONTHNAME12          As Long = &H43    'long name for December
Private Const LOCALE_SMONTHNAME13          As Long = &H100E  'long name for 13th month (if exists)
Private Const LOCALE_SABBREVMONTHNAME1     As Long = &H44    'abbreviated name for January
Private Const LOCALE_SABBREVMONTHNAME2     As Long = &H45    'abbreviated name for February
Private Const LOCALE_SABBREVMONTHNAME3     As Long = &H46    'abbreviated name for March
Private Const LOCALE_SABBREVMONTHNAME4     As Long = &H47    'abbreviated name for April
Private Const LOCALE_SABBREVMONTHNAME5     As Long = &H48    'abbreviated name for May
Private Const LOCALE_SABBREVMONTHNAME6     As Long = &H49    'abbreviated name for June
Private Const LOCALE_SABBREVMONTHNAME7     As Long = &H4A    'abbreviated name for July
Private Const LOCALE_SABBREVMONTHNAME8     As Long = &H4B    'abbreviated name for August
Private Const LOCALE_SABBREVMONTHNAME9     As Long = &H4C    'abbreviated name for September
Private Const LOCALE_SABBREVMONTHNAME10    As Long = &H4D    'abbreviated name for October
Private Const LOCALE_SABBREVMONTHNAME11    As Long = &H4E    'abbreviated name for November
Private Const LOCALE_SABBREVMONTHNAME12    As Long = &H4F    'abbreviated name for December
Private Const LOCALE_SABBREVMONTHNAME13    As Long = &H100F  'abbreviated name for 13th month (if exists)

Private Const LOCALE_SPOSITIVESIGN         As Long = &H50    'positive sign
Private Const LOCALE_SNEGATIVESIGN         As Long = &H51    'negative sign
Private Const LOCALE_IPOSSIGNPOSN          As Long = &H52    'positive sign position
Private Const LOCALE_INEGSIGNPOSN          As Long = &H53    'negative sign position
Private Const LOCALE_IPOSSYMPRECEDES       As Long = &H54    'mon sym precedes pos amt
Private Const LOCALE_IPOSSEPBYSPACE        As Long = &H55    'mon sym sep by space from pos amt
Private Const LOCALE_INEGSYMPRECEDES       As Long = &H56    'mon sym precedes neg amt
Private Const LOCALE_INEGSEPBYSPACE        As Long = &H57    'mon sym sep by space from neg amt

Private Const LOCALE_FONTSIGNATURE         As Long = &H58    'font signature
Private Const LOCALE_SISO639LANGNAME       As Long = &H59    'ISO abbreviated language name
Private Const LOCALE_SISO3166CTRYNAME      As Long = &H5A    'ISO abbreviated country name

Private Const LOCALE_IDEFAULTEBCDICCODEPAGE As Long = &H1012 'default ebcdic code page
Private Const LOCALE_IPAPERSIZE            As Long = &H100A  '0 = letter, 1 = a4, 2 = legal, 3 = a3
Private Const LOCALE_SENGCURRNAME          As Long = &H1007  'english name of currency
Private Const LOCALE_SNATIVECURRNAME       As Long = &H1008  'native name of currency
Private Const LOCALE_SYEARMONTH            As Long = &H1006  'year month format string
Private Const LOCALE_SSORTNAME             As Long = &H1013  'sort name
Private Const LOCALE_IDIGITSUBSTITUTION    As Long = &H1014  '0 = none, 1 = context, 2 = native digit

Private Declare Function GetPrivateProfileStrinmodi18n Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileStrinmodi18n Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpSectionName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long

Private Type OSVERSIONINFO
   dwVersionInfoSize As Long
   dwMajorVersion As Long
   dwMinorVersion As Long
   dwBuildNumber As Long
   dwPlatformID As Long
   szCSDVersion(0 To 127) As Byte
End Type
Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (lpVersionInfo As OSVERSIONINFO) As Long

Private mInitialised As Boolean ' indicates that the initial setup process - determining what language
'   we're using and loading the language files.

Public Function rightToLeft() As Boolean
    On Error Resume Next
    rightToLeft = mRightToLeft
End Function

Public Sub ApplyUILanguageToThisForm(aForm As Form, Optional enforceTooltipSpacing As Boolean = True)
'goes through the form updating the user components
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim aControl As Control
    Dim got As String
    Dim index  As String
    Dim controlType As String
    Dim newFont As StdFont
    Dim tbButton As Object
    Dim aPanel As Object
    Dim aTab As Object
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
        'don't do any translation
    Else
        'First, do the form:
        'do caption
        got = mTranslator.Item(aForm.name & ".Caption")
        If Len(got) > 0 Then aForm.Caption = got
        'do font if defined in language file
        If Len(mstrFontname) > 0 Then aForm.Font.name = mstrFontname
        If mintCharset > -1 Then aForm.Font.Charset = mintCharset
        If mRightToLeft Then aForm.rightToLeft = True
    
    'Second, do all controls on the form
    'Handle special cases where the control has "sub-controls" - status bar and toolbar and tabstrip
    For Each aControl In aForm.Controls
'        Debug.Print "Trying: " & aControl.Tag
        If TypeName(aControl) = "StatusBar" Then
            For Each aPanel In aControl.Panels
                If Len(aPanel.Tag) > 0 Then
                    index = aPanel.Tag
                Else
                    index = ""
                    index = aForm.name & "." & aControl.name & "." & aPanel.index
                    If index = "" Then index = aForm.name & "." & aControl.name & "." & aPanel.index
                End If
                If mTranslator.Exists(index & ".ToolTipText") Then
                    got = ""
                    got = mTranslator.Item(index & ".ToolTipText")
                    If got <> BLANK Then
                        If enforceTooltipSpacing And Len(got) > 0 Then
                            got = Trim(got)
                            got = " " & got & " "
                        End If
                        aPanel.ToolTipText = got
                    End If
                Else
                        'No Tooltip in current language.
                        #If debugging Then
                            Open App.Path & "\language.log" For Append As #1
                            Write #1, index & ".ToolTipText"
                            Close #1
                        #End If
                    End If
                Next aPanel
            ElseIf TypeName(aControl) = "Toolbar" Then
                'updates toolbar controls with international text
                For Each tbButton In aControl.Buttons
                    If Len(tbButton.Tag) > 0 Then
                        index = tbButton.Tag
                    Else
                        If TypeName(tbButton) = "IButton" Then
                            index = aForm.name & "." & aControl.name & "." & tbButton.key
                        Else
                            index = aForm.name & "." & aControl.name & "." & tbButton.name
                        End If
                    End If
                    If mTranslator.Exists(index & ".Caption") Then
                    got = ""
                    got = mTranslator.Item(index & ".Caption")
                    If got <> BLANK Then tbButton.Caption = got
                    Else
                        #If debugging Then
                            Open App.Path & "\language.log" For Append As #1
                            Write #1, "<item><key>" & index & ".Caption</key><explanation>String</explanation><content language=""en-gb"">" & aForm.Caption & "</content></item>" & vbNewLine
                            Close #1
                        #End If
                    End If
                    If mTranslator.Exists(index & ".ToolTipText") Then
                        got = ""
                        got = mTranslator.Item(index & ".ToolTipText")
                        If got <> BLANK Then
                            If enforceTooltipSpacing And Len(got) > 0 Then
                                got = Trim(got)
                                got = " " & got & " "
                            End If
                            tbButton.ToolTipText = got
                        Else
                            #If debugging Then
                                Open App.Path & "\language.log" For Append As #1
                                Write #1, "<item><key>" & index & ".ToolTipText</key><explanation>String</explanation><content language=""en-gb"">" & tbButton.ToolTipText & "</content></item>" & vbNewLine
                                Close #1
                            #End If
                        End If
                    End If
                Next tbButton
        ElseIf TypeName(aControl) = "TabStrip" Then
            For Each aTab In aControl.Tabs
                index = aForm.name & "." & aControl.name & "." & aTab.key
                If mTranslator.Exists(index & ".Caption") Then
                    got = ""
                    got = mTranslator.Item(index & ".Caption")
                    If got <> BLANK Then aTab.Caption = got
                                Else
                    #If debugging Then
                        Open App.Path & "\language.log" For Append As #1
                        Write #1, "<item><key>" & index & ".Caption</key><explanation>String</explanation><content language=""en-gb"">" & aTab.Caption & "</content></item>" & vbNewLine
                        Close #1
                    #End If
                End If
            Next aTab
        End If
            'Work out what this item should be looked up as. Is this defined in the
            'tag for the control?
            If Len(aControl.Tag) > 0 Then
                index = aControl.Tag
        Else
            index = aForm.name & "." & aControl.name
        End If
        controlType = "*" & TypeName(aControl) & "*"
        'Caption
        If InStr(1, HAS_CAPTION, controlType) > 0 Then
            'Debug.Print "Tag: " & aControl.Tag
            got = ""
            got = mTranslator.Item(index & ".Caption")
            If Len(got) > 0 Then
                If got <> BLANK Then aControl.Caption = got
                    'OK, in WebbIE 3.6 the conversion below breaks the correct character encoding: for
                    'example, in Polish, the l with a line through it becomes 3 in mnuWebsite in Accessible
                    'RSS. But I apparently got it working okay in previous versions. However, I did rework
                    'all the I18N in 3.6, so let's assume I broke it and doing a direct assignment (as
                    'above) works fine so long as the codepage for the Operating System is set correctly.
    '                If mLocaleID > -1 Then
    '                    aControl.Caption = StrConv(StrConv(got, vbFromUnicode, mLocaleID), vbUnicode)
    '                Else
    '                    aControl.Caption = StrConv(StrConv(got, vbFromUnicode, 0), vbUnicode)
    '                End If
                Else
    #If debugging Then
        Open App.Path & "\language.log" For Append As #1
        Write #1, "<item><key>" & index & ".Caption</key><explanation>String</explanation><content language=""en-gb"">" & aControl.Caption & "</content></item>" & vbNewLine
        Close #1
    #End If
                End If
            Else
                'Does not have .Caption property
    '            Debug.Print "No caption for: " & index & " " & controlType
        End If
        'Tooltip
        If InStr(1, HAS_TOOLTIPTEXT, controlType) > 0 Then
            got = ""
            got = mTranslator.Item(index & ".ToolTipText")
            If got <> BLANK Then
                If enforceTooltipSpacing And Len(got) > 0 Then
                    got = Trim(got)
                    got = " " & got & " "
                End If
                aControl.ToolTipText = got
            End If
        Else
            'Debug.Print "No Tooltiptext for: " & index & " " & controlType
        End If
        'Font object, if defined
        If mintCharset > -1 Or Len(mstrFontname) > 0 Then
            If InStr(1, HAS_FONT, controlType) > 0 Then
                Set newFont = aControl.Font
                'WebbIE 3.8.0: need to do fontname BEFORE charset, or it won't change for
                'CommandButtons.
                If Len(mstrFontname) > 0 Then newFont.name = mstrFontname
                If mintCharset > -1 Then newFont.Charset = mintCharset
                Set aControl.Font = newFont
                'Debug.Print "Applying font to: " & aForm.name & "." & controlType
            Else
                'Debug.Print "No font: " & controlType
                End If
            End If
        Next aControl
    End If
End Sub

'Public Sub RegisterForm(aForm As Form)
''saves the information about the form
'    On Error Resume Next
'    Dim aControl As Control
'    Dim parentName As String
'    Dim fso As New FileSystemObject
'    Dim ts As TextStream
'    Dim item As String
'
'    parentName = aForm.name
'    Set ts = fso.OpenTextFile(modPath.settingsPath & "\allforms.txt", ForAppending, True, TristateFalse)
'    item = vbTab & vbTab & "<item>" & vbNewLine & "<key>" & parentName & ".Caption</key><explanation/>"
'    item = item & "<content language=""en-gb"">" & aForm.Caption & "</content>" & vbNewLine & "</item>" & vbNewLine
'    Call ts.Write(item)
'    For Each aControl In aForm.Controls
'        If Len(aControl.Tag) > 0 Then
'            'got a tag: record details
'            'Caption
'            If TypeOf aControl Is Label Or TypeOf aControl Is OptionButton Or _
'            TypeOf aControl Is Menu Or TypeOf aControl Is CommandButton Or _
'            TypeOf aControl Is Frame Or TypeOf aControl Is CheckBox Then
'                item = vbTab & vbTab & "<item><key>" & aControl.Tag & ".Caption" & "</key><explanation/><content language=""en-gb"">" & aControl.Caption & "</content></item>" & vbNewLine
'                Call ts.Write(item)
'            End If
'        End If
'    Next aControl
'    Call ts.Close
'End Sub

Public Function GetText(key As String, Optional enforceTooltipSpacing As Boolean = False) As String
    'returns the internationalised string for the given key.
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim got As String
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
        GetText = key
    ElseIf key = "" Then
    Else
        If mTranslator.Exists(key) Then
            got = mTranslator.Item(key)
            If got <> BLANK Then
                GetText = mTranslator.Item(key)
                If enforceTooltipSpacing And Len(got) > 0 Then
                    GetText = Trim(GetText)
                    GetText = " " & GetText & " "
                End If
            End If
        Else
    #If debugging Then
        Open App.Path & "\language.log" For Append As #1
        Print #1, "<item><key>" & key & "</key><explanation>String</explanation><content language=""en-gb"">" & key & "</content></item>"
        Close #1
    #End If
            GetText = key
        End If
    End If
End Function


Private Sub Initialise()
'Loads language/I18N information ready for subsequent translation work.
'In order of preference:
'1 An external INI file called EXEName.Language.ini. This gets loaded and parsed into the en-gb language
'   and en-gb is set as the default language. The result is an XML document.
'2 An external XML file called EXEName.Language.xml. This replaces the embedded XML file directly.
'3 The internal XML file for language.
'Having parsed the XML file into mLanguageDoc, then try to work out what language to use:
'1 If an external ini file, use en-gb (default)
'2 Read from common WebbIE files > WebbIE 3.ini
'3 Read from common WebbIE files > WebbIE3.ini
'4 Read from registry in HKCU to support older WebbIE versions.
'5 Read from EXEName.ini
'6 Try to work it out from the Windows Locale.
'7 Default to en-gb.
'The language is then loaded, and font, charset and localeID set. But translating the UI doesn't happen
'until prompted.
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim result As String
    Dim locale As Long
    Dim LCType As Long
    Dim lpLCData As String
    Dim cchData As Long
    Dim languageIterator As IXMLDOMNode
    Dim s As String
    
    mInitialised = True
    'Set some defaults
    If IsVistaOrAbove Then
        mstrFontname = "Segoe UI"
    Else
        mstrFontname = "Tahoma"
    End If
    
    #If debugging Then
        If Dir(App.Path & "\language.log", vbNormal) <> "" Then
            Call Kill(App.Path & "\language.log")
        End If
    #End If
    Set mLanguageDoc = New DOMDocument30
    Set mAppDoc = New DOMDocument30
    'First, load language information. This is either internal to the application (as a resource) or external
    '(as an XML file or ini file)
    If Dir(GetAppPath & "\" & App.EXEName & ".Language.ini", vbNormal) <> "" Then
        'Found ini file. Load this in preference to XML.
        Call LoadXMLDocFromIni(GetAppPath & "\" & App.EXEName & ".Language.ini")
        'Always set language to "local" = the default for ini use.
        mUserLanguage = "local"
        Call SetLanguage("local")
    Else
        'nope, no Ini file. XML?
        If Dir(modPath.GetAppPath & "\Languages.xml", vbNormal) <> "" Then
            'found external XML. Try loading it.
            mLanguageDoc.async = False
            mLanguageDoc.preserveWhiteSpace = False
            mLanguageDoc.validateOnParse = False
            mLanguageDoc.resolveExternals = False
            Call mLanguageDoc.Load(modPath.GetAppPath & "\Languages.xml")
        End If
        'Now load the application-specific translations.
        mAppDoc.async = False
        mAppDoc.preserveWhiteSpace = False
        mAppDoc.validateOnParse = False
        mAppDoc.resolveExternals = False
        Call mAppDoc.Load(modPath.GetAppPath & "\" & App.EXEName & ".Language.xml")
        'Assertion: loaded the language file by now.
        
        If mAppDoc.parseError.errorCode <> 0 Or mLanguageDoc.parseError.errorCode <> 0 Then
            'One or both failed to load.
            mLanguageFilesNotAvailable = True
        Else
        'Now, what language shall we use?
        'First thing to check is for a Claro-based I18N setting which overrides the WebbIE
        'setting. If you're reading this under the Open-source licence: this is to allow for distribution
        'by Claro Software of Accessible PDF using their I18N mechanism. Feel free to ignore.
        result = modPath.ReadAppEXEIni("I18N", "ClaroLanguage", "")

            If Len(result) > 0 Then
                mUserLanguage = result
            Else
                'Let's check to see if the user has set the
                'language in one of the various places we might have saved it.
                'First, the new official place to save it.
                result = ReadIniFileLanguage(modPath.commonSettingsPath & "\WebbIE 3.ini", "Internationalisation", "Language")
                If Len(result) = 0 Then result = ReadIniFileLanguage(modPath.commonSettingsPath & "\WebbIE3.ini", "Internationalisation", "Language")
                If Len(result) > 0 Then
                    'Good, got something from there.
                    mUserLanguage = result
                Else
                    'Nope. Let's try the old place to save language info, the registry
                    mUserLanguage = GetSetting("WebbIE 3", "User Settings", "Language", "Nothing recorded")
                    If mUserLanguage = "Nothing recorded" Then
                        'Nope. Let's see if installation has written a default language to
                        'program files.
                        result = ReadIniFileLanguage(GetAppPath & "\language.ini", "Internationalisation", "Language")
                        If Len(result) = 0 Then result = modPath.ReadAppEXEIni("Internationalisation", "Language", "")
                        If Len(result) > 0 Then
                            'right, got a result from the default language file.
                            mUserLanguage = result
                        Else
                            'okay, we don't have a defined language: use Windows information
                            'to make a stab at it
                            mUserLanguage = ""
                            lpLCData = Space(255) & Chr(0)
                            cchData = Len(lpLCData)
                            LCType = LOCALE_SCOUNTRY
                            locale = LOCALE_USER_DEFAULT
                            Call GetLocaleInfo(locale, LCType, lpLCData, cchData)
                            'locale now contains the locale ID for the current user or system.
                            'Go through the language file looking for matching languages.
                            If mLanguageDoc.parseError.errorCode = 0 Then
                                For Each languageIterator In mLanguageDoc.documentElement.selectNodes("languages/language")
                                    If CLng(languageIterator.Attributes.getNamedItem("localeID").text) = locale Then
                                        'Windows locale matches this language: use it
                                        mUserLanguage = languageIterator.Attributes.getNamedItem("id").text
                                        Exit For
                                    End If
                                Next languageIterator
                            End If
                            If mUserLanguage = "" Then
                                'okay, haven't got anything at all. Default to British English.
                                mUserLanguage = DEFAULT_LANGUAGE_CODE
                            End If
                        End If
                    End If
                End If
            End If
            Call SetLanguage(mUserLanguage)
        End If
    End If
End Sub

'Private Sub Class_Terminate()
'    On Error Resume Next
'    'I'm no longer (28 Jan 2008) going to write the language chosen by a particular application, because
'    'it is too easy to have a program than fails to read the correct language and then defaults back
'    'to English. So leave this to the installer or LanguageSelector.exe
'    'Call WritePrivateProfileString("Internationalisation", "Language", CStr(mUserLanguage), modPath.commonSettingsPath & "\WebbIE 3.ini")
'    'also write to registry to support old installed apps
'    If modPath.runningLocal Then
'        'don't store in registry
'    Else
'        'running in installed machine: No, don't do this. Take language
'        'out of WebbIE.
'        'Call SaveSetting("WebbIE 3", "User Settings", "Language", CStr(mUserLanguage))
'    End If
'End Sub

Public Function GetLanguage() As String
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    If Not mInitialised Then Call Initialise
    GetLanguage = mUserLanguage
End Function

Public Sub SetLanguage(newLanguage As String)
'loads and parses the language requested, or uses English if not found
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    Dim itemIterator As IXMLDOMNode
    Dim languageNode As IXMLDOMNode
    Dim contentNode As IXMLDOMNode
    Dim i As Integer
    Dim s As String
    Dim attNode As IXMLDOMAttribute
    
    If Not mInitialised Then Call Initialise
    
    If mLanguageFilesNotAvailable Then
        'Don't do anything, failed to load language files
    Else
        'Assertion: have already loaded language file in the Class_Initialize event, so
        'no need to load it now.
        'Unless of course we failed to load it.
        If mLanguageDoc.parseError.errorCode = 0 And Len(mLanguageDoc.xml) > 0 Then
            mRightToLeft = False ' default
            mUserLanguage = newLanguage ' we should really check this is a valid language, but what the heck.
            If mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']") Is Nothing Then
                mstrFontname = ""
            Else
                mstrFontname = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']").Attributes.getNamedItem("font").text
                'Support for a Vista font: supply a "vistaFont" attribute.
                Set attNode = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']").Attributes.getNamedItem("vistaFont")
                If Not (attNode Is Nothing) And IsVistaOrAbove Then
                    If Len(attNode.text) > 0 Then
                        mstrFontname = attNode.text
                    End If
                End If
            End If
            If mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']") Is Nothing Then
                mintCharset = -1
            Else
                mintCharset = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']").Attributes.getNamedItem("charset").text
            End If
            If mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']") Is Nothing Then
                mLocaleID = -1
            Else
                Set languageNode = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']")
                mstrFontname = languageNode.Attributes.getNamedItem("font").text
                mintCharset = languageNode.Attributes.getNamedItem("charset").text
                mLocaleID = languageNode.Attributes.getNamedItem("localeID").text
                If Not languageNode.Attributes.getNamedItem("rightToLeft") Is Nothing Then
                    mRightToLeft = languageNode.Attributes.getNamedItem("rightToLeft").text
                End If
            End If
            Call mTranslator.removeAll
            Set languageNode = mAppDoc.documentElement.selectSingleNode("contents")
            For Each itemIterator In languageNode.selectNodes("item")
                Set contentNode = itemIterator.selectSingleNode("content[@language='" & mUserLanguage & "']")
                If contentNode Is Nothing Then
                    'didn't find desired content: use English (or whatever default is)
                    Set contentNode = itemIterator.selectSingleNode("content[@language='" & DEFAULT_LANGUAGE_CODE & "']")
                End If
                'now add to translation dictionary
        '        Debug.Print "Adding: " & itemIterator.selectSingleNode("key").Text
        '        Debug.Print "With: " & contentNode.Text
        #If debugging Then
            If mTranslator.Exists(itemIterator.selectSingleNode("key").text) Then
                Call languageNode.removeChild(itemIterator)
                Set itemIterator = Nothing
            End If
        #End If
            If Not itemIterator Is Nothing Then
                If contentNode.text = "" Then
                    Call mTranslator.Add(itemIterator.selectSingleNode("key").text, BLANK)
                Else
                Call mTranslator.Add(itemIterator.selectSingleNode("key").text, contentNode.text)
                End If
            End If
            Next itemIterator
        End If
    #If debugging Then
        Call mAppDoc.save(mAppDoc.url & ".bak")
    #End If
    End If
    Exit Sub
ErrorInitialise:
End Sub

Public Sub ApplyUILanguageToAllForms()
    #If debugging = 0 Then
    On Error Resume Next
    #End If
'processes the whole application updating every user interface component on every loaded form
    Dim aForm As Form
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
    Else
        For Each aForm In Forms
    '        Debug.Print "Doing: " & aForm.name
            Call ApplyUILanguageToThisForm(aForm)
        Next aForm
    End If
End Sub

Private Sub LoadXMLDocFromIni(Path As String)
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    'loads the ini file indicated by path into the mlanguagedoc file
    Dim fso As Scripting.FileSystemObject
    Set fso = New Scripting.FileSystemObject
    Dim ts As Scripting.TextStream
    Dim got As String
    Dim newItem As IXMLDOMNode
    Dim parts() As String
    
    Set mLanguageDoc = New DOMDocument30
    Set mAppDoc = New DOMDocument30
    mLanguageDoc.async = False
    mAppDoc.async = False
    'load the xml frameworks
    Call mLanguageDoc.loadXML("<language version=""3""><languages><language id=""local"" name=""Locally-defined Language"" font=""Tahoma"" charset=""0"" localeID=""0""><localname>Locally-defined Langauge</localname></language></languages><contents/></language>")
    Call mAppDoc.loadXML("<language version=""3""><contents/><help/><popupHelp/></language>")
    'parse the ini file to extract language information
    Set ts = fso.OpenTextFile(Path, ForReading, False, TristateTrue)
    While Not ts.AtEndOfStream
        got = ts.ReadLine
        
        If left(got, 1) = "[" Or Len(Trim(got)) = 0 Or InStr(1, got, "=", vbTextCompare) = 0 Then
            'ignore this line
        ElseIf StrComp(left(got, 9), "FontName=", vbTextCompare) = 0 Then
            'got a specific special font instruction
            mLanguageDoc.documentElement.selectSingleNode("languages/language").Attributes.getNamedItem("font").text = Trim(Replace(got, "FontName=", "", vbTextCompare))
        ElseIf StrComp(left(got, 8), "Charset=", vbTextCompare) = 0 Then
            'got a charset instruction
            mLanguageDoc.documentElement.selectSingleNode("languages/language").Attributes.getNamedItem("charset").text = Trim(Replace(got, "Charset=", "", vbTextCompare))
        ElseIf StrComp(left(got, 9), "LocaleID=", vbTextCompare) = 0 Then
            'got a locale ID instruction
            mLanguageDoc.documentElement.selectSingleNode("languages/language").Attributes.getNamedItem("localeID").text = Trim(Replace(got, "LocaleID=", "", vbTextCompare))
        Else
            'got an entry to add
            parts() = Split(got, "=", 2)
            If UBound(parts) < 1 Then
                'don't add, not got all the bits!
            Else
                'Add to loaded document.
                Set newItem = mAppDoc.createNode(NODE_ELEMENT, "item", "")
                Call newItem.appendChild(mAppDoc.createNode(NODE_ELEMENT, "key", ""))
                newItem.selectSingleNode("key").text = parts(0)
                Call newItem.appendChild(mAppDoc.createNode(NODE_ELEMENT, "content", ""))
                Call newItem.selectSingleNode("content").Attributes.setNamedItem(mAppDoc.createAttribute("language"))
                newItem.selectSingleNode("content").Attributes.getNamedItem("language").text = "local"
                parts(1) = Trim(parts(1))
                If left(parts(1), 1) = """" And right(parts(1), 1) = """" Then
                    parts(1) = left(parts(1), Len(parts(1)) - 1)
                    parts(1) = right(parts(1), Len(parts(1)) - 1)
                End If
                newItem.selectSingleNode("content").text = parts(1)
                Call mAppDoc.documentElement.selectSingleNode("contents").appendChild(newItem)
            End If
        End If
    Wend
    Call ts.Close
    'Debug.Print mLanguageDoc.xml
End Sub

Public Function fontDefined() As Boolean
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    If Not mInitialised Then Call Initialise
    fontDefined = (Len(mstrFontname) > 0)
End Function

Public Function helpTopicCount() As Integer
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    Dim helpNode As IXMLDOMNode
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
    Else
        If Dir(GetAppPath & "\" & App.EXEName & ".Help.txt") <> "" Then
            'Got ini file to use as help
            helpTopicCount = 1
        Else
            Set helpNode = mAppDoc.documentElement.selectSingleNode("help")
            If helpNode Is Nothing Then
                helpTopicCount = 0
            Else
                helpTopicCount = helpNode.selectNodes("topic").length
            End If
        End If
    End If
End Function

Public Function helpTopicTitle(index As Integer) As String
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim got As String
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
    Else
        got = helpTopicText(index)
        If Len(got) > 0 Then helpTopicTitle = left(got, InStr(1, got, vbNewLine) - 1)
    End If
End Function

Public Function helpTopicText(index As Integer) As String
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim fso As Scripting.FileSystemObject
    Dim ts As Scripting.TextStream
    Dim topicNode As IXMLDOMNode
    Dim topics As IXMLDOMNodeList
    Dim contentNode As IXMLDOMNode
    
    If Not mInitialised Then Call Initialise
    
    If mLanguageFilesNotAvailable Then
    Else
        If Dir(GetAppPath & "\" & App.EXEName & ".Help.txt") <> "" Then
            'local Unicode help file to use
            Set fso = New Scripting.FileSystemObject
            Set ts = fso.OpenTextFile(GetAppPath & "\" & App.EXEName & ".Help.txt", ForReading, False, TristateTrue)
            helpTopicText = ts.ReadAll
            Call ts.Close
            Set fso = Nothing
        Else
            'Use XML if valid
            Set topics = mAppDoc.documentElement.selectNodes("help/topic")
            If topics Is Nothing Then
            ElseIf topics.length = 0 Then
            ElseIf index < 0 Or index > topics.length - 1 Then
            Else
                Set topicNode = topics.Item(index)
                Set contentNode = topicNode.selectSingleNode("content[@language=""" & mUserLanguage & """]")
                If contentNode Is Nothing Then Set contentNode = topicNode.selectSingleNode("content[@language=""en-gb""]")
                If contentNode Is Nothing Then
                    'No topic!
                Else
                    helpTopicText = ProcessHelpNode(contentNode)
                End If
            End If
        End If
    End If
End Function

Private Function ProcessHelpNode(helpNode As IXMLDOMNode) As String
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    'iterate through the helpNode inserting newlines where indicated by
    '<p> nodes
    Dim paragraphNode As IXMLDOMNode
    Dim output As String
    
    output = helpNode.Attributes.getNamedItem("title").text & vbNewLine & vbNewLine
    For Each paragraphNode In helpNode.selectNodes("p")
        output = output & paragraphNode.text & vbNewLine
    Next paragraphNode
    ProcessHelpNode = output
End Function

Private Function ReadIniFileLanguage(ByVal strIniFile As String, ByVal strSECTION As String, ByVal strKey As String) As String
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim strBuffer As String
    Dim strNull As String

    strBuffer = Space$(256)
    If GetPrivateProfileStrinmodi18n(strSECTION, strKey, strNull, strBuffer, Len(strBuffer) - 1, strIniFile) > 0 Then
        ReadIniFileLanguage = left(strBuffer, InStr(strBuffer, Chr(0)) - 1)
    Else
        ReadIniFileLanguage = ""
    End If
End Function

Public Function popupHelp(key As String) As String
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    'look up popup help
    Dim resultNode As IXMLDOMNode
    Dim textNode As IXMLDOMNode

    If mLanguageFilesNotAvailable Then
    Else
        Set resultNode = mAppDoc.documentElement.selectSingleNode("popupHelp/item[key=""" & key & """]")
        If resultNode Is Nothing Then
        Else
            Set textNode = resultNode.selectSingleNode("content[@language=""" & mUserLanguage & """]")
            If textNode Is Nothing Then Set textNode = resultNode.selectSingleNode("content[@language=""en-gb""]")
            If textNode Is Nothing Then
                'No result found.
            Else
                popupHelp = textNode.text
            End If
            End If
        End If
End Function

Private Function IsVistaOrAbove() As Boolean
#If debugging = 0 Then
    On Error Resume Next
#End If
    Dim tOSV As OSVERSIONINFO
    tOSV.dwVersionInfoSize = Len(tOSV)
    If GetVersionEx(tOSV) > 0 Then
        If (tOSV.dwMajorVersion > 5) Then
           IsVistaOrAbove = True
        End If
    End If
End Function

-->
<pre id="0">
Option Explicit

Private mTranslator As New Scripting.Dictionary
Private mstrFontname As String
Private mintCharset As Integer
Private mLocaleID As Long
Private mUserLanguage As String
Private mLanguageDoc As DOMDocument30   ' The complete language document, holding information about
                                        ' the languages available.
Private mAppDoc As DOMDocument30        ' The application language document, holding translations
                                        ' for this particular application.
Private mLanguageFilesNotAvailable As Boolean  'If set then don't do any I18N. Set if fail to find or load application or
<font color="green">'   language file.</font>
Private mRightToLeft As Boolean ' indicates this is a right-to-left language, like Hebrew or Arabic. Default it false.
                                        
Private Const BLANK As String = ""
Private Const DEFAULT_LANGUAGE_CODE As String = "en-gb"

<font color="green">'Add the class name of controls with captions or tooltiptext to these strings</font>
Private Const HAS_CAPTION As String = "*Label*UniLabel*DUniLabel*OptionButton*Menu*CommandButton*Frame*CheckBox*ButtonPlus*FramePlus*SSTab*"
Private Const HAS_TOOLTIPTEXT As String = "*Label*OptionButton*CommandButton*Frame*CheckBox*DUniLabel*UniLabel*FramePlus*SSTab*TextBox*UniText*UniList*ComboBox*WebBrowser*ProgressBar*ButtonPlus*"
Private Const HASNOT_FONT As String = "*WebBrowser*Winsock*CommonDialog*Timer*Menu*ProgressBar*Slider*WindowsMediaPlayer*Toolbar*"
Private Const HAS_FONT As String = "*Label*DUniLabel*UniLabel*ComboBox*TextBox*Frame*CommandButton*CheckBox*OptionButton*ListBox*TabStrip*StatusBar*TreeView*ListView*ImageCombo*DUniText*DUniList*DUniCombo*ButtonPlus*FramePlus*SSTab*"

<font color="green">'To determine language if nothing is defined</font>
Private Declare Function GetUserDefaultUILanguage Lib "kernel32" () As Integer
<font color="green">'See http://www.codenewsgroups.net/group/microsoft.public.vb.general.discussion/topic2255.aspx</font>
Private Declare Function GetSystemDefaultLCID Lib "kernel32" () As Long
Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
Private Declare Function SetLocaleInfo Lib "kernel32" Alias "SetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String) As Long
Private Const LOCALE_USER_DEFAULT = &H400
Private Const LOCALE_SYSTEM_DEFAULT = &H800
Private Const LOCALE_ILANGUAGE             As Long = &H1     'language id
Private Const LOCALE_SLANGUAGE             As Long = &H2     'localized name of language
Private Const LOCALE_SENmodi18n          As Long = &H1001  'English name of language
Private Const LOCALE_SABBREVLANGNAME       As Long = &H3     'abbreviated language name
Private Const LOCALE_SNATIVELANGNAME       As Long = &H4     'native name of language

Private Const LOCALE_ICOUNTRY              As Long = &H5     'country code
Private Const LOCALE_SCOUNTRY              As Long = &H6     'localized name of country
Private Const LOCALE_SENGCOUNTRY           As Long = &H1002  'English name of country
Private Const LOCALE_SABBREVCTRYNAME       As Long = &H7     'abbreviated country name
Private Const LOCALE_SNATIVECTRYNAME       As Long = &H8     'native name of country

Private Const LOCALE_IDEFAULTLANGUAGE      As Long = &H9     'default language id
Private Const LOCALE_IDEFAULTCOUNTRY       As Long = &HA     'default country code
Private Const LOCALE_IDEFAULTCODEPAGE      As Long = &HB     'default oem code page
Private Const LOCALE_IDEFAULTANSICODEPAGE  As Long = &H1004  'default ansi code page
Private Const LOCALE_IDEFAULTMACCODEPAGE   As Long = &H1011  'default mac code page

Private Const LOCALE_SLIST                 As Long = &HC     'list item separator
Private Const LOCALE_IMEASURE              As Long = &HD     '0 = metric, 1 = US

Private Const LOCALE_SDECIMAL              As Long = &HE     'decimal separator
Private Const LOCALE_STHOUSAND             As Long = &HF     'thousand separator
Private Const LOCALE_SGROUPING             As Long = &H10    'digit grouping
Private Const LOCALE_IDIGITS               As Long = &H11    'number of fractional digits
Private Const LOCALE_ILZERO                As Long = &H12    'leading zeros for decimal
Private Const LOCALE_INEGNUMBER            As Long = &H1010  'negative number mode
Private Const LOCALE_SNATIVEDIGITS         As Long = &H13    'native ascii 0-9

Private Const LOCALE_SCURRENCY             As Long = &H14    'local monetary symbol
Private Const LOCALE_SINTLSYMBOL           As Long = &H15    'intl monetary symbol
Private Const LOCALE_SMONDECIMALSEP        As Long = &H16    'monetary decimal separator
Private Const LOCALE_SMONTHOUSANDSEP       As Long = &H17    'monetary thousand separator
Private Const LOCALE_SMONGROUPING          As Long = &H18    'monetary grouping
Private Const LOCALE_ICURRDIGITS           As Long = &H19    '# local monetary digits
Private Const LOCALE_IINTLCURRDIGITS       As Long = &H1A    '# intl monetary digits
Private Const LOCALE_ICURRENCY             As Long = &H1B    'positive currency mode
Private Const LOCALE_INEGCURR              As Long = &H1C    'negative currency mode

Private Const LOCALE_SDATE                 As Long = &H1D    'date separator
Private Const LOCALE_STIME                 As Long = &H1E    'time separator
Private Const LOCALE_SSHORTDATE            As Long = &H1F    'short date format string
Private Const LOCALE_SLONGDATE             As Long = &H20    'long date format string
Private Const LOCALE_STIMEFORMAT           As Long = &H1003  'time format string
Private Const LOCALE_IDATE                 As Long = &H21    'short date format ordering
Private Const LOCALE_ILDATE                As Long = &H22    'long date format ordering
Private Const LOCALE_ITIME                 As Long = &H23    'time format specifier
Private Const LOCALE_ITIMEMARKPOSN         As Long = &H1005  'time marker position
Private Const LOCALE_ICENTURY              As Long = &H24    'century format specifier (short date)
Private Const LOCALE_ITLZERO               As Long = &H25    'leading zeros in time field
Private Const LOCALE_IDAYLZERO             As Long = &H26    'leading zeros in day field (short date)
Private Const LOCALE_IMONLZERO             As Long = &H27    'leading zeros in month field (short date)
Private Const LOCALE_S1159                 As Long = &H28    'AM designator
Private Const LOCALE_S2359                 As Long = &H29    'PM designator

Private Const LOCALE_ICALENDARTYPE         As Long = &H1009  'type of calendar specifier
Private Const LOCALE_IOPTIONALCALENDAR     As Long = &H100B  'additional calendar types specifier
Private Const LOCALE_IFIRSTDAYOFWEEK       As Long = &H100C  'first day of week specifier
Private Const LOCALE_IFIRSTWEEKOFYEAR      As Long = &H100D  'first week of year specifier

Private Const LOCALE_SDAYNAME1             As Long = &H2A    'long name for Monday
Private Const LOCALE_SDAYNAME2             As Long = &H2B    'long name for Tuesday
Private Const LOCALE_SDAYNAME3             As Long = &H2C    'long name for Wednesday
Private Const LOCALE_SDAYNAME4             As Long = &H2D    'long name for Thursday
Private Const LOCALE_SDAYNAME5             As Long = &H2E    'long name for Friday
Private Const LOCALE_SDAYNAME6             As Long = &H2F    'long name for Saturday
Private Const LOCALE_SDAYNAME7             As Long = &H30    'long name for Sunday
Private Const LOCALE_SABBREVDAYNAME1       As Long = &H31    'abbreviated name for Monday
Private Const LOCALE_SABBREVDAYNAME2       As Long = &H32    'abbreviated name for Tuesday
Private Const LOCALE_SABBREVDAYNAME3       As Long = &H33    'abbreviated name for Wednesday
Private Const LOCALE_SABBREVDAYNAME4       As Long = &H34    'abbreviated name for Thursday
Private Const LOCALE_SABBREVDAYNAME5       As Long = &H35    'abbreviated name for Friday
Private Const LOCALE_SABBREVDAYNAME6       As Long = &H36    'abbreviated name for Saturday
Private Const LOCALE_SABBREVDAYNAME7       As Long = &H37    'abbreviated name for Sunday
Private Const LOCALE_SMONTHNAME1           As Long = &H38    'long name for January
Private Const LOCALE_SMONTHNAME2           As Long = &H39    'long name for February
Private Const LOCALE_SMONTHNAME3           As Long = &H3A    'long name for March
Private Const LOCALE_SMONTHNAME4           As Long = &H3B    'long name for April
Private Const LOCALE_SMONTHNAME5           As Long = &H3C    'long name for May
Private Const LOCALE_SMONTHNAME6           As Long = &H3D    'long name for June
Private Const LOCALE_SMONTHNAME7           As Long = &H3E    'long name for July
Private Const LOCALE_SMONTHNAME8           As Long = &H3F    'long name for August
Private Const LOCALE_SMONTHNAME9           As Long = &H40    'long name for September
Private Const LOCALE_SMONTHNAME10          As Long = &H41    'long name for October
Private Const LOCALE_SMONTHNAME11          As Long = &H42    'long name for November
Private Const LOCALE_SMONTHNAME12          As Long = &H43    'long name for December
Private Const LOCALE_SMONTHNAME13          As Long = &H100E  'long name for 13th month (if exists)
Private Const LOCALE_SABBREVMONTHNAME1     As Long = &H44    'abbreviated name for January
Private Const LOCALE_SABBREVMONTHNAME2     As Long = &H45    'abbreviated name for February
Private Const LOCALE_SABBREVMONTHNAME3     As Long = &H46    'abbreviated name for March
Private Const LOCALE_SABBREVMONTHNAME4     As Long = &H47    'abbreviated name for April
Private Const LOCALE_SABBREVMONTHNAME5     As Long = &H48    'abbreviated name for May
Private Const LOCALE_SABBREVMONTHNAME6     As Long = &H49    'abbreviated name for June
Private Const LOCALE_SABBREVMONTHNAME7     As Long = &H4A    'abbreviated name for July
Private Const LOCALE_SABBREVMONTHNAME8     As Long = &H4B    'abbreviated name for August
Private Const LOCALE_SABBREVMONTHNAME9     As Long = &H4C    'abbreviated name for September
Private Const LOCALE_SABBREVMONTHNAME10    As Long = &H4D    'abbreviated name for October
Private Const LOCALE_SABBREVMONTHNAME11    As Long = &H4E    'abbreviated name for November
Private Const LOCALE_SABBREVMONTHNAME12    As Long = &H4F    'abbreviated name for December
Private Const LOCALE_SABBREVMONTHNAME13    As Long = &H100F  'abbreviated name for 13th month (if exists)

Private Const LOCALE_SPOSITIVESIGN         As Long = &H50    'positive sign
Private Const LOCALE_SNEGATIVESIGN         As Long = &H51    'negative sign
Private Const LOCALE_IPOSSIGNPOSN          As Long = &H52    'positive sign position
Private Const LOCALE_INEGSIGNPOSN          As Long = &H53    'negative sign position
Private Const LOCALE_IPOSSYMPRECEDES       As Long = &H54    'mon sym precedes pos amt
Private Const LOCALE_IPOSSEPBYSPACE        As Long = &H55    'mon sym sep by space from pos amt
Private Const LOCALE_INEGSYMPRECEDES       As Long = &H56    'mon sym precedes neg amt
Private Const LOCALE_INEGSEPBYSPACE        As Long = &H57    'mon sym sep by space from neg amt

Private Const LOCALE_FONTSIGNATURE         As Long = &H58    'font signature
Private Const LOCALE_SISO639LANGNAME       As Long = &H59    'ISO abbreviated language name
Private Const LOCALE_SISO3166CTRYNAME      As Long = &H5A    'ISO abbreviated country name

Private Const LOCALE_IDEFAULTEBCDICCODEPAGE As Long = &H1012 'default ebcdic code page
Private Const LOCALE_IPAPERSIZE            As Long = &H100A  '0 = letter, 1 = a4, 2 = legal, 3 = a3
Private Const LOCALE_SENGCURRNAME          As Long = &H1007  'english name of currency
Private Const LOCALE_SNATIVECURRNAME       As Long = &H1008  'native name of currency
Private Const LOCALE_SYEARMONTH            As Long = &H1006  'year month format string
Private Const LOCALE_SSORTNAME             As Long = &H1013  'sort name
Private Const LOCALE_IDIGITSUBSTITUTION    As Long = &H1014  '0 = none, 1 = context, 2 = native digit

Private Declare Function GetPrivateProfileStrinmodi18n Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Private Declare Function WritePrivateProfileStrinmodi18n Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpSectionName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long

Private Type OSVERSIONINFO
   dwVersionInfoSize As Long
   dwMajorVersion As Long
   dwMinorVersion As Long
   dwBuildNumber As Long
   dwPlatformID As Long
   szCSDVersion(0 To 127) As Byte
End Type
Private Declare Function GetVersionEx Lib "kernel32" Alias "GetVersionExA" (lpVersionInfo As OSVERSIONINFO) As Long

Private mInitialised As Boolean ' indicates that the initial setup process - determining what language
<font color="green">'   we're using and loading the language files.</font>

<b>Public Function rightToLeft() As Boolean</b>
    On Error Resume Next
    rightToLeft = mRightToLeft
End Function

<b>Public Sub ApplyUILanguageToThisForm(aForm As Form, Optional enforceTooltipSpacing As Boolean = True)</b>
<font color="green">'goes through the form updating the user components</font>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim aControl As Control
    Dim got As String
    Dim index  As String
    Dim controlType As String
    Dim newFont As StdFont
    Dim tbButton As Object
    Dim aPanel As Object
    Dim aTab As Object
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
        'don't do any translation
    Else
        'First, do the form:
        'do caption
        got = mTranslator.Item(aForm.name & ".Caption")
        If Len(got) > 0 Then aForm.Caption = got
        'do font if defined in language file
        If Len(mstrFontname) > 0 Then aForm.Font.name = mstrFontname
        If mintCharset > -1 Then aForm.Font.Charset = mintCharset
        If mRightToLeft Then aForm.rightToLeft = True
    
    'Second, do all controls on the form
    'Handle special cases where the control has "sub-controls" - status bar and toolbar and tabstrip
    For Each aControl In aForm.Controls
<font color="green">'        Debug.Print "Trying: " & aControl.Tag</font>
        If TypeName(aControl) = "StatusBar" Then
            For Each aPanel In aControl.Panels
                If Len(aPanel.Tag) > 0 Then
                    index = aPanel.Tag
                Else
                    index = ""
                    index = aForm.name & "." & aControl.name & "." & aPanel.index
                    If index = "" Then index = aForm.name & "." & aControl.name & "." & aPanel.index
                End If
                If mTranslator.Exists(index & ".ToolTipText") Then
                    got = ""
                    got = mTranslator.Item(index & ".ToolTipText")
                    If got &lt;> BLANK Then
                        If enforceTooltipSpacing And Len(got) > 0 Then
                            got = Trim(got)
                            got = " " & got & " "
                        End If
                        aPanel.ToolTipText = got
                    End If
                Else
                        'No Tooltip in current language.
                        #If debugging Then
                            Open App.Path & "\language.log" For Append As #1
                            Write #1, index & ".ToolTipText"
                            Close #1
                        #End If
                    End If
                Next aPanel
            ElseIf TypeName(aControl) = "Toolbar" Then
                'updates toolbar controls with international text
                For Each tbButton In aControl.Buttons
                    If Len(tbButton.Tag) > 0 Then
                        index = tbButton.Tag
                    Else
                        If TypeName(tbButton) = "IButton" Then
                            index = aForm.name & "." & aControl.name & "." & tbButton.key
                        Else
                            index = aForm.name & "." & aControl.name & "." & tbButton.name
                        End If
                    End If
                    If mTranslator.Exists(index & ".Caption") Then
                    got = ""
                    got = mTranslator.Item(index & ".Caption")
                    If got &lt;> BLANK Then tbButton.Caption = got
                    Else
                        #If debugging Then
                            Open App.Path & "\language.log" For Append As #1
                            Write #1, "&lt;item>&lt;key>" & index & ".Caption&lt;/key>&lt;explanation>String&lt;/explanation>&lt;content language=""en-gb"">" & aForm.Caption & "&lt;/content>&lt;/item>" & vbNewLine
                            Close #1
                        #End If
                    End If
                    If mTranslator.Exists(index & ".ToolTipText") Then
                        got = ""
                        got = mTranslator.Item(index & ".ToolTipText")
                        If got &lt;> BLANK Then
                            If enforceTooltipSpacing And Len(got) > 0 Then
                                got = Trim(got)
                                got = " " & got & " "
                            End If
                            tbButton.ToolTipText = got
                        Else
                            #If debugging Then
                                Open App.Path & "\language.log" For Append As #1
                                Write #1, "&lt;item>&lt;key>" & index & ".ToolTipText&lt;/key>&lt;explanation>String&lt;/explanation>&lt;content language=""en-gb"">" & tbButton.ToolTipText & "&lt;/content>&lt;/item>" & vbNewLine
                                Close #1
                            #End If
                        End If
                    End If
                Next tbButton
        ElseIf TypeName(aControl) = "TabStrip" Then
            For Each aTab In aControl.Tabs
                index = aForm.name & "." & aControl.name & "." & aTab.key
                If mTranslator.Exists(index & ".Caption") Then
                    got = ""
                    got = mTranslator.Item(index & ".Caption")
                    If got &lt;> BLANK Then aTab.Caption = got
                                Else
                    #If debugging Then
                        Open App.Path & "\language.log" For Append As #1
                        Write #1, "&lt;item>&lt;key>" & index & ".Caption&lt;/key>&lt;explanation>String&lt;/explanation>&lt;content language=""en-gb"">" & aTab.Caption & "&lt;/content>&lt;/item>" & vbNewLine
                        Close #1
                    #End If
                End If
            Next aTab
        End If
            'Work out what this item should be looked up as. Is this defined in the
            'tag for the control?
            If Len(aControl.Tag) > 0 Then
                index = aControl.Tag
        Else
            index = aForm.name & "." & aControl.name
        End If
        controlType = "*" & TypeName(aControl) & "*"
        'Caption
        If InStr(1, HAS_CAPTION, controlType) > 0 Then
            'Debug.Print "Tag: " & aControl.Tag
            got = ""
            got = mTranslator.Item(index & ".Caption")
            If Len(got) > 0 Then
                If got &lt;> BLANK Then aControl.Caption = got
                    'OK, in WebbIE 3.6 the conversion below breaks the correct character encoding: for
                    'example, in Polish, the l with a line through it becomes 3 in mnuWebsite in Accessible
                    'RSS. But I apparently got it working okay in previous versions. However, I did rework
                    'all the I18N in 3.6, so let's assume I broke it and doing a direct assignment (as
                    'above) works fine so long as the codepage for the Operating System is set correctly.
    '                If mLocaleID > -1 Then
    '                    aControl.Caption = StrConv(StrConv(got, vbFromUnicode, mLocaleID), vbUnicode)
    '                Else
    '                    aControl.Caption = StrConv(StrConv(got, vbFromUnicode, 0), vbUnicode)
    '                End If
                Else
    #If debugging Then
        Open App.Path & "\language.log" For Append As #1
        Write #1, "&lt;item>&lt;key>" & index & ".Caption&lt;/key>&lt;explanation>String&lt;/explanation>&lt;content language=""en-gb"">" & aControl.Caption & "&lt;/content>&lt;/item>" & vbNewLine
        Close #1
    #End If
                End If
            Else
                'Does not have .Caption property
    '            Debug.Print "No caption for: " & index & " " & controlType
        End If
        'Tooltip
        If InStr(1, HAS_TOOLTIPTEXT, controlType) > 0 Then
            got = ""
            got = mTranslator.Item(index & ".ToolTipText")
            If got &lt;> BLANK Then
                If enforceTooltipSpacing And Len(got) > 0 Then
                    got = Trim(got)
                    got = " " & got & " "
                End If
                aControl.ToolTipText = got
            End If
        Else
            'Debug.Print "No Tooltiptext for: " & index & " " & controlType
        End If
        'Font object, if defined
        If mintCharset > -1 Or Len(mstrFontname) > 0 Then
            If InStr(1, HAS_FONT, controlType) > 0 Then
                Set newFont = aControl.Font
                'WebbIE 3.8.0: need to do fontname BEFORE charset, or it won't change for
                'CommandButtons.
                If Len(mstrFontname) > 0 Then newFont.name = mstrFontname
                If mintCharset > -1 Then newFont.Charset = mintCharset
                Set aControl.Font = newFont
                'Debug.Print "Applying font to: " & aForm.name & "." & controlType
            Else
                'Debug.Print "No font: " & controlType
                End If
            End If
        Next aControl
    End If
<b>End Sub</b>

<font color="green">'Public Sub RegisterForm(aForm As Form)</font>
<font color="green">''saves the information about the form</font>
<font color="green">'    On Error Resume Next</font>
<font color="green">'    Dim aControl As Control</font>
<font color="green">'    Dim parentName As String</font>
<font color="green">'    Dim fso As New FileSystemObject</font>
<font color="green">'    Dim ts As TextStream</font>
<font color="green">'    Dim item As String</font>
<font color="green">'</font>
<font color="green">'    parentName = aForm.name</font>
<font color="green">'    Set ts = fso.OpenTextFile(modPath.settingsPath & "\allforms.txt", ForAppending, True, TristateFalse)</font>
<font color="green">'    item = vbTab & vbTab & "&lt;item>" & vbNewLine & "&lt;key>" & parentName & ".Caption&lt;/key>&lt;explanation/>"</font>
<font color="green">'    item = item & "&lt;content language=""en-gb"">" & aForm.Caption & "&lt;/content>" & vbNewLine & "&lt;/item>" & vbNewLine</font>
<font color="green">'    Call ts.Write(item)</font>
<font color="green">'    For Each aControl In aForm.Controls</font>
<font color="green">'        If Len(aControl.Tag) > 0 Then</font>
<font color="green">'            'got a tag: record details</font>
<font color="green">'            'Caption</font>
<font color="green">'            If TypeOf aControl Is Label Or TypeOf aControl Is OptionButton Or _</font>
<font color="green">'            TypeOf aControl Is Menu Or TypeOf aControl Is CommandButton Or _</font>
<font color="green">'            TypeOf aControl Is Frame Or TypeOf aControl Is CheckBox Then</font>
<font color="green">'                item = vbTab & vbTab & "&lt;item>&lt;key>" & aControl.Tag & ".Caption" & "&lt;/key>&lt;explanation/>&lt;content language=""en-gb"">" & aControl.Caption & "&lt;/content>&lt;/item>" & vbNewLine</font>
<font color="green">'                Call ts.Write(item)</font>
<font color="green">'            End If</font>
<font color="green">'        End If</font>
<font color="green">'    Next aControl</font>
<font color="green">'    Call ts.Close</font>
<font color="green">'End Sub</font>

<b>Public Function GetText(key As String, Optional enforceTooltipSpacing As Boolean = False) As String</b>
    'returns the internationalised string for the given key.
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim got As String
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
        GetText = key
    ElseIf key = "" Then
    Else
        If mTranslator.Exists(key) Then
            got = mTranslator.Item(key)
            If got &lt;> BLANK Then
                GetText = mTranslator.Item(key)
                If enforceTooltipSpacing And Len(got) > 0 Then
                    GetText = Trim(GetText)
                    GetText = " " & GetText & " "
                End If
            End If
        Else
    #If debugging Then
        Open App.Path & "\language.log" For Append As #1
        Print #1, "&lt;item>&lt;key>" & key & "&lt;/key>&lt;explanation>String&lt;/explanation>&lt;content language=""en-gb"">" & key & "&lt;/content>&lt;/item>"
        Close #1
    #End If
            GetText = key
        End If
    End If
End Function


<b>Private Sub Initialise()</b>
<font color="green">'Loads language/I18N information ready for subsequent translation work.</font>
<font color="green">'In order of preference:</font>
<font color="green">'1 An external INI file called EXEName.Language.ini. This gets loaded and parsed into the en-gb language</font>
<font color="green">'   and en-gb is set as the default language. The result is an XML document.</font>
<font color="green">'2 An external XML file called EXEName.Language.xml. This replaces the embedded XML file directly.</font>
<font color="green">'3 The internal XML file for language.</font>
<font color="green">'Having parsed the XML file into mLanguageDoc, then try to work out what language to use:</font>
<font color="green">'1 If an external ini file, use en-gb (default)</font>
<font color="green">'2 Read from common WebbIE files > WebbIE 3.ini</font>
<font color="green">'3 Read from common WebbIE files > WebbIE3.ini</font>
<font color="green">'4 Read from registry in HKCU to support older WebbIE versions.</font>
<font color="green">'5 Read from EXEName.ini</font>
<font color="green">'6 Try to work it out from the Windows Locale.</font>
<font color="green">'7 Default to en-gb.</font>
<font color="green">'The language is then loaded, and font, charset and localeID set. But translating the UI doesn't happen</font>
<font color="green">'until prompted.</font>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim result As String
    Dim locale As Long
    Dim LCType As Long
    Dim lpLCData As String
    Dim cchData As Long
    Dim languageIterator As IXMLDOMNode
    Dim s As String
    
    mInitialised = True
    'Set some defaults
    If IsVistaOrAbove Then
        mstrFontname = "Segoe UI"
    Else
        mstrFontname = "Tahoma"
    End If
    
    #If debugging Then
        If Dir(App.Path & "\language.log", vbNormal) &lt;> "" Then
            Call Kill(App.Path & "\language.log")
        End If
    #End If
    Set mLanguageDoc = New DOMDocument30
    Set mAppDoc = New DOMDocument30
    'First, load language information. This is either internal to the application (as a resource) or external
    '(as an XML file or ini file)
    If Dir(GetAppPath & "\" & App.EXEName & ".Language.ini", vbNormal) &lt;> "" Then
        'Found ini file. Load this in preference to XML.
        Call LoadXMLDocFromIni(GetAppPath & "\" & App.EXEName & ".Language.ini")
        'Always set language to "local" = the default for ini use.
        mUserLanguage = "local"
        Call SetLanguage("local")
    Else
        'nope, no Ini file. XML?
        If Dir(modPath.GetAppPath & "\Languages.xml", vbNormal) &lt;> "" Then
            'found external XML. Try loading it.
            mLanguageDoc.async = False
            mLanguageDoc.preserveWhiteSpace = False
            mLanguageDoc.validateOnParse = False
            mLanguageDoc.resolveExternals = False
            Call mLanguageDoc.Load(modPath.GetAppPath & "\Languages.xml")
        End If
        'Now load the application-specific translations.
        mAppDoc.async = False
        mAppDoc.preserveWhiteSpace = False
        mAppDoc.validateOnParse = False
        mAppDoc.resolveExternals = False
        Call mAppDoc.Load(modPath.GetAppPath & "\" & App.EXEName & ".Language.xml")
        'Assertion: loaded the language file by now.
        
        If mAppDoc.parseError.errorCode &lt;> 0 Or mLanguageDoc.parseError.errorCode &lt;> 0 Then
            'One or both failed to load.
            mLanguageFilesNotAvailable = True
        Else
        'Now, what language shall we use?
        'First thing to check is for a Claro-based I18N setting which overrides the WebbIE
        'setting. If you're reading this under the Open-source licence: this is to allow for distribution
        'by Claro Software of Accessible PDF using their I18N mechanism. Feel free to ignore.
        result = modPath.ReadAppEXEIni("I18N", "ClaroLanguage", "")

            If Len(result) > 0 Then
                mUserLanguage = result
            Else
                'Let's check to see if the user has set the
                'language in one of the various places we might have saved it.
                'First, the new official place to save it.
                result = ReadIniFileLanguage(modPath.commonSettingsPath & "\WebbIE 3.ini", "Internationalisation", "Language")
                If Len(result) = 0 Then result = ReadIniFileLanguage(modPath.commonSettingsPath & "\WebbIE3.ini", "Internationalisation", "Language")
                If Len(result) > 0 Then
                    'Good, got something from there.
                    mUserLanguage = result
                Else
                    'Nope. Let's try the old place to save language info, the registry
                    mUserLanguage = GetSetting("WebbIE 3", "User Settings", "Language", "Nothing recorded")
                    If mUserLanguage = "Nothing recorded" Then
                        'Nope. Let's see if installation has written a default language to
                        'program files.
                        result = ReadIniFileLanguage(GetAppPath & "\language.ini", "Internationalisation", "Language")
                        If Len(result) = 0 Then result = modPath.ReadAppEXEIni("Internationalisation", "Language", "")
                        If Len(result) > 0 Then
                            'right, got a result from the default language file.
                            mUserLanguage = result
                        Else
                            'okay, we don't have a defined language: use Windows information
                            'to make a stab at it
                            mUserLanguage = ""
                            lpLCData = Space(255) & Chr(0)
                            cchData = Len(lpLCData)
                            LCType = LOCALE_SCOUNTRY
                            locale = LOCALE_USER_DEFAULT
                            Call GetLocaleInfo(locale, LCType, lpLCData, cchData)
                            'locale now contains the locale ID for the current user or system.
                            'Go through the language file looking for matching languages.
                            If mLanguageDoc.parseError.errorCode = 0 Then
                                For Each languageIterator In mLanguageDoc.documentElement.selectNodes("languages/language")
                                    If CLng(languageIterator.Attributes.getNamedItem("localeID").text) = locale Then
                                        'Windows locale matches this language: use it
                                        mUserLanguage = languageIterator.Attributes.getNamedItem("id").text
                                        Exit For
                                    End If
                                Next languageIterator
                            End If
                            If mUserLanguage = "" Then
                                'okay, haven't got anything at all. Default to British English.
                                mUserLanguage = DEFAULT_LANGUAGE_CODE
                            End If
                        End If
                    End If
                End If
            End If
            Call SetLanguage(mUserLanguage)
        End If
    End If
<b>End Sub</b>

<font color="green">'Private Sub Class_Terminate()</font>
<font color="green">'    On Error Resume Next</font>
<font color="green">'    'I'm no longer (28 Jan 2008) going to write the language chosen by a particular application, because</font>
<font color="green">'    'it is too easy to have a program than fails to read the correct language and then defaults back</font>
<font color="green">'    'to English. So leave this to the installer or LanguageSelector.exe</font>
<font color="green">'    'Call WritePrivateProfileString("Internationalisation", "Language", CStr(mUserLanguage), modPath.commonSettingsPath & "\WebbIE 3.ini")</font>
<font color="green">'    'also write to registry to support old installed apps</font>
<font color="green">'    If modPath.runningLocal Then</font>
<font color="green">'        'don't store in registry</font>
<font color="green">'    Else</font>
<font color="green">'        'running in installed machine: No, don't do this. Take language</font>
<font color="green">'        'out of WebbIE.</font>
<font color="green">'        'Call SaveSetting("WebbIE 3", "User Settings", "Language", CStr(mUserLanguage))</font>
<font color="green">'    End If</font>
<font color="green">'End Sub</font>

<b>Public Function GetLanguage() As String</b>
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    If Not mInitialised Then Call Initialise
    GetLanguage = mUserLanguage
End Function

<b>Public Sub SetLanguage(newLanguage As String)</b>
<font color="green">'loads and parses the language requested, or uses English if not found</font>
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    Dim itemIterator As IXMLDOMNode
    Dim languageNode As IXMLDOMNode
    Dim contentNode As IXMLDOMNode
    Dim i As Integer
    Dim s As String
    Dim attNode As IXMLDOMAttribute
    
    If Not mInitialised Then Call Initialise
    
    If mLanguageFilesNotAvailable Then
        'Don't do anything, failed to load language files
    Else
        'Assertion: have already loaded language file in the Class_Initialize event, so
        'no need to load it now.
        'Unless of course we failed to load it.
        If mLanguageDoc.parseError.errorCode = 0 And Len(mLanguageDoc.xml) > 0 Then
            mRightToLeft = False ' default
            mUserLanguage = newLanguage ' we should really check this is a valid language, but what the heck.
            If mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']") Is Nothing Then
                mstrFontname = ""
            Else
                mstrFontname = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']").Attributes.getNamedItem("font").text
                'Support for a Vista font: supply a "vistaFont" attribute.
                Set attNode = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']").Attributes.getNamedItem("vistaFont")
                If Not (attNode Is Nothing) And IsVistaOrAbove Then
                    If Len(attNode.text) > 0 Then
                        mstrFontname = attNode.text
                    End If
                End If
            End If
            If mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']") Is Nothing Then
                mintCharset = -1
            Else
                mintCharset = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']").Attributes.getNamedItem("charset").text
            End If
            If mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']") Is Nothing Then
                mLocaleID = -1
            Else
                Set languageNode = mLanguageDoc.documentElement.selectSingleNode("languages/language[@id='" & mUserLanguage & "']")
                mstrFontname = languageNode.Attributes.getNamedItem("font").text
                mintCharset = languageNode.Attributes.getNamedItem("charset").text
                mLocaleID = languageNode.Attributes.getNamedItem("localeID").text
                If Not languageNode.Attributes.getNamedItem("rightToLeft") Is Nothing Then
                    mRightToLeft = languageNode.Attributes.getNamedItem("rightToLeft").text
                End If
            End If
            Call mTranslator.removeAll
            Set languageNode = mAppDoc.documentElement.selectSingleNode("contents")
            For Each itemIterator In languageNode.selectNodes("item")
                Set contentNode = itemIterator.selectSingleNode("content[@language='" & mUserLanguage & "']")
                If contentNode Is Nothing Then
                    'didn't find desired content: use English (or whatever default is)
                    Set contentNode = itemIterator.selectSingleNode("content[@language='" & DEFAULT_LANGUAGE_CODE & "']")
                End If
                'now add to translation dictionary
        '        Debug.Print "Adding: " & itemIterator.selectSingleNode("key").Text
        '        Debug.Print "With: " & contentNode.Text
        #If debugging Then
            If mTranslator.Exists(itemIterator.selectSingleNode("key").text) Then
                Call languageNode.removeChild(itemIterator)
                Set itemIterator = Nothing
            End If
        #End If
            If Not itemIterator Is Nothing Then
                If contentNode.text = "" Then
                    Call mTranslator.Add(itemIterator.selectSingleNode("key").text, BLANK)
                Else
                Call mTranslator.Add(itemIterator.selectSingleNode("key").text, contentNode.text)
                End If
            End If
            Next itemIterator
        End If
    #If debugging Then
        Call mAppDoc.save(mAppDoc.url & ".bak")
    #End If
    End If
    Exit Sub
ErrorInitialise:
<b>End Sub</b>

<b>Public Sub ApplyUILanguageToAllForms()</b>
    #If debugging = 0 Then
    On Error Resume Next
    #End If
<font color="green">'processes the whole application updating every user interface component on every loaded form</font>
    Dim aForm As Form
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
    Else
        For Each aForm In Forms
    '        Debug.Print "Doing: " & aForm.name
            Call ApplyUILanguageToThisForm(aForm)
        Next aForm
    End If
<b>End Sub</b>

<b>Private Sub LoadXMLDocFromIni(Path As String)</b>
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    'loads the ini file indicated by path into the mlanguagedoc file
    Dim fso As Scripting.FileSystemObject
    Set fso = New Scripting.FileSystemObject
    Dim ts As Scripting.TextStream
    Dim got As String
    Dim newItem As IXMLDOMNode
    Dim parts() As String
    
    Set mLanguageDoc = New DOMDocument30
    Set mAppDoc = New DOMDocument30
    mLanguageDoc.async = False
    mAppDoc.async = False
    'load the xml frameworks
    Call mLanguageDoc.loadXML("&lt;language version=""3"">&lt;languages>&lt;language id=""local"" name=""Locally-defined Language"" font=""Tahoma"" charset=""0"" localeID=""0"">&lt;localname>Locally-defined Langauge&lt;/localname>&lt;/language>&lt;/languages>&lt;contents/>&lt;/language>")
    Call mAppDoc.loadXML("&lt;language version=""3"">&lt;contents/>&lt;help/>&lt;popupHelp/>&lt;/language>")
    'parse the ini file to extract language information
    Set ts = fso.OpenTextFile(Path, ForReading, False, TristateTrue)
    While Not ts.AtEndOfStream
        got = ts.ReadLine
        
        If left(got, 1) = "[" Or Len(Trim(got)) = 0 Or InStr(1, got, "=", vbTextCompare) = 0 Then
            'ignore this line
        ElseIf StrComp(left(got, 9), "FontName=", vbTextCompare) = 0 Then
            'got a specific special font instruction
            mLanguageDoc.documentElement.selectSingleNode("languages/language").Attributes.getNamedItem("font").text = Trim(Replace(got, "FontName=", "", vbTextCompare))
        ElseIf StrComp(left(got, 8), "Charset=", vbTextCompare) = 0 Then
            'got a charset instruction
            mLanguageDoc.documentElement.selectSingleNode("languages/language").Attributes.getNamedItem("charset").text = Trim(Replace(got, "Charset=", "", vbTextCompare))
        ElseIf StrComp(left(got, 9), "LocaleID=", vbTextCompare) = 0 Then
            'got a locale ID instruction
            mLanguageDoc.documentElement.selectSingleNode("languages/language").Attributes.getNamedItem("localeID").text = Trim(Replace(got, "LocaleID=", "", vbTextCompare))
        Else
            'got an entry to add
            parts() = Split(got, "=", 2)
            If UBound(parts) &lt; 1 Then
                'don't add, not got all the bits!
            Else
                'Add to loaded document.
                Set newItem = mAppDoc.createNode(NODE_ELEMENT, "item", "")
                Call newItem.appendChild(mAppDoc.createNode(NODE_ELEMENT, "key", ""))
                newItem.selectSingleNode("key").text = parts(0)
                Call newItem.appendChild(mAppDoc.createNode(NODE_ELEMENT, "content", ""))
                Call newItem.selectSingleNode("content").Attributes.setNamedItem(mAppDoc.createAttribute("language"))
                newItem.selectSingleNode("content").Attributes.getNamedItem("language").text = "local"
                parts(1) = Trim(parts(1))
                If left(parts(1), 1) = """" And right(parts(1), 1) = """" Then
                    parts(1) = left(parts(1), Len(parts(1)) - 1)
                    parts(1) = right(parts(1), Len(parts(1)) - 1)
                End If
                newItem.selectSingleNode("content").text = parts(1)
                Call mAppDoc.documentElement.selectSingleNode("contents").appendChild(newItem)
            End If
        End If
    Wend
    Call ts.Close
    'Debug.Print mLanguageDoc.xml
<b>End Sub</b>

<b>Public Function fontDefined() As Boolean</b>
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    If Not mInitialised Then Call Initialise
    fontDefined = (Len(mstrFontname) > 0)
End Function

<b>Public Function helpTopicCount() As Integer</b>
    #If debugging = 0 Then
    On Error Resume Next
    #End If
    Dim helpNode As IXMLDOMNode
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
    Else
        If Dir(GetAppPath & "\" & App.EXEName & ".Help.txt") &lt;> "" Then
            'Got ini file to use as help
            helpTopicCount = 1
        Else
            Set helpNode = mAppDoc.documentElement.selectSingleNode("help")
            If helpNode Is Nothing Then
                helpTopicCount = 0
            Else
                helpTopicCount = helpNode.selectNodes("topic").length
            End If
        End If
    End If
End Function

<b>Public Function helpTopicTitle(index As Integer) As String</b>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim got As String
    
    If Not mInitialised Then Call Initialise
    If mLanguageFilesNotAvailable Then
    Else
        got = helpTopicText(index)
        If Len(got) > 0 Then helpTopicTitle = left(got, InStr(1, got, vbNewLine) - 1)
    End If
End Function

<b>Public Function helpTopicText(index As Integer) As String</b>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim fso As Scripting.FileSystemObject
    Dim ts As Scripting.TextStream
    Dim topicNode As IXMLDOMNode
    Dim topics As IXMLDOMNodeList
    Dim contentNode As IXMLDOMNode
    
    If Not mInitialised Then Call Initialise
    
    If mLanguageFilesNotAvailable Then
    Else
        If Dir(GetAppPath & "\" & App.EXEName & ".Help.txt") &lt;> "" Then
            'local Unicode help file to use
            Set fso = New Scripting.FileSystemObject
            Set ts = fso.OpenTextFile(GetAppPath & "\" & App.EXEName & ".Help.txt", ForReading, False, TristateTrue)
            helpTopicText = ts.ReadAll
            Call ts.Close
            Set fso = Nothing
        Else
            'Use XML if valid
            Set topics = mAppDoc.documentElement.selectNodes("help/topic")
            If topics Is Nothing Then
            ElseIf topics.length = 0 Then
            ElseIf index &lt; 0 Or index > topics.length - 1 Then
            Else
                Set topicNode = topics.Item(index)
                Set contentNode = topicNode.selectSingleNode("content[@language=""" & mUserLanguage & """]")
                If contentNode Is Nothing Then Set contentNode = topicNode.selectSingleNode("content[@language=""en-gb""]")
                If contentNode Is Nothing Then
                    'No topic!
                Else
                    helpTopicText = ProcessHelpNode(contentNode)
                End If
            End If
        End If
    End If
End Function

<b>Private Function ProcessHelpNode(helpNode As IXMLDOMNode) As String</b>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    'iterate through the helpNode inserting newlines where indicated by
    '&lt;p> nodes
    Dim paragraphNode As IXMLDOMNode
    Dim output As String
    
    output = helpNode.Attributes.getNamedItem("title").text & vbNewLine & vbNewLine
    For Each paragraphNode In helpNode.selectNodes("p")
        output = output & paragraphNode.text & vbNewLine
    Next paragraphNode
    ProcessHelpNode = output
End Function

<b>Private Function ReadIniFileLanguage(ByVal strIniFile As String, ByVal strSECTION As String, ByVal strKey As String) As String</b>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    Dim strBuffer As String
    Dim strNull As String

    strBuffer = Space$(256)
    If GetPrivateProfileStrinmodi18n(strSECTION, strKey, strNull, strBuffer, Len(strBuffer) - 1, strIniFile) > 0 Then
        ReadIniFileLanguage = left(strBuffer, InStr(strBuffer, Chr(0)) - 1)
    Else
        ReadIniFileLanguage = ""
    End If
End Function

<b>Public Function popupHelp(key As String) As String</b>
    #If debugging = 0 Then
        On Error Resume Next
    #End If
    'look up popup help
    Dim resultNode As IXMLDOMNode
    Dim textNode As IXMLDOMNode

    If mLanguageFilesNotAvailable Then
    Else
        Set resultNode = mAppDoc.documentElement.selectSingleNode("popupHelp/item[key=""" & key & """]")
        If resultNode Is Nothing Then
        Else
            Set textNode = resultNode.selectSingleNode("content[@language=""" & mUserLanguage & """]")
            If textNode Is Nothing Then Set textNode = resultNode.selectSingleNode("content[@language=""en-gb""]")
            If textNode Is Nothing Then
                'No result found.
            Else
                popupHelp = textNode.text
            End If
            End If
        End If
End Function

<b>Private Function IsVistaOrAbove() As Boolean</b>
#If debugging = 0 Then
    On Error Resume Next
#End If
    Dim tOSV As OSVERSIONINFO
    tOSV.dwVersionInfoSize = Len(tOSV)
    If GetVersionEx(tOSV) > 0 Then
        If (tOSV.dwMajorVersion > 5) Then
           IsVistaOrAbove = True
        End If
    End If
End Function

</pre>
<h2>Module modXPStyle</h2>
<p>Filename: ..\Common\modXPStyle.bas</p><p>Date last modified: Wed Jan 2009 22:59</p><!-- 
Attribute VB_Name = "modXPStyle"
Option Explicit

Private Type tagInitCommonControlsEx
   lngSize As Long
   lngICC As Long
End Type
Private Declare Function InitCommonControlsEx Lib "comctl32.dll" _
   (iccex As tagInitCommonControlsEx) As Boolean
Private Const ICC_USEREX_CLASSES = &H200

Public Function InitCommonControlsVB() As Boolean
   On Error Resume Next
   Dim iccex As tagInitCommonControlsEx
   ' Ensure CC available:
   With iccex
       .lngSize = LenB(iccex)
       .lngICC = ICC_USEREX_CLASSES
   End With
   InitCommonControlsEx iccex
   InitCommonControlsVB = (Err.Number = 0)
   On Error GoTo 0
End Function


-->
<pre id="0">
Option Explicit

Private Type tagInitCommonControlsEx
   lngSize As Long
   lngICC As Long
End Type
Private Declare Function InitCommonControlsEx Lib "comctl32.dll" _
   (iccex As tagInitCommonControlsEx) As Boolean
Private Const ICC_USEREX_CLASSES = &H200

<b>Public Function InitCommonControlsVB() As Boolean</b>
   On Error Resume Next
   Dim iccex As tagInitCommonControlsEx
   ' Ensure CC available:
   With iccex
       .lngSize = LenB(iccex)
       .lngICC = ICC_USEREX_CLASSES
   End With
   InitCommonControlsEx iccex
   InitCommonControlsVB = (Err.Number = 0)
   On Error GoTo 0
End Function


</pre>
<h2>Module modUpdate</h2>
<p>Filename: ..\Common\modUpdate.bas</p><p>Date last modified: Fri May 2009 18:18</p><!-- 
Attribute VB_Name = "modUpdate"
Option Explicit

'Call CheckForUpdates when you start each Accessible program.

Public Sub CheckForUpdates()
'Shells the WebbIE update check program and lets it get on with things.
    On Error Resume Next
    If Len(Dir(GetAppPath & "\CheckForWebbIEUpdates.exe", vbNormal)) > 0 Then
        Call Shell(GetAppPath & "\CheckForWebbIEUpdates.exe", vbHide)
    End If
End Sub

-->
<pre id="0">
Option Explicit

<font color="green">'Call CheckForUpdates when you start each Accessible program.</font>

<b>Public Sub CheckForUpdates()</b>
<font color="green">'Shells the WebbIE update check program and lets it get on with things.</font>
    On Error Resume Next
    If Len(Dir(GetAppPath & "\CheckForWebbIEUpdates.exe", vbNormal)) > 0 Then
        Call Shell(GetAppPath & "\CheckForWebbIEUpdates.exe", vbHide)
    End If
<b>End Sub</b>

</pre>
<h2>Module modShared</h2>
<p>Filename: ..\Common\modShared.bas</p><p>Date last modified: Tue Mar 2009 08:20</p><!-- 
Attribute VB_Name = "modShared"
'modShared
'Holds code common to all Alasdair applications

'Copyright (c) 2007, Alasdair King
'All rights reserved.
'
'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
'
'    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
'    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
'    * Neither the name of [Alasdair] nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
'
'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'07 Aug 2006 - Added GetCurrentDateAsRFC822, used in Inform and WebbIERSS
'07 Aug 2006 - Moved in lots of other functions...
'17 Aug 2006 - Added SetupApplicationDirectory stuff.
'23 Aug 2006 - Added OpenUrlInWebBrowser using ShellExecute
'23 Aug 2006 - Added ShellExecute
'6 Sept 2006 - Added GetSystemFontName
'23 Sept 2006 - Added LockWindowUpdate
' 3 Oct 2006 - Added DeriveAppPath
'23 Oct 2007 - Added ReadFile
'12 Dec 2007 - Added ConvertWindowsToCSSColours
'13 Dec 2007 - Added MakePathSafe

'Needs reference to Windows Script Host Object Model and
'Microsoft Scripting Runtime

Option Explicit

'Fonts
'See http://www.freevbcode.com/ShowCode.Asp?ID=208
Public Const LF_FACESIZE = 32
Public Const SPI_GETNONCLIENTMETRICS = 41
Public Type LOGFONT
    lfHeight As Long
    lfWidth As Long
    lfEscapement As Long
    lfOrientation As Long
    lfWeight As Long
    lfItalic As Byte
    lfUnderline As Byte
    lfStrikeOut As Byte
    lfCharSet As Byte
    lfOutPrecision As Byte
    lfClipPrecision As Byte
    lfQuality As Byte
    lfPitchAndFamily As Byte
    lfFaceName(1 To LF_FACESIZE) As Byte
End Type
Public Type NONCLIENTMETRICS
    cbSize As Long
    iBorderWidth As Long
    iScrollWidth As Long
    iScrollHeight As Long
    iCaptionWidth As Long
    iCaptionHeight As Long
    lfCaptionFont As LOGFONT
    iSMCaptionWidth As Long
    iSMCaptionHeight As Long
    lfSMCaptionFont As LOGFONT
    iMenuWidth As Long
    iMenuHeight As Long
    lfMenuFont As LOGFONT
    lfStatusFont As LOGFONT
    lfMessageFont As LOGFONT
End Type
Public Declare Function SystemParametersInfo Lib "User32" _
Alias "SystemParametersInfoA" (ByVal uAction As Long, _
ByVal uParam As Long, ByRef lpvParam As Any, _
ByVal fuWinIni As Long) As Long


'Prevents a control from being updated
'Pass it the hWnd for the control to lock, 0 to cancel
'See http://www.vbaccelerator.com/home/VB/Tips/Prevent_A_Window_From_Repainting/article.asp
Public Declare Function LockWindowUpdate Lib "User32" _
    (ByVal hwndLock As Long) As Long

'see http://www.nsftools.com/tips/ShellExec.lss
'** ShellExecute will open a file using the registered file association on the computer.
'** If it returns a value of greater than 32 then the call was successful; otherwise
'** it should return one of the error codes below. The parameters are:
'**     hwnd = an active window handle, or 0
'**     operation = "edit", "explore", "find", "open", or "print"
'**     fileName = a file or directory name
'**     parameters = if fileName is an executable file, the command line parameters
'**                         to pass when launching the application, or "" if no parameters
'**                         are necessary
'**     directory = the default directory to use, or "" if you don't care
'**     displayType = one of the displayType constants listed below
Declare Function ShellExecute Lib "Shell32" Alias "ShellExecuteA" _
(ByVal hwnd As Long, ByVal operation As String, ByVal filename As String, _
ByVal parameters As String, ByVal directory As String, ByVal displayType As Long) As Long

'** FindExecutable will determine the executable file that is set up to open a particular
'** file based on the file associations on this computer. If it returns a value of greater than
'** 32 then the call was successful; otherwise it should return one of the error codes
'** below. The parameters are:
'**     fileName = the full path to the file you are trying to find the association for
'**     directory = the default directory to use, or "" if you don't care
'**     retAssociation = the associated executable will be returned as this parameter,
'**                         with a maximum string length of 255 characters (you will want
'**                         to pass a String that's 256 characters long and trim the
'**                         null-terminated result)
Declare Function FindExecutable Lib "Shell32" Alias "FindExecutableA" _
(ByVal filename As String, ByVal directory As String, ByVal retAssociation As String) As Long

'** constants for the displayType parameter
Public Const SW_HIDE = 0
Public Const SW_SHOWNORMAL = 1
Public Const SW_NORMAL = 1
Public Const SW_SHOWMINIMIZED = 2
Public Const SW_SHOWMAXIMIZED = 3
Public Const SW_MAXIMIZE = 3
Public Const SW_SHOWNOACTIVATE = 4
Public Const SW_SHOW = 5
Public Const SW_MINIMIZE = 6
Public Const SW_SHOWMINNOACTIVE = 7
Public Const SW_SHOWNA = 8
Public Const SW_RESTORE = 9
Public Const SW_SHOWDEFAULT = 10
Public Const SW_MAX = 10
'** possible errors returned by ShellExecute
Const ERROR_OUT_OF_MEMORY = 0       'The operating system is out of memory or resources.
Const ERROR_FILE_NOT_FOUND = 2      'The specified file was not found.
Const ERROR_PATH_NOT_FOUND = 3  'The specified path was not found.
Const ERROR_BAD_FORMAT = 11         'The .exe file is invalid (non-Microsoft Win32 .exe or error in .exe image).
Const SE_ERR_FNF = 2                            'The specified file was not found.
Const SE_ERR_PNF = 3                        'The specified path was not found.
Const SE_ERR_ACCESSDENIED = 5       'The operating system denied access to the specified file.
Const SE_ERR_OOM = 8                        'There was not enough memory to complete the operation.
Const SE_ERR_SHARE = 26                 'A sharing violation occurred.
Const SE_ERR_ASSOCINCOMPLETE = 27   'The file name association is incomplete or invalid.
Const SE_ERR_DDETIMEOUT = 28            'The DDE transaction could not be completed because the request timed out.
Const SE_ERR_DDEFAIL = 29               'The DDE transaction failed.
Const SE_ERR_DDEBUSY = 30               'The Dynamic Data Exchange (DDE) transaction could not be completed because other DDE transactions were being processed.
Const SE_ERR_NOASSOC = 31               'There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.
Const SE_ERR_DLLNOTFOUND = 32       'The specified dynamic-link library (DLL) was not found.

'CONSTANTS
Public Const HKEY_CLASSES_ROOT = &H80000000
Public Const HKEY_CURRENT_USER = &H80000001
Public Const HKEY_LOCAL_MACHINE = &H80000002
Public Const HKEY_USERS = &H80000003
Public Const HKEY_CURRENT_CONFIG = &H80000005
Public Const HKEY_DYN_DATA = &H80000006
Public Const REG_SZ = 1 'Unicode nul terminated string
Public Const REG_BINARY = 3 'Free form binary
Public Const REG_DWORD = 4 '32-bit number
Public Const ERROR_SUCCESS = 0&
Public Const RESERVED_NULL = 0
Public Const INTERNET_CONNECTION_MODEM As Long = &H1
Public Const MIIM_SUBMENU As Long = &H4
Public Const APINULL = 0&
Public Const EM_SCROLLCARET = &HB7
Public Const EM_LINEINDEX = &HBB
Public Const EM_GETLINECOUNT = &HBA
Public Const EM_LINELENGTH = &HC1
Public Const EM_GETFIRSTVISIBLELINE = &HCE
Public Const EM_LINEFROMCHAR = &HC9
Public Const EM_GETLINE = &HC4
Public Const EM_LINESCROLL = &HB6
Public Const EM_SETSEL = &HB1
Public Const KEY_READ = &H20019                    '-- Permission for general read access.
Public Const KEY_QUERY_VALUE = &H1
Public Const MF_MENUBREAK As Long = &H40&  'indicates a vertical break
Public Const MIIM_STATE As Long = &H1
Public Const MIIM_ID As Long = &H2
Public Const MIIM_CHECKMARKS As Long = &H8
Public Const MIIM_TYPE As Long = &H10
Public Const MIIM_DATA As Long = &H20
Public Const MIIM_STRING As Long = &H40
Public Const MIIM_BITMAP As Long = &H80
Public Const MIIM_FTYPE As Long = &H100
Public Const FBYPOSITION_POSITION As Boolean = True
Public Const FBYPOSTION_IDENTIFIER As Boolean = False
Public Const MF_STRING As Long = &H0&
Public Const GWL_WNDPROC As Long = (-4)
Public Const WM_COMMAND = &H111 ' indicates that a command has been intercepted by the app
Public Const MF_BYPOSITION = &H400& ' indicates a menu item by position, not by name, for RemoveMenu
Public Const MF_DISABLED = &H2& ' used in setting menu items (InsertMenuItem etc) to indicate that an item is greyed
Public Const MF_GRAYED = &H1& ' allegedly does the same thing as MF_DISABLED
'The maximum length, it is assumed, in characters, of one line of text in the browser
Public Const MAX_LINE_LENGTH As Integer = 255

Public Const SND_FILENAME = &H20000 ' Name is a file name
Public Const SND_NODEFAULT = &H2  ' silence not default, if sound not found
Public Const SND_ASYNC = &H1 ' play asynchronously ie return to main thread while playing

'keybd_event
'http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/keybd_event.asp?frame=true
Public Declare Sub keybd_event Lib "User32" _
         (ByVal bVk As Byte, _
          ByVal bScan As Byte, _
          ByVal dwflags As Long, ByVal dwExtraInfo As Long)
Public Const VK_CAPITAL = &H14
Public Const VK_MENU = &H14
Public Const VK_NUMLOCK = &H90
Public Const KEYEVENTF_EXTENDEDKEY = &H1
Public Const KEYEVENTF_KEYUP = &H2
Public Const VER_PLATFORM_WIN32_NT = 2
Public Const VER_PLATFORM_WIN32_WINDOWS = 1

Dim gstrNull As Variant

'NumLock
'From http://support.microsoft.com/kb/177674/
Public Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128   '  Maintenance string for PSS usage
End Type
Public Declare Function GetVersionEx Lib "kernel32" _
         Alias "GetVersionExA" _
         (lpVersionInformation As OSVERSIONINFO) As Long
Public Declare Function GetKeyboardState Lib "User32" _
         (pbKeyState As Byte) As Long
Public Declare Function SetKeyboardState Lib "User32" _
         (lppbKeyState As Byte) As Long

Public Declare Function GetPrivateProfileInt Lib "kernel32" Alias "GetPrivateProfileIntA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal nDefault As Long, ByVal lpFileName As String) As Long
Public Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Public Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpSectionName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long


'See http://www.codenewsgroups.net/group/microsoft.public.vb.general.discussion/topic2255.aspx
Public Declare Function GetSystemDefaultLCID Lib "kernel32" () As Long
Public Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
Public Declare Function SetLocaleInfo Lib "kernel32" Alias "SetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String) As Long
Public Const LOCALE_USER_DEFAULT = &H400
Public Const LOCALE_SYSTEM_DEFAULT = &H800
Public Const LOCALE_ILANGUAGE             As Long = &H1     'language id
Public Const LOCALE_SLANGUAGE             As Long = &H2     'localized name of language
Public Const LOCALE_SENGLANGUAGE          As Long = &H1001  'English name of language
Public Const LOCALE_SABBREVLANGNAME       As Long = &H3     'abbreviated language name
Public Const LOCALE_SNATIVELANGNAME       As Long = &H4     'native name of language

Public Const LOCALE_ICOUNTRY              As Long = &H5     'country code
Public Const LOCALE_SCOUNTRY              As Long = &H6     'localized name of country
Public Const LOCALE_SENGCOUNTRY           As Long = &H1002  'English name of country
Public Const LOCALE_SABBREVCTRYNAME       As Long = &H7     'abbreviated country name
Public Const LOCALE_SNATIVECTRYNAME       As Long = &H8     'native name of country

Public Const LOCALE_IDEFAULTLANGUAGE      As Long = &H9     'default language id
Public Const LOCALE_IDEFAULTCOUNTRY       As Long = &HA     'default country code
Public Const LOCALE_IDEFAULTCODEPAGE      As Long = &HB     'default oem code page
Public Const LOCALE_IDEFAULTANSICODEPAGE  As Long = &H1004  'default ansi code page
Public Const LOCALE_IDEFAULTMACCODEPAGE   As Long = &H1011  'default mac code page

Public Const LOCALE_SLIST                 As Long = &HC     'list item separator
Public Const LOCALE_IMEASURE              As Long = &HD     '0 = metric, 1 = US

Public Const LOCALE_SDECIMAL              As Long = &HE     'decimal separator
Public Const LOCALE_STHOUSAND             As Long = &HF     'thousand separator
Public Const LOCALE_SGROUPING             As Long = &H10    'digit grouping
Public Const LOCALE_IDIGITS               As Long = &H11    'number of fractional digits
Public Const LOCALE_ILZERO                As Long = &H12    'leading zeros for decimal
Public Const LOCALE_INEGNUMBER            As Long = &H1010  'negative number mode
Public Const LOCALE_SNATIVEDIGITS         As Long = &H13    'native ascii 0-9

Public Const LOCALE_SCURRENCY             As Long = &H14    'local monetary symbol
Public Const LOCALE_SINTLSYMBOL           As Long = &H15    'intl monetary symbol
Public Const LOCALE_SMONDECIMALSEP        As Long = &H16    'monetary decimal separator
Public Const LOCALE_SMONTHOUSANDSEP       As Long = &H17    'monetary thousand separator
Public Const LOCALE_SMONGROUPING          As Long = &H18    'monetary grouping
Public Const LOCALE_ICURRDIGITS           As Long = &H19    '# local monetary digits
Public Const LOCALE_IINTLCURRDIGITS       As Long = &H1A    '# intl monetary digits
Public Const LOCALE_ICURRENCY             As Long = &H1B    'positive currency mode
Public Const LOCALE_INEGCURR              As Long = &H1C    'negative currency mode

Public Const LOCALE_SDATE                 As Long = &H1D    'date separator
Public Const LOCALE_STIME                 As Long = &H1E    'time separator
Public Const LOCALE_SSHORTDATE            As Long = &H1F    'short date format string
Public Const LOCALE_SLONGDATE             As Long = &H20    'long date format string
Public Const LOCALE_STIMEFORMAT           As Long = &H1003  'time format string
Public Const LOCALE_IDATE                 As Long = &H21    'short date format ordering
Public Const LOCALE_ILDATE                As Long = &H22    'long date format ordering
Public Const LOCALE_ITIME                 As Long = &H23    'time format specifier
Public Const LOCALE_ITIMEMARKPOSN         As Long = &H1005  'time marker position
Public Const LOCALE_ICENTURY              As Long = &H24    'century format specifier (short date)
Public Const LOCALE_ITLZERO               As Long = &H25    'leading zeros in time field
Public Const LOCALE_IDAYLZERO             As Long = &H26    'leading zeros in day field (short date)
Public Const LOCALE_IMONLZERO             As Long = &H27    'leading zeros in month field (short date)
Public Const LOCALE_S1159                 As Long = &H28    'AM designator
Public Const LOCALE_S2359                 As Long = &H29    'PM designator

Public Const LOCALE_ICALENDARTYPE         As Long = &H1009  'type of calendar specifier
Public Const LOCALE_IOPTIONALCALENDAR     As Long = &H100B  'additional calendar types specifier
Public Const LOCALE_IFIRSTDAYOFWEEK       As Long = &H100C  'first day of week specifier
Public Const LOCALE_IFIRSTWEEKOFYEAR      As Long = &H100D  'first week of year specifier

Public Const LOCALE_SDAYNAME1             As Long = &H2A    'long name for Monday
Public Const LOCALE_SDAYNAME2             As Long = &H2B    'long name for Tuesday
Public Const LOCALE_SDAYNAME3             As Long = &H2C    'long name for Wednesday
Public Const LOCALE_SDAYNAME4             As Long = &H2D    'long name for Thursday
Public Const LOCALE_SDAYNAME5             As Long = &H2E    'long name for Friday
Public Const LOCALE_SDAYNAME6             As Long = &H2F    'long name for Saturday
Public Const LOCALE_SDAYNAME7             As Long = &H30    'long name for Sunday
Public Const LOCALE_SABBREVDAYNAME1       As Long = &H31    'abbreviated name for Monday
Public Const LOCALE_SABBREVDAYNAME2       As Long = &H32    'abbreviated name for Tuesday
Public Const LOCALE_SABBREVDAYNAME3       As Long = &H33    'abbreviated name for Wednesday
Public Const LOCALE_SABBREVDAYNAME4       As Long = &H34    'abbreviated name for Thursday
Public Const LOCALE_SABBREVDAYNAME5       As Long = &H35    'abbreviated name for Friday
Public Const LOCALE_SABBREVDAYNAME6       As Long = &H36    'abbreviated name for Saturday
Public Const LOCALE_SABBREVDAYNAME7       As Long = &H37    'abbreviated name for Sunday
Public Const LOCALE_SMONTHNAME1           As Long = &H38    'long name for January
Public Const LOCALE_SMONTHNAME2           As Long = &H39    'long name for February
Public Const LOCALE_SMONTHNAME3           As Long = &H3A    'long name for March
Public Const LOCALE_SMONTHNAME4           As Long = &H3B    'long name for April
Public Const LOCALE_SMONTHNAME5           As Long = &H3C    'long name for May
Public Const LOCALE_SMONTHNAME6           As Long = &H3D    'long name for June
Public Const LOCALE_SMONTHNAME7           As Long = &H3E    'long name for July
Public Const LOCALE_SMONTHNAME8           As Long = &H3F    'long name for August
Public Const LOCALE_SMONTHNAME9           As Long = &H40    'long name for September
Public Const LOCALE_SMONTHNAME10          As Long = &H41    'long name for October
Public Const LOCALE_SMONTHNAME11          As Long = &H42    'long name for November
Public Const LOCALE_SMONTHNAME12          As Long = &H43    'long name for December
Public Const LOCALE_SMONTHNAME13          As Long = &H100E  'long name for 13th month (if exists)
Public Const LOCALE_SABBREVMONTHNAME1     As Long = &H44    'abbreviated name for January
Public Const LOCALE_SABBREVMONTHNAME2     As Long = &H45    'abbreviated name for February
Public Const LOCALE_SABBREVMONTHNAME3     As Long = &H46    'abbreviated name for March
Public Const LOCALE_SABBREVMONTHNAME4     As Long = &H47    'abbreviated name for April
Public Const LOCALE_SABBREVMONTHNAME5     As Long = &H48    'abbreviated name for May
Public Const LOCALE_SABBREVMONTHNAME6     As Long = &H49    'abbreviated name for June
Public Const LOCALE_SABBREVMONTHNAME7     As Long = &H4A    'abbreviated name for July
Public Const LOCALE_SABBREVMONTHNAME8     As Long = &H4B    'abbreviated name for August
Public Const LOCALE_SABBREVMONTHNAME9     As Long = &H4C    'abbreviated name for September
Public Const LOCALE_SABBREVMONTHNAME10    As Long = &H4D    'abbreviated name for October
Public Const LOCALE_SABBREVMONTHNAME11    As Long = &H4E    'abbreviated name for November
Public Const LOCALE_SABBREVMONTHNAME12    As Long = &H4F    'abbreviated name for December
Public Const LOCALE_SABBREVMONTHNAME13    As Long = &H100F  'abbreviated name for 13th month (if exists)

Public Const LOCALE_SPOSITIVESIGN         As Long = &H50    'positive sign
Public Const LOCALE_SNEGATIVESIGN         As Long = &H51    'negative sign
Public Const LOCALE_IPOSSIGNPOSN          As Long = &H52    'positive sign position
Public Const LOCALE_INEGSIGNPOSN          As Long = &H53    'negative sign position
Public Const LOCALE_IPOSSYMPRECEDES       As Long = &H54    'mon sym precedes pos amt
Public Const LOCALE_IPOSSEPBYSPACE        As Long = &H55    'mon sym sep by space from pos amt
Public Const LOCALE_INEGSYMPRECEDES       As Long = &H56    'mon sym precedes neg amt
Public Const LOCALE_INEGSEPBYSPACE        As Long = &H57    'mon sym sep by space from neg amt

Public Const LOCALE_FONTSIGNATURE         As Long = &H58    'font signature
Public Const LOCALE_SISO639LANGNAME       As Long = &H59    'ISO abbreviated language name
Public Const LOCALE_SISO3166CTRYNAME      As Long = &H5A    'ISO abbreviated country name

Public Const LOCALE_IDEFAULTEBCDICCODEPAGE As Long = &H1012 'default ebcdic code page
Public Const LOCALE_IPAPERSIZE            As Long = &H100A  '0 = letter, 1 = a4, 2 = legal, 3 = a3
Public Const LOCALE_SENGCURRNAME          As Long = &H1007  'english name of currency
Public Const LOCALE_SNATIVECURRNAME       As Long = &H1008  'native name of currency
Public Const LOCALE_SYEARMONTH            As Long = &H1006  'year month format string
Public Const LOCALE_SSORTNAME             As Long = &H1013  'sort name
Public Const LOCALE_IDIGITSUBSTITUTION    As Long = &H1014  '0 = none, 1 = context, 2 = native digit

'SHGetPathFromIDList
'Returns the path (string) from the folder ID obtained by SHGetSpecialFolderLocation
Public Declare Function SHGetPathFromIDList Lib "Shell32" Alias "SHGetPathFromIDListA" (ByVal Pidl As Long, ByVal pszPath As String) As Long

Public Const GAP As Long = 90 'the twip distance for spacing UI elements

'SHGetSpecialFolderLocation
'Returns the Folder ID of the user's My Documents folder (or another folder indicated
'by CSIDL)
Public Declare Function SHGetSpecialFolderLocation Lib "Shell32" (ByVal hwnd As Long, ByVal nFolder As Long, ppidl As Long) As Long
' constants for Shell.NameSpace method -- these are the "special folders"
'contained in the Windows shell
Public Const CSIDL_DESKTOP = &H0 ' Desktop
Public Const CSIDL_INTERNET = &H1 ' The internet
Public Const CSIDL_PROGRAMS = &H2 ' Shortcuts in the Programs menu
Public Const CSIDL_CONTROLS = &H3 ' Control Panel
Public Const CSIDL_PRINTERS = &H4 ' Printers
Public Const CSIDL_PERSONAL = &H5 ' Shortcuts to Personal files
Public Const CSIDL_FAVORITES = &H6 ' Shortcuts to favorite folders
Public Const CSIDL_STARTUP = &H7 ' Shortcuts to apps that start at boot Time
Public Const CSIDL_RECENT = &H8 ' Shortcuts to recently used docs
Public Const CSIDL_SENDTO = &H9 ' Shortcuts for the SendTo menu
Public Const CSIDL_BITBUCKET = &HA ' Recycle Bin
Public Const CSIDL_STARTMENU = &HB ' User-defined items in Start Menu
Public Const CSIDL_DESKTOPDIRECTORY = &H10 ' Directory with all the desktop shortcuts
Public Const CSIDL_DRIVES = &H11 ' My Computer
Public Const CSIDL_NETWORK = &H12 ' Network Neighborhood virtual folder
Public Const CSIDL_NETHOOD = &H13 ' Directory containing objects in the network neighborhood
Public Const CSIDL_FONTS = &H14 ' Installed fonts
Public Const CSIDL_TEMPLATES = &H15 ' Shortcuts to document templates
Public Const CSIDL_COMMON_STARTMENU = &H16 ' Directory with items in the Start menu for all users
Public Const CSIDL_COMMON_PROGRAMS = &H17 ' Directory with items in the Programs menu for all users
Public Const CSIDL_COMMON_STARTUP = &H18 ' Directory with items in the StartUp submenu for all users
Public Const CSIDL_COMMON_DESKTOPDIRECTORY = &H19 ' Directory with items on the desktop of all users
Public Const CSIDL_APPDATA = &H1A ' Folder for application-specific data
Public Const CSIDL_PRINTHOOD = &H1B ' Directory with references to printer links
Public Const CSIDL_LOCAL_APPDATA = &H1C          '{user name}\Local Settings\Application Data (non roaming)
Public Const CSIDL_ALTSTARTUP = &H1D ' (DBCS) Directory corresponding to user 's nonlocalized Startup program group
Public Const CSIDL_COMMON_ALTSTARTUP = &H1E ' (DBCS) Directory with Startup items for all users
Public Const CSIDL_COMMON_FAVORITES = &H1F ' Directory with all user's favorit items
Public Const CSIDL_INTERNET_CACHE = &H20 ' Directory for temporary internet Files
Public Const CSIDL_COOKIES = &H21 ' Directory for Internet cookies
Public Const CSIDL_HISTORY = &H22 ' Directory for Internet history items
Public Const CSIDL_COMMON_APPDATA = &H23          'All Users\Application Data
Public Const CSIDL_WINDOWS = &H24                 'GetWindowsDirectory()
Public Const CSIDL_SYSTEM = &H25                  'GetSystemDirectory()
Public Const CSIDL_PROGRAM_FILES = &H26           'C:\Program Files
Public Const CSIDL_MYPICTURES = &H27                 'C:\Program Files\My Pictures
Public Const CSIDL_PROFILE = &H28                 'USERPROFILE
Public Const CSIDL_SYSTEMX86 = &H29               'x86 system directory on RISC
Public Const CSIDL_PROGRAM_FILESX86 = &H2A        'x86 C:\Program Files on RISC
Public Const CSIDL_PROGRAM_FILES_COMMON = &H2B    'C:\Program Files\Common
Public Const CSIDL_PROGRAM_FILES_COMMONX86 = &H2C 'x86 Program Files\Common on RISC
Public Const CSIDL_COMMON_TEMPLATES = &H2D        'All Users\Templates
Public Const CSIDL_COMMON_DOCUMENTS = &H2E        'All Users\Documents
Public Const CSIDL_COMMON_ADMINTOOLS = &H2F       'All Users\Start Menu\Programs\Administrative Tools
Public Const CSIDL_ADMINTOOLS = &H30              '{user name}\Start Menu\Programs\Administrative Tools

Public Const CSIDL_FLAG_CREATE = &H8000           'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_DONT_VERIFY = &H4000      'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_MASK = &HFF00             'mask for all possible flag values

'Shut down Windows XP: doesn't work.
Public Declare Function ExitWindowsEx Lib "User32" _
(ByVal uFlags As Long, ByVal dwReserved As Long) As Long
Public Const EWX_LOGOFF = 0
Public Const EWX_SHUTDOWN = 1
Public Const EWX_REBOOT = 2
Public Const EWX_FORCE = 4

'Large font support: see http://www.developerfusion.co.uk/show/275/
Public Type TEXTMETRIC
  tmHeight As Integer
  tmAscent As Integer
  tmDescent As Integer
  tmInternalLeading As Integer
  tmExternalLeading As Integer
  tmAveCharWidth As Integer
  tmMaxCharWidth As Integer
  tmWeight As Integer
  tmItalic As String * 1
  tmUnderlined As String * 1
  tmStruckOut As String * 1
  tmFirstChar As String * 1
  tmLastChar As String * 1
  tmDefaultChar As String * 1
  tmBreakChar As String * 1
  tmPitchAndFamily As String * 1
  tmCharSet As String * 1
  tmOverhang As Integer
  tmDigitizedAspectX As Integer
  tmDigitizedAspectY As Integer
End Type
'Large font support
Public Declare Function GetTextMetrics Lib "gdi32" Alias "GetTextMetricsA" _
 (ByVal hdc As Long, lpMetrics As TEXTMETRIC) As Long
Public Declare Function GetDesktopWindow Lib "User32" () As Long
Public Declare Function GetWindowDC Lib "User32" (ByVal hwnd As Long) As Long
Public Declare Function ReleaseDC Lib "User32" (ByVal hwnd As Long, ByVal hdc _
 As Long) As Long
Public Declare Function SetMapMode Lib "gdi32" (ByVal hdc As Long, ByVal _
nMapMode As Long) As Long

'** CONSTANTS **
Public Const MM_TEXT = 1


'TYPES
Public Type DllVersionInfo
   cbSize As Long
   dwMajorVersion As Long
   dwMinorVersion As Long
   dwBuildNumber As Long
   dwPlatformId As Long
End Type

Public Type MENUITEMINFO
    cbSize As Long
    fMask As Long
    fType As Long
    fState As Long
    wID As Long
    hSubMenu As Long
    hbmpChecked As Long
    hbmpUnchecked As Long
    dwItemData As Long
    dwTypeData As String
    cch As Long
End Type


'METHODS

'URLDownloadToFile
'Downloads a specified url to a local file
Public Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long

'For removing a menu item
Public Declare Function DeleteMenu Lib "User32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

'For finding the system time - used for timing
Public Declare Function GetTickCount Lib "kernel32" () As Long
Public Declare Function TimeGetTime Lib "winmm.dll" () As Long

'For finding IE version
Public Declare Function DllGetVersion Lib "Shlwapi.dll" (dwVersion As DllVersionInfo) As Long
    'for finding IE version
    
'For changing to IE homepage
Public Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Public Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long

Public Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As Long, ByVal lpSubKey As String) As Long

Public Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long

Public Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long

Public Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long

Public Declare Function InternetGetConnectedStateEx Lib "wininet.dll" Alias "InternetGetConnectedStateExA" (lpdwFlags As Long, lpszConnectionName As Long, dwNameLen As Long, ByVal dwReserved As Long) As Long

'This is declaring a Function called
'"PlaySound" and we tell VB that it's located in the
'Library called "winmm.dll". The word 'Alias' means that "PlaySound"
'is actually stored in the DLL as "PlaysoundA", and written in C++ but
'we can use the function in VB as "PlaySound".
'lpszname = file path, hmodule = 0 and dwflags = (Synchonous = 0/Asynchronously = 1)
Public Declare Function PlaySound Lib "winmm.dll" Alias "PlaySoundA" (ByVal lpszName As String, ByVal hModule As Long, ByVal dwflags As Long) As Long
'returns a long, but 0 = successful play

Public Declare Function RasEnumConnections Lib "RasApi32.DLL" Alias "RasEnumConnectionsA" (lprasconn As Any, lpcb As Long, lpcConnections As Long) As Long

Public Declare Function RasHangUp Lib "RasApi32.DLL" Alias "RasHangUpA" (ByVal hRasConn As Long) As Long

Public Declare Function SendMessage Lib "User32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function SendMessageW Lib "User32" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Public Declare Function FolderRegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long
    ' Note that if you declare the lpData parameter as String, you must pass it
    ' By Value.

Public Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
    'must be called before FolderRegQueryEx

'for constructing the Favorites menu
Public Declare Function GetMenu Lib "User32" (ByVal hwnd As Long) As Long

Public Declare Function GetSubMenu Lib "User32" (ByVal hMenu As Long, ByVal nPos As Long) As Long

'for processing the menu favorites
Public Declare Function SetWindowLong Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Public Declare Function CallWindowProc Lib "user32.dll" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Public Declare Function InsertMenuItem Lib "User32" Alias "InsertMenuItemA" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Boolean, ByRef lpcMenuItemInfo As MENUITEMINFO) As Long
    
Public Declare Function SetMenuItemInfo Lib "User32" Alias "SetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Boolean, lpcMenuItemInfo As MENUITEMINFO) As Long

Public Declare Function GetMenuItemInfo Lib "User32" Alias "GetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal b As Long, lpMenuItemInfo As MENUITEMINFO) As Long

Public Declare Function RemoveMenu Lib "User32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

Public Declare Function CreateMenu Lib "User32" () As Long

Public Declare Function CreatePopupMenu Lib "User32" () As Long

Public Declare Function DrawMenuBar Lib "User32" (ByVal hwnd As Long) As Long

Public Declare Function GetModuleHandle Lib "kernel32" Alias "GetModuleHandleA" (ByVal lpModuleName As String) As Long

'Public Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long

'for getting the locale ID for the current machine/user
Public Declare Function GetUserDefaultLCID Lib "kernel32" () As Long

'Used to determine the (window handle of) the current active window in Windows.
Public Declare Function GetForegroundWindow Lib "User32" () As Long

''''FindMimeFromData
''''obtains the mimetype of the resource given in pwzUrl in combination with
''''pwzMimeProposed.
''''See http://msdn.microsoft.com/workshop/networking/moniker/overview/appendix_a.asp
''''And http://msdn.microsoft.com/workshop/networking/moniker/reference/functions/findmimefromdata.asp
'''Private Declare Function FindMimeFromData Lib "urlmon.dll" ( _
'''            ByVal pbc As Long, _
'''            ByVal pwzUrl As String, _
'''            pBuffer As Any, _
'''            ByVal cbSize As Long, _
'''            ByVal pwzMimeProposed As String, _
'''            ByVal dwMimeFlags As Long, _
'''            ByVal ppwzMimeOut As String, _
'''            ByVal dwReserved As Long) As Long
'''
''''Guess what mime type target url is. Doesn't require any data or content-type
''''from server, so based entirely on last three characters pretty much!
'''Public Function FindMimeFromUrl(url As Variant, Optional mimetype As String) As String
'DEV: Can't get this to work at all. Returns random garbage. August 2005.
'''    Dim result As Long
'''    Dim mimetypeGot As String * 100
'''    Dim urlString As String
'''
'''    urlString = url
'''    mimetypeGot = String(100, " ") '& Chr(0)
'''    result = FindMimeFromData(0, urlString, 0, 0, "", 0, mimetypeGot, 0)
'''    Debug.Print "FMFU: " & result
'''    Debug.Print mimetypeGot
'''End Function


Public Sub Scroll(ByRef editControl As Control, lines As Long)
'scrolls the editControl textbox by lines lines
' editControl - the current control
' lines - the number of lines to scroll
    On Error Resume Next
    Call SendMessageW(editControl.hwnd, EM_LINESCROLL, 0, lines)
End Sub

Public Sub ScrollToCursor(ByRef editControl As Control)
'scrolls the editControl textbox to where the cursor is now
' editControl - the current control
    On Error Resume Next
    Call SendMessageW(editControl.hwnd, EM_SCROLLCARET, 0, 0)
End Sub

Public Function GetCurrentLine(ByRef editControl As Control) As String
'returns the text on the current line from the current control
'   editControl - the current control
'   charPos - the position of the cursor in the control
    On Error Resume Next
    Dim gotLine As String ' the line we get back
    Dim lineNumber As Long ' the line number of the current line
    'get the line number: arguments of -1 mean "line with caret", 0 is not used
    lineNumber = SendMessage(editControl.hwnd, EM_LINEFROMCHAR, -1, 0)
    'now get this line and return it
    gotLine = Space(MAX_LINE_LENGTH)
    'first two words have to be a Long, size of String
    gotLine = Chr$(MAX_LINE_LENGTH Mod 256) + Chr$(MAX_LINE_LENGTH / 256) & gotLine
    Call SendMessage(editControl.hwnd, EM_GETLINE, lineNumber, ByVal gotLine)
    GetCurrentLine = gotLine
End Function

Public Function GetCurrentLineIndex(ByRef editControl As Control) As Long
'returns the number of the current line indicated by the cursor
    On Error Resume Next
    'get the line number: arguments of -1 mean "line with caret", 0 is not used
    GetCurrentLineIndex = SendMessage(editControl.hwnd, EM_LINEFROMCHAR, -1, 0)
End Function

Public Function GetNumberedLine(ByRef editControl As Control, lineNumber As Long) As String
'returns the numbered line
    On Error Resume Next
    Dim gotLine As String ' the line we get back
    'now get this line and return it
    gotLine = Space(MAX_LINE_LENGTH)
    'first two words have to be a Long, size of String
    gotLine = Chr$(MAX_LINE_LENGTH Mod 256) + Chr$(MAX_LINE_LENGTH / 256) & gotLine
    Call SendMessage(editControl.hwnd, EM_GETLINE, lineNumber, ByVal gotLine)
    GetNumberedLine = gotLine
End Function

Public Function GetNumberOfLines(ByRef editControl) As Long
'returns the number of lines in the control
    On Error Resume Next
    GetNumberOfLines = SendMessage(editControl.hwnd, EM_GETLINECOUNT, 0, 0)
End Function

Public Function GetCharacterIndexOfLine(ByRef editControl, lineNumber As Long) As Long
'returns the number of characters in the control up to the numbered line
    On Error Resume Next
    GetCharacterIndexOfLine = SendMessage(editControl.hwnd, EM_LINEINDEX, lineNumber, 0)
End Function

Public Sub SetImagesOnOrOffInIE(state As Boolean)
'put image loading in ie in the registry back to its original setting on leaving WebbIE
'state is determined by blnIEImages
    On Error Resume Next
    Dim stateString As String ' null-terminated string containing the word "yes" or "no" - i.e. images on/off
    Dim lengthState As Integer
    Dim imagesKey As String ' the key for images on/off in the registry
    Dim result As Long
    Dim hKeyHandle As Long
    
    If state Then
        stateString = "yes" '& Chr(0) ' note null-termination of "yes" string for API call
    Else
        stateString = "no" '& Chr(0) ' note null-termination of "no" string for API call
    End If
    lengthState = Len(stateString)
    imagesKey = "Software\Microsoft\Internet Explorer\Main" ' & Chr(0) ' also null-terminate
    result = RegOpenKey( _
        HKEY_CURRENT_USER, _
        imagesKey, _
        hKeyHandle _
    )
    imagesKey = "Display Inline Images"
    result = RegSetValueEx( _
        hKeyHandle, _
        imagesKey, _
        0, _
        REG_SZ, _
        ByVal stateString, _
        lengthState _
    )
    Call RegCloseKey(hKeyHandle)
    If result <> ERROR_SUCCESS Then MsgBox result
End Sub

Public Function GetImagesOnOrOffInIE() As Boolean
    On Error Resume Next
    Dim stateString As String ' null-terminated string containing the word "no" - i.e. images off
    Dim lengthState As Integer
    Dim imagesKey As String ' the key for images on/off in the registry
    Dim result As Long
    Dim hKeyHandle As Long
    Dim keySize As Long
    Dim initialValue As String
    'first get the original value so we can restore it when we exit
    'also opens the key for writing
    imagesKey = "Software\Microsoft\Internet Explorer\Main" & Chr(0)
    result = RegOpenKey( _
        HKEY_CURRENT_USER, _
        imagesKey, _
        hKeyHandle _
    )
    keySize = 256
    initialValue = String(keySize, 0)
    imagesKey = "Display Inline images" & Chr(0)
    result = RegQueryValueEx(hKeyHandle, imagesKey, RESERVED_NULL, REG_SZ, _
        ByVal initialValue, keySize)
    initialValue = Trim(initialValue)
    'MsgBox initialValue
    If InStr(1, initialValue, "yes") = 1 Then
        GetImagesOnOrOffInIE = True
    Else
        GetImagesOnOrOffInIE = False
    End If
    Call RegCloseKey(hKeyHandle)
    'If result <> ERROR_SUCCESS Then MsgBox result
End Function

Public Function ReadRegistryEntryNumber(hKey As String, regkey As String, itemKey As String) As Long
'returns the value of the registry key indicated by hKey and regKey
    On Error Resume Next
    Dim lengthState As Integer
    Dim result As Long
    Dim hKeyHandle As Long
    Dim keySize As Long
    Dim initialValue As Long
    'first get the original value so we can restore it when we exit
    'also opens the key for writing
    regkey = regkey & Chr(0)
    result = RegOpenKey( _
        hKey, _
        regkey, _
        hKeyHandle _
    )
    'Debug.Print "res1:" & result
    keySize = Len(initialValue)
    itemKey = itemKey & Chr(0)
    result = RegQueryValueEx(hKeyHandle, itemKey, RESERVED_NULL, REG_DWORD, _
        initialValue, keySize)
    'Debug.Print "res2:" & result
    'Debug.Print "Got from registry number: " & initialValue
    Call RegCloseKey(hKeyHandle)
    'If result <> ERROR_SUCCESS Then MsgBox result
    ReadRegistryEntryNumber = initialValue

End Function

Public Function ReadRegistryEntryString(hKey As String, regkey As String, itemKey As String) As String
'returns the value of the registry key indicated by hKey and regKey
'NOTE: be careful when parsing the results, it seems to produce an ANSI version
'overlaying a Unicode version, e.g. "HELLO L O "
    On Error Resume Next
    Dim lengthState As Integer
    Dim result As Long
    Dim hKeyHandle As Long
    Dim keySize As Long
    Dim initialValue As String
    'first get the original value so we can restore it when we exit
    'also opens the key for writing
    regkey = regkey & Chr(0)
    result = RegOpenKey( _
        hKey, _
        regkey, _
        hKeyHandle _
    )
    'Debug.Print "Result1:" & result
    keySize = 256
    initialValue = String(keySize, 0)
    itemKey = itemKey & Chr(0)
    result = RegQueryValueEx(hKeyHandle, itemKey, RESERVED_NULL, REG_SZ, _
        ByVal initialValue, keySize)
        'Debug.Print "Result2:" & result
    'Need to trim the key value since it comes back as a mix of Unicode and
    'ANSI:
    initialValue = Trim(Left(initialValue, keySize - 1))
    'Debug.Print "Got from registry: " & initialValue
    Call RegCloseKey(hKeyHandle)
    'If result <> ERROR_SUCCESS Then MsgBox result
    ReadRegistryEntryString = initialValue
End Function

Public Function GetOnlineStatus() As Boolean
'returns whether the system is currently connected to the Internet
'using InternetGetConnectedStateEx
    On Error Resume Next
    Dim connectionName As String
    Dim connectionNameLength As Long
    Dim connected As Long
    Dim connectionFlags As Long
    Dim pointer As Long
    Dim namePointer As Long

    connectionName = Space(256)
    connectionNameLength = 256
    pointer = StrPtr(connectionName)
    namePointer = VarPtr(connectionNameLength)
    
    'non-zero results indicates connected
    connected = InternetGetConnectedStateEx(connectionFlags, ByVal pointer, ByVal connectionNameLength, 0&)
    If connected <> 0 Then
        GetOnlineStatus = True
    Else
        GetOnlineStatus = False
    End If
End Function

Public Function GetIEHomepage() As String
'returns the url for the home page of the user
    On Error Resume Next
    
    'call getsetting to retrieve the URL
    GetIEHomepage = GetSettingString(HKEY_CURRENT_USER, _
            "Software\Microsoft\Internet Explorer\Main", "Start Page")
End Function

Public Function GetSettingString(hKey As Long, _
strPath As String, strValue As String, Optional _
default As String) As String
'Retrieve a setting from the registry
    On Error Resume Next
    Dim hCurKey As Long
    Dim lResult As Long
    Dim lValueType As Long
    Dim strBuffer As String
    Dim lDataBufferSize As Long
    Dim intZeroPos As Integer
    Dim lRegResult As Long
    
    'If no default was sent, then set up a default value
    If Not IsEmpty(default) Then
        GetSettingString = default
    Else
        GetSettingString = ""
    End If
    
    'expand the registry key and query value of the string in that key
    lRegResult = RegOpenKey(hKey, strPath, hCurKey)
    lRegResult = RegQueryValueEx(hCurKey, strValue, 0&, _
    lValueType, ByVal 0&, lDataBufferSize)
    
    'if this query was successful
    If lRegResult = ERROR_SUCCESS Then
        'if the value is in fact a string
        If lValueType = REG_SZ Then
    
            strBuffer = String(lDataBufferSize, " ")
            lResult = RegQueryValueEx(hCurKey, strValue, 0&, 0&, _
            ByVal strBuffer, lDataBufferSize)
    
            intZeroPos = InStr(strBuffer, Chr$(0))
                If intZeroPos > 0 Then 'return results
                    GetSettingString = Left$(strBuffer, intZeroPos - 1)
                Else
                    GetSettingString = strBuffer
                End If
    
        End If
    
    Else 'if the original query was not successful
'        MsgBox gobjLanguageHandler.GetText("A registry access error has occurred."), vbOKOnly, gobjLanguageHandler.GetText("Registry error")
    End If
    
    'finish by closing the expanded key of the registry
    lRegResult = RegCloseKey(hCurKey)
End Function

Public Sub WriteToLogFile(logentry As String, Optional Path As String)
    On Error Resume Next
    Dim fn As Integer
    fn = FreeFile
    
    If Len(Path) = 0 Then
        If Right(App.Path, 1) = "\" Then
            Path = App.Path
        Else
            Path = App.Path & "\"
        End If
        Path = Path & App.EXEName & ".log"
    End If
    Open Path For Append As #fn
    Write #fn, Now & ": " & logentry
    Close #fn
End Sub

Public Sub CreateLogFile(logentry As String, Optional Path As String)
    On Error Resume Next
    Dim fn As Integer
    fn = FreeFile
    If Len(Path) = 0 Then
        Path = App.Path
        If Right(Path, 1) <> "\" Then Path = Path & "\"
        Path = Path & App.EXEName & ".log"
    End If
    Open Path For Output As #fn
    Write #fn, Now & ": " & logentry
    Close #fn
End Sub

Public Function GetNonRoamingApplicationDirectory() As String
'uses the Windows API to get the path for the application directory,
'Application Data
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL_LOCAL_APPDATA, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to My Documents
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetNonRoamingApplicationDirectory = Path
End Function

Public Function GetMyDocuments() As String
'uses the Windows API to get the path for the user's home directory,
'My Documents.
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL_PERSONAL, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to My Documents
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetMyDocuments = Path
End Function

Public Function GetTempDirectory() As String
'uses the Windows API to get the path for the current temp directory
    On Error GoTo localHandler:
    GetTempDirectory = GetNonRoamingApplicationDirectory
    'This is now ....Local Settings\Application Data, but we want
    '....Local Settings\Temp
    'I'm assuming that these aren't localised!
    GetTempDirectory = Replace(GetNonRoamingApplicationDirectory, "Application Data", "Temp")
    Exit Function
localHandler:
    'MsgBox Err.Number & " " & Err.Description & vbNewLine & Err.Source, vbOKOnly, "Error: GetTempDirectory"
    Resume Next
End Function

Public Function GetRoamingApplicationDirectory() As String
'Uses the Windows API to get the path for the user's roaming profile
    On Error Resume Next
    GetRoamingApplicationDirectory = GetSpecialFolderPath(CSIDL_APPDATA)
End Function

Public Function GetCurrentDateAsRFC822() As String
'returns current date in RFC822 specification
    On Error Resume Next
    Dim datetime As String
    
    datetime = WeekdayName(Weekday(Date), True) & ", "
    datetime = datetime & day(Date) & " "
    datetime = datetime & MonthName(Month(Date), True) & " "
    datetime = datetime & Right(year(Date), 2) & " "
    datetime = datetime & DatePart("h", Now) & ":" & DatePart("n", Now)
    
    GetCurrentDateAsRFC822 = datetime
End Function

Public Function BuildNonRoamingApplicationPath(companyName As String, productName As String, version As String) As String
'returns a Windows-compliant non-roaming application path where you can store
'programme data
    On Error Resume Next
    Dim Path As String
    
    Path = GetNonRoamingApplicationDirectory
    Path = Path & "\" & companyName & "\" & productName & "\" & version
    BuildNonRoamingApplicationPath = Path
End Function

Public Function BuildRoamingApplicationPath(companyName As String, productName As String, version As String) As String
'returns a Windows-compliant nroaming application path where you can store
'programme data
    On Error Resume Next
    Dim Path As String
    
    Path = GetRoamingApplicationDirectory
    Path = Path & "\" & companyName & "\" & productName & "\" & version
    BuildRoamingApplicationPath = Path
End Function

Public Sub CreateNonRoamingApplicationPath(companyName As String, productName As String, version As String)
'returns a Windows-compliant non-roaming application path where you can store
'programme data
    On Error Resume Next
    Call CreateApplicationPath(GetSpecialFolderPath(CSIDL_LOCAL_APPDATA), companyName, productName, version)
End Sub

Public Sub CreateRoamingApplicationPath(companyName As String, productName As String, version As String)
    On Error Resume Next
    Call CreateApplicationPath(GetSpecialFolderPath(CSIDL_APPDATA), companyName, productName, version)
End Sub

Private Sub CreateApplicationPath(rootPath As String, companyName As String, productName As String, version As String)
    On Error Resume Next
    Dim Path As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    Path = rootPath & "\" & companyName
    If Not fso.FolderExists(Path) Then
        Call fso.CreateFolder(Path)
    End If
    Path = Path & "\" & productName
    If Not fso.FolderExists(Path) Then
        Call fso.CreateFolder(Path)
    End If
    Path = Path & "\" & version
    If Not fso.FolderExists(Path) Then
        Call fso.CreateFolder(Path)
    End If
End Sub

Public Function GetUserHomeDirectory() As String
    On Error Resume Next
    GetUserHomeDirectory = GetSpecialFolderPath(CSIDL_PERSONAL)
End Function

Public Function GetLocalApplicationDirectory() As String
    On Error Resume Next
    GetLocalApplicationDirectory = GetSpecialFolderPath(CSIDL_LOCAL_APPDATA)
End Function

Public Function GetApplicationDirectory() As String
    On Error Resume Next
    GetApplicationDirectory = GetSpecialFolderPath(CSIDL_APPDATA)
End Function

Public Sub ShutDownWindows()
    On Error Resume Next
    'Shutdown Windows XP
    Call Shell("shutdown -s -f -t 0")
End Sub

Public Function GetUserDirectory() As String
'uses the Windows API to get the path for the user's home directory,
'My Documents.
    On Error Resume Next
    GetUserDirectory = GetSpecialFolderPath(CSIDL_PERSONAL)
End Function

Public Function GetSpecialFolderPath(CSIDL As Long) As String
'returns the special folder indicated by the CSIDL constant
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to special folder
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetSpecialFolderPath = Path
End Function

Public Function GetNumlockState() As Boolean
    On Error Resume Next
    Dim O As OSVERSIONINFO
    Dim keys(0 To 255) As Byte
    
    O.dwOSVersionInfoSize = Len(O)
    Call GetVersionEx(O)
    Call GetKeyboardState(keys(0))
    GetNumlockState = CBool(keys(VK_NUMLOCK))
End Function

Public Sub SetNumlockState(state As Boolean)
'See http://support.microsoft.com/kb/177674/
    On Error Resume Next
    Dim O As OSVERSIONINFO
    Dim NumLockState As Boolean
    Dim keys(0 To 255) As Byte
   
    O.dwOSVersionInfoSize = Len(O)
    Call GetVersionEx(O)
    Call GetKeyboardState(keys(0))
    ' NumLock handling:
    NumLockState = keys(VK_NUMLOCK)
    If NumLockState = state Then
        'already in correct state
    Else
        'need to change
        If O.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS Then  '=== Win95/98
            keys(VK_NUMLOCK) = IIf(state, 1, 0)
            Call SetKeyboardState(keys(0))
        ElseIf O.dwPlatformId = VER_PLATFORM_WIN32_NT Then   '=== WinNT
            'Simulate Key Press
            Call keybd_event(VK_NUMLOCK, &H45, KEYEVENTF_EXTENDEDKEY Or 0, 0)
            'Simulate Key Release
            Call keybd_event(VK_NUMLOCK, &H45, KEYEVENTF_EXTENDEDKEY _
             Or KEYEVENTF_KEYUP, 0)
        End If
    End If
End Sub

Public Sub CreateShortcut(targetFile As String, shortcutFile As String)
'creates a shortcut at shortcutFile to the targetFile
'see http://www.melbpc.org.au/pcupdate/2206/2206article14.htm
    On Error Resume Next
    Dim ws As Object ' WshShell
    Dim newShortcut As Object
    
    Set ws = CreateObject("WScript.Shell", "")   'New WshShell
    Set newShortcut = ws.CreateShortcut(shortcutFile)
    newShortcut.TargetPath = targetFile
    Call newShortcut.save
End Sub

Public Function GetLocaleInformation(locale As Long, query As Long) As String
'returns locale info from GetLocaleInfo: locale should be one of modshared
'modshared.LOCALE_SYSTEM_DEFAULT or modshared.LOCALE_USER_DEFAULT,
'query can be one of modshared.LOCALE_ constants
    On Error Resume Next
    Dim result As String
    Dim resultLength As Long
    
    result = Space(255)
    resultLength = Len(result)
    Call GetLocaleInfo(locale, query, result, resultLength)
    'Debug.Print "r:" & result
    result = Replace(result, Chr(0), Empty)
    GetLocaleInformation = Trim(result)
End Function

Public Function GetSystemFontName() As String
'returns the system font name
'See http://www.freevbcode.com/ShowCode.Asp?ID=208
    On Error Resume Next
    Dim s As String
    Dim i As Byte
    Dim ncm As NONCLIENTMETRICS
    Dim sdfont As StdFont
    
    ncm.cbSize = Len(ncm)
    If SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, ncm, 0) Then
        s = StrConv(ncm.lfCaptionFont.lfFaceName, vbUnicode)
        i = InStr(s, vbNullChar)
        If i > 0 Then s = Left(s, i - 1)
    End If
    GetSystemFontName = s
End Function

Public Function GetSystemFontSize() As Long
'returns the system font size: lets you know if the system is using small
'fonts or not.
'See http://www.developerfusion.co.uk/show/275/
    On Error Resume Next
    Dim hdc, hwnd, PrevMapMode As Long
    Dim tm As TEXTMETRIC

    ' Set the default return value to small fonts
    'gbl_GetFontRes$ = &quot;VGA&quot;

    ' Get the handle of the desktop window
    hwnd = GetDesktopWindow()

    ' Get the device context for the desktop
    hdc = GetWindowDC(hwnd)
    If hdc Then
        ' Set the mapping mode to pixels
        PrevMapMode = SetMapMode(hdc, MM_TEXT)

        ' Get the size of the system font
        Call GetTextMetrics(hdc, tm)

        ' Set the mapping mode back to what it was
        PrevMapMode = SetMapMode(hdc, PrevMapMode)

        ' Release the device context
        Call ReleaseDC(hwnd, hdc)

        ' If the system font is more than 16 pixels high,
        ' then large fonts are being used
        GetSystemFontSize = tm.tmHeight
    End If
End Function

'Launch a url in the system's default web browser (E.g. IE)
Public Function OpenURLInWebBrowser(url As String) As Long
    On Error Resume Next
    OpenURLInWebBrowser = ShellExecute(0&, "open", url, "", "", SW_SHOW)
End Function

'Public Sub ApplyLargeFonts()
''iterates through application applying large fonts to the
''application's forms
'Oh wait, need to write code to detect large fonts! Screen.TwipsPerThing
'doesn't hack it. Doesn't change. Need to use GetDeviceCaps
'    On Error Resume Next
'    Dim controlIterator As Control
'    Dim formIterator As Form
'    Dim largeFonts As Boolean
'    Dim extraLargeFonts As Boolean
'
'    'have we got large fonts?
'    If Screen.TwipsPerPixelY > 14 Then
'        largeFonts = True
'    Else
'    End If
'
'    If largeFonts Then
'        For Each formIterator In Forms
'            For Each controlIterator In formIterator.Controls
'                Select Case TypeName(controlIterator)
'                    Case "ListBox"
'
'                End Select
'            Next controlIterator
'        Next formIterator
'    End If
'End Sub
'

Public Sub OpenControlPanel(cplFilename As String, Optional arguments As String = "")
'see http://www.vbcode.com/Asp/showsn.asp?theID=11982
'Runs the control panel applet specified by cplFilename (e.g. inetcpl.cpl)
'with optional arguments arguments. It's up to the calling code to add any
'commas to arguments, e.g. ", panel=6", since some control panel applets
'may not take them.
    On Error Resume Next
    Dim commandLine As String
    
    commandLine = "Rundll32.exe Shell32.dll,Control_RunDLL " & cplFilename & _
        " " & arguments
    Call Shell(commandLine)
End Sub

Public Sub SetFontToSystemFont()
'iterate through the entire application setting the font to the system default
    On Error Resume Next
    Dim f As Form
    Dim c As Control
    Dim systemFont As String
    Dim systemSize As Long
    
    systemFont = GetSystemFontName
    systemSize = GetSystemFontSize
    For Each f In Forms
        f.FontSize = systemSize
        f.FontName = systemFont
        For Each c In f.Controls
            Select Case TypeName(c)
                Case "CheckBox"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "CommandButton"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "Frame"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "Label"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "OptionButton"
                    c.FontSize = systemSize
                    c.FontName = systemFont
            End Select
        Next c
    Next f
End Sub

Public Function StripTerminator(ByVal strString As String) As String
    On Error Resume Next
'used in processing the results of ini file reads
    Dim intZeroPos As Integer

    intZeroPos = InStr(strString, Chr$(0))
    If intZeroPos > 0 Then
        StripTerminator = Left$(strString, intZeroPos - 1)
    Else
        StripTerminator = strString
    End If
End Function

'-----------------------------------------------------------
' FUNCTION: ReadIniFile
'
' Reads a value from the specified section/key of the
' specified .INI file
'
' IN: [strIniFile] - name of .INI file to read
'     [strSection] - section where key is found
'     [strKey] - name of key to get the value of
'
' Returns: non-zero terminated value of .INI file key
'-----------------------------------------------------------
'
Public Function SharedReadIniFile(ByVal strIniFile As String, ByVal strSECTION As String, ByVal strKey As String) As String
    On Error Resume Next
    Dim strBuffer As String
    Dim intPos As Integer
    Dim emptyS As String

    '
    'If successful read of .INI file, strip any trailing zero returned by the Windows API GetPrivateProfileString
    '
    strBuffer = Space$(256)
    strSECTION = strSECTION & Chr(0)
    strKey = strKey & Chr(0)
    emptyS = "" & Chr(0)
    strIniFile = strIniFile & Chr(0)
    If GetPrivateProfileString(strSECTION, strKey, emptyS, strBuffer, Len(strBuffer) - 1, strIniFile) > 0 Then
        SharedReadIniFile = Left(strBuffer, InStr(strBuffer, Chr(0)) - 1)
'    If GetPrivateProfileString(strSECTION, strKey, gstrNULL, strBuffer, gintMAX_SIZE, strIniFile) > 0 Then
'        ReadIniFile = RTrim$(StripTerminator(strBuffer))
    Else
        SharedReadIniFile = gstrNull
    End If
End Function

Public Function SharedReadIniFileDefault(ByVal strIniFile As String, ByVal strSECTION As String, ByVal strKey As String, default As String) As String
    On Error Resume Next
    Dim strBuffer As String
    Dim intPos As Integer

    '
    'If successful read of .INI file, strip any trailing zero returned by the Windows API GetPrivateProfileString
    '
    strSECTION = strSECTION & Chr(0)
    strKey = strKey & Chr(0)
    strIniFile = strIniFile & Chr(0)
    default = default & Chr(0)
    strBuffer = Space$(256)
    If GetPrivateProfileString(strSECTION, strKey, default, strBuffer, Len(strBuffer) - 1, strIniFile) > 0 Then
        SharedReadIniFileDefault = Left(strBuffer, InStr(strBuffer, Chr(0)) - 1)
'    If GetPrivateProfileString(strSECTION, strKey, gstrNULL, strBuffer, gintMAX_SIZE, strIniFile) > 0 Then
'        ReadIniFile = RTrim$(StripTerminator(strBuffer))
    Else
        SharedReadIniFileDefault = default
    End If
End Function

Public Function WriteIniFile(ByVal strIniFile As String, ByVal section As String, ByVal setting As String, ByVal value As String)
    On Error Resume Next
    strIniFile = strIniFile & Chr(0)
    section = section & Chr(0)
    setting = setting & Chr(0)
    value = value & Chr(0)
    Call WritePrivateProfileString(section, setting, value, strIniFile)
End Function

Public Function ReadFile(ByRef strFile As String) As String
    On Error GoTo exitReadFile:
    Dim intFileNumber As Long
    intFileNumber = FreeFile
    Open strFile For Binary As #intFileNumber
    ReadFile = Space(LOF(intFileNumber))
    Get #intFileNumber, , ReadFile
    Close #intFileNumber
exitReadFile:
 
End Function

Public Function ConvertWindowsToCSSColours(windowsColour As String) As String
    On Error Resume Next
'converts a Windows colour (BGR) to CSS (RGB)
    Dim newColour As String
    Dim hexColour As String
    hexColour = Hex(windowsColour)
    newColour = String(6 - Len(hexColour), "0") & hexColour
    ConvertWindowsToCSSColours = "#" & Right(newColour, 2) & Mid(newColour, 3, 2) & Left(newColour, 2)
End Function

Public Function MakePathSafe(Path As String) As String
'Returns a path with invalid characters removed.
    On Error Resume Next
    Dim suggestedName As String
    suggestedName = Path
    suggestedName = Replace(suggestedName, vbNewLine, "")
    suggestedName = Replace(suggestedName, vbCr, "")
    suggestedName = Replace(suggestedName, vbLf, "")
    suggestedName = Replace(suggestedName, "\", "_")
    suggestedName = Replace(suggestedName, "/", "_")
    suggestedName = Replace(suggestedName, ":", "_")
    suggestedName = Replace(suggestedName, "*", "_")
    suggestedName = Replace(suggestedName, "?", "_")
    suggestedName = Replace(suggestedName, """", "_")
    suggestedName = Replace(suggestedName, "<", "_")
    suggestedName = Replace(suggestedName, ">", "_")
    suggestedName = Replace(suggestedName, "|", "_")
    suggestedName = Trim(suggestedName)
    MakePathSafe = suggestedName
End Function

-->
<pre id="0">
Option Explicit

<font color="green">'Fonts</font>
<font color="green">'See http://www.freevbcode.com/ShowCode.Asp?ID=208</font>
Public Const LF_FACESIZE = 32
Public Const SPI_GETNONCLIENTMETRICS = 41
Public Type LOGFONT
    lfHeight As Long
    lfWidth As Long
    lfEscapement As Long
    lfOrientation As Long
    lfWeight As Long
    lfItalic As Byte
    lfUnderline As Byte
    lfStrikeOut As Byte
    lfCharSet As Byte
    lfOutPrecision As Byte
    lfClipPrecision As Byte
    lfQuality As Byte
    lfPitchAndFamily As Byte
    lfFaceName(1 To LF_FACESIZE) As Byte
End Type
Public Type NONCLIENTMETRICS
    cbSize As Long
    iBorderWidth As Long
    iScrollWidth As Long
    iScrollHeight As Long
    iCaptionWidth As Long
    iCaptionHeight As Long
    lfCaptionFont As LOGFONT
    iSMCaptionWidth As Long
    iSMCaptionHeight As Long
    lfSMCaptionFont As LOGFONT
    iMenuWidth As Long
    iMenuHeight As Long
    lfMenuFont As LOGFONT
    lfStatusFont As LOGFONT
    lfMessageFont As LOGFONT
End Type
Public Declare Function SystemParametersInfo Lib "User32" _
Alias "SystemParametersInfoA" (ByVal uAction As Long, _
ByVal uParam As Long, ByRef lpvParam As Any, _
ByVal fuWinIni As Long) As Long


<font color="green">'Prevents a control from being updated</font>
<font color="green">'Pass it the hWnd for the control to lock, 0 to cancel</font>
<font color="green">'See http://www.vbaccelerator.com/home/VB/Tips/Prevent_A_Window_From_Repainting/article.asp</font>
Public Declare Function LockWindowUpdate Lib "User32" _
    (ByVal hwndLock As Long) As Long

<font color="green">'see http://www.nsftools.com/tips/ShellExec.lss</font>
<font color="green">'** ShellExecute will open a file using the registered file association on the computer.</font>
<font color="green">'** If it returns a value of greater than 32 then the call was successful; otherwise</font>
<font color="green">'** it should return one of the error codes below. The parameters are:</font>
<font color="green">'**     hwnd = an active window handle, or 0</font>
<font color="green">'**     operation = "edit", "explore", "find", "open", or "print"</font>
<font color="green">'**     fileName = a file or directory name</font>
<font color="green">'**     parameters = if fileName is an executable file, the command line parameters</font>
<font color="green">'**                         to pass when launching the application, or "" if no parameters</font>
<font color="green">'**                         are necessary</font>
<font color="green">'**     directory = the default directory to use, or "" if you don't care</font>
<font color="green">'**     displayType = one of the displayType constants listed below</font>
Declare Function ShellExecute Lib "Shell32" Alias "ShellExecuteA" _
(ByVal hwnd As Long, ByVal operation As String, ByVal filename As String, _
ByVal parameters As String, ByVal directory As String, ByVal displayType As Long) As Long

<font color="green">'** FindExecutable will determine the executable file that is set up to open a particular</font>
<font color="green">'** file based on the file associations on this computer. If it returns a value of greater than</font>
<font color="green">'** 32 then the call was successful; otherwise it should return one of the error codes</font>
<font color="green">'** below. The parameters are:</font>
<font color="green">'**     fileName = the full path to the file you are trying to find the association for</font>
<font color="green">'**     directory = the default directory to use, or "" if you don't care</font>
<font color="green">'**     retAssociation = the associated executable will be returned as this parameter,</font>
<font color="green">'**                         with a maximum string length of 255 characters (you will want</font>
<font color="green">'**                         to pass a String that's 256 characters long and trim the</font>
<font color="green">'**                         null-terminated result)</font>
Declare Function FindExecutable Lib "Shell32" Alias "FindExecutableA" _
(ByVal filename As String, ByVal directory As String, ByVal retAssociation As String) As Long

<font color="green">'** constants for the displayType parameter</font>
Public Const SW_HIDE = 0
Public Const SW_SHOWNORMAL = 1
Public Const SW_NORMAL = 1
Public Const SW_SHOWMINIMIZED = 2
Public Const SW_SHOWMAXIMIZED = 3
Public Const SW_MAXIMIZE = 3
Public Const SW_SHOWNOACTIVATE = 4
Public Const SW_SHOW = 5
Public Const SW_MINIMIZE = 6
Public Const SW_SHOWMINNOACTIVE = 7
Public Const SW_SHOWNA = 8
Public Const SW_RESTORE = 9
Public Const SW_SHOWDEFAULT = 10
Public Const SW_MAX = 10
<font color="green">'** possible errors returned by ShellExecute</font>
Const ERROR_OUT_OF_MEMORY = 0       'The operating system is out of memory or resources.
Const ERROR_FILE_NOT_FOUND = 2      'The specified file was not found.
Const ERROR_PATH_NOT_FOUND = 3  'The specified path was not found.
Const ERROR_BAD_FORMAT = 11         'The .exe file is invalid (non-Microsoft Win32 .exe or error in .exe image).
Const SE_ERR_FNF = 2                            'The specified file was not found.
Const SE_ERR_PNF = 3                        'The specified path was not found.
Const SE_ERR_ACCESSDENIED = 5       'The operating system denied access to the specified file.
Const SE_ERR_OOM = 8                        'There was not enough memory to complete the operation.
Const SE_ERR_SHARE = 26                 'A sharing violation occurred.
Const SE_ERR_ASSOCINCOMPLETE = 27   'The file name association is incomplete or invalid.
Const SE_ERR_DDETIMEOUT = 28            'The DDE transaction could not be completed because the request timed out.
Const SE_ERR_DDEFAIL = 29               'The DDE transaction failed.
Const SE_ERR_DDEBUSY = 30               'The Dynamic Data Exchange (DDE) transaction could not be completed because other DDE transactions were being processed.
Const SE_ERR_NOASSOC = 31               'There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.
Const SE_ERR_DLLNOTFOUND = 32       'The specified dynamic-link library (DLL) was not found.

<font color="green">'CONSTANTS</font>
Public Const HKEY_CLASSES_ROOT = &H80000000
Public Const HKEY_CURRENT_USER = &H80000001
Public Const HKEY_LOCAL_MACHINE = &H80000002
Public Const HKEY_USERS = &H80000003
Public Const HKEY_CURRENT_CONFIG = &H80000005
Public Const HKEY_DYN_DATA = &H80000006
Public Const REG_SZ = 1 'Unicode nul terminated string
Public Const REG_BINARY = 3 'Free form binary
Public Const REG_DWORD = 4 '32-bit number
Public Const ERROR_SUCCESS = 0&
Public Const RESERVED_NULL = 0
Public Const INTERNET_CONNECTION_MODEM As Long = &H1
Public Const MIIM_SUBMENU As Long = &H4
Public Const APINULL = 0&
Public Const EM_SCROLLCARET = &HB7
Public Const EM_LINEINDEX = &HBB
Public Const EM_GETLINECOUNT = &HBA
Public Const EM_LINELENGTH = &HC1
Public Const EM_GETFIRSTVISIBLELINE = &HCE
Public Const EM_LINEFROMCHAR = &HC9
Public Const EM_GETLINE = &HC4
Public Const EM_LINESCROLL = &HB6
Public Const EM_SETSEL = &HB1
Public Const KEY_READ = &H20019                    '-- Permission for general read access.
Public Const KEY_QUERY_VALUE = &H1
Public Const MF_MENUBREAK As Long = &H40&  'indicates a vertical break
Public Const MIIM_STATE As Long = &H1
Public Const MIIM_ID As Long = &H2
Public Const MIIM_CHECKMARKS As Long = &H8
Public Const MIIM_TYPE As Long = &H10
Public Const MIIM_DATA As Long = &H20
Public Const MIIM_STRING As Long = &H40
Public Const MIIM_BITMAP As Long = &H80
Public Const MIIM_FTYPE As Long = &H100
Public Const FBYPOSITION_POSITION As Boolean = True
Public Const FBYPOSTION_IDENTIFIER As Boolean = False
Public Const MF_STRING As Long = &H0&
Public Const GWL_WNDPROC As Long = (-4)
Public Const WM_COMMAND = &H111 ' indicates that a command has been intercepted by the app
Public Const MF_BYPOSITION = &H400& ' indicates a menu item by position, not by name, for RemoveMenu
Public Const MF_DISABLED = &H2& ' used in setting menu items (InsertMenuItem etc) to indicate that an item is greyed
Public Const MF_GRAYED = &H1& ' allegedly does the same thing as MF_DISABLED
<font color="green">'The maximum length, it is assumed, in characters, of one line of text in the browser</font>
Public Const MAX_LINE_LENGTH As Integer = 255

Public Const SND_FILENAME = &H20000 ' Name is a file name
Public Const SND_NODEFAULT = &H2  ' silence not default, if sound not found
Public Const SND_ASYNC = &H1 ' play asynchronously ie return to main thread while playing

<font color="green">'keybd_event</font>
<font color="green">'http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/keybd_event.asp?frame=true</font>
Public Declare Sub keybd_event Lib "User32" _
         (ByVal bVk As Byte, _
          ByVal bScan As Byte, _
          ByVal dwflags As Long, ByVal dwExtraInfo As Long)
Public Const VK_CAPITAL = &H14
Public Const VK_MENU = &H14
Public Const VK_NUMLOCK = &H90
Public Const KEYEVENTF_EXTENDEDKEY = &H1
Public Const KEYEVENTF_KEYUP = &H2
Public Const VER_PLATFORM_WIN32_NT = 2
Public Const VER_PLATFORM_WIN32_WINDOWS = 1

Dim gstrNull As Variant

<font color="green">'NumLock</font>
<font color="green">'From http://support.microsoft.com/kb/177674/</font>
Public Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128   '  Maintenance string for PSS usage
End Type
Public Declare Function GetVersionEx Lib "kernel32" _
         Alias "GetVersionExA" _
         (lpVersionInformation As OSVERSIONINFO) As Long
Public Declare Function GetKeyboardState Lib "User32" _
         (pbKeyState As Byte) As Long
Public Declare Function SetKeyboardState Lib "User32" _
         (lppbKeyState As Byte) As Long

Public Declare Function GetPrivateProfileInt Lib "kernel32" Alias "GetPrivateProfileIntA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal nDefault As Long, ByVal lpFileName As String) As Long
Public Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Public Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpSectionName As String, ByVal lpKeyName As Any, ByVal lpString As Any, ByVal lpFileName As String) As Long


<font color="green">'See http://www.codenewsgroups.net/group/microsoft.public.vb.general.discussion/topic2255.aspx</font>
Public Declare Function GetSystemDefaultLCID Lib "kernel32" () As Long
Public Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String, ByVal cchData As Long) As Long
Public Declare Function SetLocaleInfo Lib "kernel32" Alias "SetLocaleInfoA" (ByVal locale As Long, ByVal LCType As Long, ByVal lpLCData As String) As Long
Public Const LOCALE_USER_DEFAULT = &H400
Public Const LOCALE_SYSTEM_DEFAULT = &H800
Public Const LOCALE_ILANGUAGE             As Long = &H1     'language id
Public Const LOCALE_SLANGUAGE             As Long = &H2     'localized name of language
Public Const LOCALE_SENGLANGUAGE          As Long = &H1001  'English name of language
Public Const LOCALE_SABBREVLANGNAME       As Long = &H3     'abbreviated language name
Public Const LOCALE_SNATIVELANGNAME       As Long = &H4     'native name of language

Public Const LOCALE_ICOUNTRY              As Long = &H5     'country code
Public Const LOCALE_SCOUNTRY              As Long = &H6     'localized name of country
Public Const LOCALE_SENGCOUNTRY           As Long = &H1002  'English name of country
Public Const LOCALE_SABBREVCTRYNAME       As Long = &H7     'abbreviated country name
Public Const LOCALE_SNATIVECTRYNAME       As Long = &H8     'native name of country

Public Const LOCALE_IDEFAULTLANGUAGE      As Long = &H9     'default language id
Public Const LOCALE_IDEFAULTCOUNTRY       As Long = &HA     'default country code
Public Const LOCALE_IDEFAULTCODEPAGE      As Long = &HB     'default oem code page
Public Const LOCALE_IDEFAULTANSICODEPAGE  As Long = &H1004  'default ansi code page
Public Const LOCALE_IDEFAULTMACCODEPAGE   As Long = &H1011  'default mac code page

Public Const LOCALE_SLIST                 As Long = &HC     'list item separator
Public Const LOCALE_IMEASURE              As Long = &HD     '0 = metric, 1 = US

Public Const LOCALE_SDECIMAL              As Long = &HE     'decimal separator
Public Const LOCALE_STHOUSAND             As Long = &HF     'thousand separator
Public Const LOCALE_SGROUPING             As Long = &H10    'digit grouping
Public Const LOCALE_IDIGITS               As Long = &H11    'number of fractional digits
Public Const LOCALE_ILZERO                As Long = &H12    'leading zeros for decimal
Public Const LOCALE_INEGNUMBER            As Long = &H1010  'negative number mode
Public Const LOCALE_SNATIVEDIGITS         As Long = &H13    'native ascii 0-9

Public Const LOCALE_SCURRENCY             As Long = &H14    'local monetary symbol
Public Const LOCALE_SINTLSYMBOL           As Long = &H15    'intl monetary symbol
Public Const LOCALE_SMONDECIMALSEP        As Long = &H16    'monetary decimal separator
Public Const LOCALE_SMONTHOUSANDSEP       As Long = &H17    'monetary thousand separator
Public Const LOCALE_SMONGROUPING          As Long = &H18    'monetary grouping
Public Const LOCALE_ICURRDIGITS           As Long = &H19    '# local monetary digits
Public Const LOCALE_IINTLCURRDIGITS       As Long = &H1A    '# intl monetary digits
Public Const LOCALE_ICURRENCY             As Long = &H1B    'positive currency mode
Public Const LOCALE_INEGCURR              As Long = &H1C    'negative currency mode

Public Const LOCALE_SDATE                 As Long = &H1D    'date separator
Public Const LOCALE_STIME                 As Long = &H1E    'time separator
Public Const LOCALE_SSHORTDATE            As Long = &H1F    'short date format string
Public Const LOCALE_SLONGDATE             As Long = &H20    'long date format string
Public Const LOCALE_STIMEFORMAT           As Long = &H1003  'time format string
Public Const LOCALE_IDATE                 As Long = &H21    'short date format ordering
Public Const LOCALE_ILDATE                As Long = &H22    'long date format ordering
Public Const LOCALE_ITIME                 As Long = &H23    'time format specifier
Public Const LOCALE_ITIMEMARKPOSN         As Long = &H1005  'time marker position
Public Const LOCALE_ICENTURY              As Long = &H24    'century format specifier (short date)
Public Const LOCALE_ITLZERO               As Long = &H25    'leading zeros in time field
Public Const LOCALE_IDAYLZERO             As Long = &H26    'leading zeros in day field (short date)
Public Const LOCALE_IMONLZERO             As Long = &H27    'leading zeros in month field (short date)
Public Const LOCALE_S1159                 As Long = &H28    'AM designator
Public Const LOCALE_S2359                 As Long = &H29    'PM designator

Public Const LOCALE_ICALENDARTYPE         As Long = &H1009  'type of calendar specifier
Public Const LOCALE_IOPTIONALCALENDAR     As Long = &H100B  'additional calendar types specifier
Public Const LOCALE_IFIRSTDAYOFWEEK       As Long = &H100C  'first day of week specifier
Public Const LOCALE_IFIRSTWEEKOFYEAR      As Long = &H100D  'first week of year specifier

Public Const LOCALE_SDAYNAME1             As Long = &H2A    'long name for Monday
Public Const LOCALE_SDAYNAME2             As Long = &H2B    'long name for Tuesday
Public Const LOCALE_SDAYNAME3             As Long = &H2C    'long name for Wednesday
Public Const LOCALE_SDAYNAME4             As Long = &H2D    'long name for Thursday
Public Const LOCALE_SDAYNAME5             As Long = &H2E    'long name for Friday
Public Const LOCALE_SDAYNAME6             As Long = &H2F    'long name for Saturday
Public Const LOCALE_SDAYNAME7             As Long = &H30    'long name for Sunday
Public Const LOCALE_SABBREVDAYNAME1       As Long = &H31    'abbreviated name for Monday
Public Const LOCALE_SABBREVDAYNAME2       As Long = &H32    'abbreviated name for Tuesday
Public Const LOCALE_SABBREVDAYNAME3       As Long = &H33    'abbreviated name for Wednesday
Public Const LOCALE_SABBREVDAYNAME4       As Long = &H34    'abbreviated name for Thursday
Public Const LOCALE_SABBREVDAYNAME5       As Long = &H35    'abbreviated name for Friday
Public Const LOCALE_SABBREVDAYNAME6       As Long = &H36    'abbreviated name for Saturday
Public Const LOCALE_SABBREVDAYNAME7       As Long = &H37    'abbreviated name for Sunday
Public Const LOCALE_SMONTHNAME1           As Long = &H38    'long name for January
Public Const LOCALE_SMONTHNAME2           As Long = &H39    'long name for February
Public Const LOCALE_SMONTHNAME3           As Long = &H3A    'long name for March
Public Const LOCALE_SMONTHNAME4           As Long = &H3B    'long name for April
Public Const LOCALE_SMONTHNAME5           As Long = &H3C    'long name for May
Public Const LOCALE_SMONTHNAME6           As Long = &H3D    'long name for June
Public Const LOCALE_SMONTHNAME7           As Long = &H3E    'long name for July
Public Const LOCALE_SMONTHNAME8           As Long = &H3F    'long name for August
Public Const LOCALE_SMONTHNAME9           As Long = &H40    'long name for September
Public Const LOCALE_SMONTHNAME10          As Long = &H41    'long name for October
Public Const LOCALE_SMONTHNAME11          As Long = &H42    'long name for November
Public Const LOCALE_SMONTHNAME12          As Long = &H43    'long name for December
Public Const LOCALE_SMONTHNAME13          As Long = &H100E  'long name for 13th month (if exists)
Public Const LOCALE_SABBREVMONTHNAME1     As Long = &H44    'abbreviated name for January
Public Const LOCALE_SABBREVMONTHNAME2     As Long = &H45    'abbreviated name for February
Public Const LOCALE_SABBREVMONTHNAME3     As Long = &H46    'abbreviated name for March
Public Const LOCALE_SABBREVMONTHNAME4     As Long = &H47    'abbreviated name for April
Public Const LOCALE_SABBREVMONTHNAME5     As Long = &H48    'abbreviated name for May
Public Const LOCALE_SABBREVMONTHNAME6     As Long = &H49    'abbreviated name for June
Public Const LOCALE_SABBREVMONTHNAME7     As Long = &H4A    'abbreviated name for July
Public Const LOCALE_SABBREVMONTHNAME8     As Long = &H4B    'abbreviated name for August
Public Const LOCALE_SABBREVMONTHNAME9     As Long = &H4C    'abbreviated name for September
Public Const LOCALE_SABBREVMONTHNAME10    As Long = &H4D    'abbreviated name for October
Public Const LOCALE_SABBREVMONTHNAME11    As Long = &H4E    'abbreviated name for November
Public Const LOCALE_SABBREVMONTHNAME12    As Long = &H4F    'abbreviated name for December
Public Const LOCALE_SABBREVMONTHNAME13    As Long = &H100F  'abbreviated name for 13th month (if exists)

Public Const LOCALE_SPOSITIVESIGN         As Long = &H50    'positive sign
Public Const LOCALE_SNEGATIVESIGN         As Long = &H51    'negative sign
Public Const LOCALE_IPOSSIGNPOSN          As Long = &H52    'positive sign position
Public Const LOCALE_INEGSIGNPOSN          As Long = &H53    'negative sign position
Public Const LOCALE_IPOSSYMPRECEDES       As Long = &H54    'mon sym precedes pos amt
Public Const LOCALE_IPOSSEPBYSPACE        As Long = &H55    'mon sym sep by space from pos amt
Public Const LOCALE_INEGSYMPRECEDES       As Long = &H56    'mon sym precedes neg amt
Public Const LOCALE_INEGSEPBYSPACE        As Long = &H57    'mon sym sep by space from neg amt

Public Const LOCALE_FONTSIGNATURE         As Long = &H58    'font signature
Public Const LOCALE_SISO639LANGNAME       As Long = &H59    'ISO abbreviated language name
Public Const LOCALE_SISO3166CTRYNAME      As Long = &H5A    'ISO abbreviated country name

Public Const LOCALE_IDEFAULTEBCDICCODEPAGE As Long = &H1012 'default ebcdic code page
Public Const LOCALE_IPAPERSIZE            As Long = &H100A  '0 = letter, 1 = a4, 2 = legal, 3 = a3
Public Const LOCALE_SENGCURRNAME          As Long = &H1007  'english name of currency
Public Const LOCALE_SNATIVECURRNAME       As Long = &H1008  'native name of currency
Public Const LOCALE_SYEARMONTH            As Long = &H1006  'year month format string
Public Const LOCALE_SSORTNAME             As Long = &H1013  'sort name
Public Const LOCALE_IDIGITSUBSTITUTION    As Long = &H1014  '0 = none, 1 = context, 2 = native digit

<font color="green">'SHGetPathFromIDList</font>
<font color="green">'Returns the path (string) from the folder ID obtained by SHGetSpecialFolderLocation</font>
Public Declare Function SHGetPathFromIDList Lib "Shell32" Alias "SHGetPathFromIDListA" (ByVal Pidl As Long, ByVal pszPath As String) As Long

Public Const GAP As Long = 90 'the twip distance for spacing UI elements

<font color="green">'SHGetSpecialFolderLocation</font>
<font color="green">'Returns the Folder ID of the user's My Documents folder (or another folder indicated</font>
<font color="green">'by CSIDL)</font>
Public Declare Function SHGetSpecialFolderLocation Lib "Shell32" (ByVal hwnd As Long, ByVal nFolder As Long, ppidl As Long) As Long
<font color="green">' constants for Shell.NameSpace method -- these are the "special folders"</font>
<font color="green">'contained in the Windows shell</font>
Public Const CSIDL_DESKTOP = &H0 ' Desktop
Public Const CSIDL_INTERNET = &H1 ' The internet
Public Const CSIDL_PROGRAMS = &H2 ' Shortcuts in the Programs menu
Public Const CSIDL_CONTROLS = &H3 ' Control Panel
Public Const CSIDL_PRINTERS = &H4 ' Printers
Public Const CSIDL_PERSONAL = &H5 ' Shortcuts to Personal files
Public Const CSIDL_FAVORITES = &H6 ' Shortcuts to favorite folders
Public Const CSIDL_STARTUP = &H7 ' Shortcuts to apps that start at boot Time
Public Const CSIDL_RECENT = &H8 ' Shortcuts to recently used docs
Public Const CSIDL_SENDTO = &H9 ' Shortcuts for the SendTo menu
Public Const CSIDL_BITBUCKET = &HA ' Recycle Bin
Public Const CSIDL_STARTMENU = &HB ' User-defined items in Start Menu
Public Const CSIDL_DESKTOPDIRECTORY = &H10 ' Directory with all the desktop shortcuts
Public Const CSIDL_DRIVES = &H11 ' My Computer
Public Const CSIDL_NETWORK = &H12 ' Network Neighborhood virtual folder
Public Const CSIDL_NETHOOD = &H13 ' Directory containing objects in the network neighborhood
Public Const CSIDL_FONTS = &H14 ' Installed fonts
Public Const CSIDL_TEMPLATES = &H15 ' Shortcuts to document templates
Public Const CSIDL_COMMON_STARTMENU = &H16 ' Directory with items in the Start menu for all users
Public Const CSIDL_COMMON_PROGRAMS = &H17 ' Directory with items in the Programs menu for all users
Public Const CSIDL_COMMON_STARTUP = &H18 ' Directory with items in the StartUp submenu for all users
Public Const CSIDL_COMMON_DESKTOPDIRECTORY = &H19 ' Directory with items on the desktop of all users
Public Const CSIDL_APPDATA = &H1A ' Folder for application-specific data
Public Const CSIDL_PRINTHOOD = &H1B ' Directory with references to printer links
Public Const CSIDL_LOCAL_APPDATA = &H1C          '{user name}\Local Settings\Application Data (non roaming)
Public Const CSIDL_ALTSTARTUP = &H1D ' (DBCS) Directory corresponding to user 's nonlocalized Startup program group
Public Const CSIDL_COMMON_ALTSTARTUP = &H1E ' (DBCS) Directory with Startup items for all users
Public Const CSIDL_COMMON_FAVORITES = &H1F ' Directory with all user's favorit items
Public Const CSIDL_INTERNET_CACHE = &H20 ' Directory for temporary internet Files
Public Const CSIDL_COOKIES = &H21 ' Directory for Internet cookies
Public Const CSIDL_HISTORY = &H22 ' Directory for Internet history items
Public Const CSIDL_COMMON_APPDATA = &H23          'All Users\Application Data
Public Const CSIDL_WINDOWS = &H24                 'GetWindowsDirectory()
Public Const CSIDL_SYSTEM = &H25                  'GetSystemDirectory()
Public Const CSIDL_PROGRAM_FILES = &H26           'C:\Program Files
Public Const CSIDL_MYPICTURES = &H27                 'C:\Program Files\My Pictures
Public Const CSIDL_PROFILE = &H28                 'USERPROFILE
Public Const CSIDL_SYSTEMX86 = &H29               'x86 system directory on RISC
Public Const CSIDL_PROGRAM_FILESX86 = &H2A        'x86 C:\Program Files on RISC
Public Const CSIDL_PROGRAM_FILES_COMMON = &H2B    'C:\Program Files\Common
Public Const CSIDL_PROGRAM_FILES_COMMONX86 = &H2C 'x86 Program Files\Common on RISC
Public Const CSIDL_COMMON_TEMPLATES = &H2D        'All Users\Templates
Public Const CSIDL_COMMON_DOCUMENTS = &H2E        'All Users\Documents
Public Const CSIDL_COMMON_ADMINTOOLS = &H2F       'All Users\Start Menu\Programs\Administrative Tools
Public Const CSIDL_ADMINTOOLS = &H30              '{user name}\Start Menu\Programs\Administrative Tools

Public Const CSIDL_FLAG_CREATE = &H8000           'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_DONT_VERIFY = &H4000      'combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()
Public Const CSIDL_FLAG_MASK = &HFF00             'mask for all possible flag values

<font color="green">'Shut down Windows XP: doesn't work.</font>
Public Declare Function ExitWindowsEx Lib "User32" _
(ByVal uFlags As Long, ByVal dwReserved As Long) As Long
Public Const EWX_LOGOFF = 0
Public Const EWX_SHUTDOWN = 1
Public Const EWX_REBOOT = 2
Public Const EWX_FORCE = 4

<font color="green">'Large font support: see http://www.developerfusion.co.uk/show/275/</font>
Public Type TEXTMETRIC
  tmHeight As Integer
  tmAscent As Integer
  tmDescent As Integer
  tmInternalLeading As Integer
  tmExternalLeading As Integer
  tmAveCharWidth As Integer
  tmMaxCharWidth As Integer
  tmWeight As Integer
  tmItalic As String * 1
  tmUnderlined As String * 1
  tmStruckOut As String * 1
  tmFirstChar As String * 1
  tmLastChar As String * 1
  tmDefaultChar As String * 1
  tmBreakChar As String * 1
  tmPitchAndFamily As String * 1
  tmCharSet As String * 1
  tmOverhang As Integer
  tmDigitizedAspectX As Integer
  tmDigitizedAspectY As Integer
End Type
<font color="green">'Large font support</font>
Public Declare Function GetTextMetrics Lib "gdi32" Alias "GetTextMetricsA" _
 (ByVal hdc As Long, lpMetrics As TEXTMETRIC) As Long
Public Declare Function GetDesktopWindow Lib "User32" () As Long
Public Declare Function GetWindowDC Lib "User32" (ByVal hwnd As Long) As Long
Public Declare Function ReleaseDC Lib "User32" (ByVal hwnd As Long, ByVal hdc _
 As Long) As Long
Public Declare Function SetMapMode Lib "gdi32" (ByVal hdc As Long, ByVal _
nMapMode As Long) As Long

<font color="green">'** CONSTANTS **</font>
Public Const MM_TEXT = 1


<font color="green">'TYPES</font>
Public Type DllVersionInfo
   cbSize As Long
   dwMajorVersion As Long
   dwMinorVersion As Long
   dwBuildNumber As Long
   dwPlatformId As Long
End Type

Public Type MENUITEMINFO
    cbSize As Long
    fMask As Long
    fType As Long
    fState As Long
    wID As Long
    hSubMenu As Long
    hbmpChecked As Long
    hbmpUnchecked As Long
    dwItemData As Long
    dwTypeData As String
    cch As Long
End Type


<font color="green">'METHODS</font>

<font color="green">'URLDownloadToFile</font>
<font color="green">'Downloads a specified url to a local file</font>
Public Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long

<font color="green">'For removing a menu item</font>
Public Declare Function DeleteMenu Lib "User32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

<font color="green">'For finding the system time - used for timing</font>
Public Declare Function GetTickCount Lib "kernel32" () As Long
Public Declare Function TimeGetTime Lib "winmm.dll" () As Long

<font color="green">'For finding IE version</font>
Public Declare Function DllGetVersion Lib "Shlwapi.dll" (dwVersion As DllVersionInfo) As Long
    'for finding IE version
    
<font color="green">'For changing to IE homepage</font>
Public Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Public Declare Function RegCreateKey Lib "advapi32.dll" Alias "RegCreateKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long

Public Declare Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" (ByVal hKey As Long, ByVal lpSubKey As String) As Long

Public Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long

Public Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, lpData As Any, lpcbData As Long) As Long

Public Declare Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal reserved As Long, ByVal dwType As Long, lpData As Any, ByVal cbData As Long) As Long

Public Declare Function InternetGetConnectedStateEx Lib "wininet.dll" Alias "InternetGetConnectedStateExA" (lpdwFlags As Long, lpszConnectionName As Long, dwNameLen As Long, ByVal dwReserved As Long) As Long

<font color="green">'This is declaring a Function called</font>
<font color="green">'"PlaySound" and we tell VB that it's located in the</font>
<font color="green">'Library called "winmm.dll". The word 'Alias' means that "PlaySound"</font>
<font color="green">'is actually stored in the DLL as "PlaysoundA", and written in C++ but</font>
<font color="green">'we can use the function in VB as "PlaySound".</font>
<font color="green">'lpszname = file path, hmodule = 0 and dwflags = (Synchonous = 0/Asynchronously = 1)</font>
Public Declare Function PlaySound Lib "winmm.dll" Alias "PlaySoundA" (ByVal lpszName As String, ByVal hModule As Long, ByVal dwflags As Long) As Long
<font color="green">'returns a long, but 0 = successful play</font>

Public Declare Function RasEnumConnections Lib "RasApi32.DLL" Alias "RasEnumConnectionsA" (lprasconn As Any, lpcb As Long, lpcConnections As Long) As Long

Public Declare Function RasHangUp Lib "RasApi32.DLL" Alias "RasHangUpA" (ByVal hRasConn As Long) As Long

Public Declare Function SendMessage Lib "User32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function SendMessageW Lib "User32" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Public Declare Function FolderRegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long
    ' Note that if you declare the lpData parameter as String, you must pass it
    ' By Value.

Public Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
    'must be called before FolderRegQueryEx

<font color="green">'for constructing the Favorites menu</font>
Public Declare Function GetMenu Lib "User32" (ByVal hwnd As Long) As Long

Public Declare Function GetSubMenu Lib "User32" (ByVal hMenu As Long, ByVal nPos As Long) As Long

<font color="green">'for processing the menu favorites</font>
Public Declare Function SetWindowLong Lib "User32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Public Declare Function CallWindowProc Lib "user32.dll" Alias "CallWindowProcA" (ByVal lpPrevWndFunc As Long, ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long

Public Declare Function InsertMenuItem Lib "User32" Alias "InsertMenuItemA" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Boolean, ByRef lpcMenuItemInfo As MENUITEMINFO) As Long
    
Public Declare Function SetMenuItemInfo Lib "User32" Alias "SetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal bool As Boolean, lpcMenuItemInfo As MENUITEMINFO) As Long

Public Declare Function GetMenuItemInfo Lib "User32" Alias "GetMenuItemInfoA" (ByVal hMenu As Long, ByVal un As Long, ByVal b As Long, lpMenuItemInfo As MENUITEMINFO) As Long

Public Declare Function RemoveMenu Lib "User32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

Public Declare Function CreateMenu Lib "User32" () As Long

Public Declare Function CreatePopupMenu Lib "User32" () As Long

Public Declare Function DrawMenuBar Lib "User32" (ByVal hwnd As Long) As Long

Public Declare Function GetModuleHandle Lib "kernel32" Alias "GetModuleHandleA" (ByVal lpModuleName As String) As Long

<font color="green">'Public Declare Function GetProcAddress Lib "kernel32" (ByVal hModule As Long, ByVal lpProcName As String) As Long</font>

<font color="green">'for getting the locale ID for the current machine/user</font>
Public Declare Function GetUserDefaultLCID Lib "kernel32" () As Long

<font color="green">'Used to determine the (window handle of) the current active window in Windows.</font>
Public Declare Function GetForegroundWindow Lib "User32" () As Long

<font color="green">''''FindMimeFromData</font>
<font color="green">''''obtains the mimetype of the resource given in pwzUrl in combination with</font>
<font color="green">''''pwzMimeProposed.</font>
<font color="green">''''See http://msdn.microsoft.com/workshop/networking/moniker/overview/appendix_a.asp</font>
<font color="green">''''And http://msdn.microsoft.com/workshop/networking/moniker/reference/functions/findmimefromdata.asp</font>
<font color="green">'''Private Declare Function FindMimeFromData Lib "urlmon.dll" ( _</font>
<font color="green">'''            ByVal pbc As Long, _</font>
<font color="green">'''            ByVal pwzUrl As String, _</font>
<font color="green">'''            pBuffer As Any, _</font>
<font color="green">'''            ByVal cbSize As Long, _</font>
<font color="green">'''            ByVal pwzMimeProposed As String, _</font>
<font color="green">'''            ByVal dwMimeFlags As Long, _</font>
<font color="green">'''            ByVal ppwzMimeOut As String, _</font>
<font color="green">'''            ByVal dwReserved As Long) As Long</font>
<font color="green">'''</font>
<font color="green">''''Guess what mime type target url is. Doesn't require any data or content-type</font>
<font color="green">''''from server, so based entirely on last three characters pretty much!</font>
<font color="green">'''Public Function FindMimeFromUrl(url As Variant, Optional mimetype As String) As String</font>
<font color="green">'DEV: Can't get this to work at all. Returns random garbage. August 2005.</font>
<font color="green">'''    Dim result As Long</font>
<font color="green">'''    Dim mimetypeGot As String * 100</font>
<font color="green">'''    Dim urlString As String</font>
<font color="green">'''</font>
<font color="green">'''    urlString = url</font>
<font color="green">'''    mimetypeGot = String(100, " ") '& Chr(0)</font>
<font color="green">'''    result = FindMimeFromData(0, urlString, 0, 0, "", 0, mimetypeGot, 0)</font>
<font color="green">'''    Debug.Print "FMFU: " & result</font>
<font color="green">'''    Debug.Print mimetypeGot</font>
<font color="green">'''End Function</font>


<b>Public Sub Scroll(ByRef editControl As Control, lines As Long)</b>
<font color="green">'scrolls the editControl textbox by lines lines</font>
<font color="green">' editControl - the current control</font>
<font color="green">' lines - the number of lines to scroll</font>
    On Error Resume Next
    Call SendMessageW(editControl.hwnd, EM_LINESCROLL, 0, lines)
<b>End Sub</b>

<b>Public Sub ScrollToCursor(ByRef editControl As Control)</b>
<font color="green">'scrolls the editControl textbox to where the cursor is now</font>
<font color="green">' editControl - the current control</font>
    On Error Resume Next
    Call SendMessageW(editControl.hwnd, EM_SCROLLCARET, 0, 0)
<b>End Sub</b>

<b>Public Function GetCurrentLine(ByRef editControl As Control) As String</b>
<font color="green">'returns the text on the current line from the current control</font>
<font color="green">'   editControl - the current control</font>
<font color="green">'   charPos - the position of the cursor in the control</font>
    On Error Resume Next
    Dim gotLine As String ' the line we get back
    Dim lineNumber As Long ' the line number of the current line
    'get the line number: arguments of -1 mean "line with caret", 0 is not used
    lineNumber = SendMessage(editControl.hwnd, EM_LINEFROMCHAR, -1, 0)
    'now get this line and return it
    gotLine = Space(MAX_LINE_LENGTH)
    'first two words have to be a Long, size of String
    gotLine = Chr$(MAX_LINE_LENGTH Mod 256) + Chr$(MAX_LINE_LENGTH / 256) & gotLine
    Call SendMessage(editControl.hwnd, EM_GETLINE, lineNumber, ByVal gotLine)
    GetCurrentLine = gotLine
End Function

<b>Public Function GetCurrentLineIndex(ByRef editControl As Control) As Long</b>
<font color="green">'returns the number of the current line indicated by the cursor</font>
    On Error Resume Next
    'get the line number: arguments of -1 mean "line with caret", 0 is not used
    GetCurrentLineIndex = SendMessage(editControl.hwnd, EM_LINEFROMCHAR, -1, 0)
End Function

<b>Public Function GetNumberedLine(ByRef editControl As Control, lineNumber As Long) As String</b>
<font color="green">'returns the numbered line</font>
    On Error Resume Next
    Dim gotLine As String ' the line we get back
    'now get this line and return it
    gotLine = Space(MAX_LINE_LENGTH)
    'first two words have to be a Long, size of String
    gotLine = Chr$(MAX_LINE_LENGTH Mod 256) + Chr$(MAX_LINE_LENGTH / 256) & gotLine
    Call SendMessage(editControl.hwnd, EM_GETLINE, lineNumber, ByVal gotLine)
    GetNumberedLine = gotLine
End Function

<b>Public Function GetNumberOfLines(ByRef editControl) As Long</b>
<font color="green">'returns the number of lines in the control</font>
    On Error Resume Next
    GetNumberOfLines = SendMessage(editControl.hwnd, EM_GETLINECOUNT, 0, 0)
End Function

<b>Public Function GetCharacterIndexOfLine(ByRef editControl, lineNumber As Long) As Long</b>
<font color="green">'returns the number of characters in the control up to the numbered line</font>
    On Error Resume Next
    GetCharacterIndexOfLine = SendMessage(editControl.hwnd, EM_LINEINDEX, lineNumber, 0)
End Function

<b>Public Sub SetImagesOnOrOffInIE(state As Boolean)</b>
<font color="green">'put image loading in ie in the registry back to its original setting on leaving WebbIE</font>
<font color="green">'state is determined by blnIEImages</font>
    On Error Resume Next
    Dim stateString As String ' null-terminated string containing the word "yes" or "no" - i.e. images on/off
    Dim lengthState As Integer
    Dim imagesKey As String ' the key for images on/off in the registry
    Dim result As Long
    Dim hKeyHandle As Long
    
    If state Then
        stateString = "yes" '& Chr(0) ' note null-termination of "yes" string for API call
    Else
        stateString = "no" '& Chr(0) ' note null-termination of "no" string for API call
    End If
    lengthState = Len(stateString)
    imagesKey = "Software\Microsoft\Internet Explorer\Main" ' & Chr(0) ' also null-terminate
    result = RegOpenKey( _
        HKEY_CURRENT_USER, _
        imagesKey, _
        hKeyHandle _
    )
    imagesKey = "Display Inline Images"
    result = RegSetValueEx( _
        hKeyHandle, _
        imagesKey, _
        0, _
        REG_SZ, _
        ByVal stateString, _
        lengthState _
    )
    Call RegCloseKey(hKeyHandle)
    If result &lt;> ERROR_SUCCESS Then MsgBox result
<b>End Sub</b>

<b>Public Function GetImagesOnOrOffInIE() As Boolean</b>
    On Error Resume Next
    Dim stateString As String ' null-terminated string containing the word "no" - i.e. images off
    Dim lengthState As Integer
    Dim imagesKey As String ' the key for images on/off in the registry
    Dim result As Long
    Dim hKeyHandle As Long
    Dim keySize As Long
    Dim initialValue As String
    'first get the original value so we can restore it when we exit
    'also opens the key for writing
    imagesKey = "Software\Microsoft\Internet Explorer\Main" & Chr(0)
    result = RegOpenKey( _
        HKEY_CURRENT_USER, _
        imagesKey, _
        hKeyHandle _
    )
    keySize = 256
    initialValue = String(keySize, 0)
    imagesKey = "Display Inline images" & Chr(0)
    result = RegQueryValueEx(hKeyHandle, imagesKey, RESERVED_NULL, REG_SZ, _
        ByVal initialValue, keySize)
    initialValue = Trim(initialValue)
    'MsgBox initialValue
    If InStr(1, initialValue, "yes") = 1 Then
        GetImagesOnOrOffInIE = True
    Else
        GetImagesOnOrOffInIE = False
    End If
    Call RegCloseKey(hKeyHandle)
    'If result &lt;> ERROR_SUCCESS Then MsgBox result
End Function

<b>Public Function ReadRegistryEntryNumber(hKey As String, regkey As String, itemKey As String) As Long</b>
<font color="green">'returns the value of the registry key indicated by hKey and regKey</font>
    On Error Resume Next
    Dim lengthState As Integer
    Dim result As Long
    Dim hKeyHandle As Long
    Dim keySize As Long
    Dim initialValue As Long
    'first get the original value so we can restore it when we exit
    'also opens the key for writing
    regkey = regkey & Chr(0)
    result = RegOpenKey( _
        hKey, _
        regkey, _
        hKeyHandle _
    )
    'Debug.Print "res1:" & result
    keySize = Len(initialValue)
    itemKey = itemKey & Chr(0)
    result = RegQueryValueEx(hKeyHandle, itemKey, RESERVED_NULL, REG_DWORD, _
        initialValue, keySize)
    'Debug.Print "res2:" & result
    'Debug.Print "Got from registry number: " & initialValue
    Call RegCloseKey(hKeyHandle)
    'If result &lt;> ERROR_SUCCESS Then MsgBox result
    ReadRegistryEntryNumber = initialValue

End Function

<b>Public Function ReadRegistryEntryString(hKey As String, regkey As String, itemKey As String) As String</b>
<font color="green">'returns the value of the registry key indicated by hKey and regKey</font>
<font color="green">'NOTE: be careful when parsing the results, it seems to produce an ANSI version</font>
<font color="green">'overlaying a Unicode version, e.g. "HELLO L O "</font>
    On Error Resume Next
    Dim lengthState As Integer
    Dim result As Long
    Dim hKeyHandle As Long
    Dim keySize As Long
    Dim initialValue As String
    'first get the original value so we can restore it when we exit
    'also opens the key for writing
    regkey = regkey & Chr(0)
    result = RegOpenKey( _
        hKey, _
        regkey, _
        hKeyHandle _
    )
    'Debug.Print "Result1:" & result
    keySize = 256
    initialValue = String(keySize, 0)
    itemKey = itemKey & Chr(0)
    result = RegQueryValueEx(hKeyHandle, itemKey, RESERVED_NULL, REG_SZ, _
        ByVal initialValue, keySize)
        'Debug.Print "Result2:" & result
    'Need to trim the key value since it comes back as a mix of Unicode and
    'ANSI:
    initialValue = Trim(Left(initialValue, keySize - 1))
    'Debug.Print "Got from registry: " & initialValue
    Call RegCloseKey(hKeyHandle)
    'If result &lt;> ERROR_SUCCESS Then MsgBox result
    ReadRegistryEntryString = initialValue
End Function

<b>Public Function GetOnlineStatus() As Boolean</b>
<font color="green">'returns whether the system is currently connected to the Internet</font>
<font color="green">'using InternetGetConnectedStateEx</font>
    On Error Resume Next
    Dim connectionName As String
    Dim connectionNameLength As Long
    Dim connected As Long
    Dim connectionFlags As Long
    Dim pointer As Long
    Dim namePointer As Long

    connectionName = Space(256)
    connectionNameLength = 256
    pointer = StrPtr(connectionName)
    namePointer = VarPtr(connectionNameLength)
    
    'non-zero results indicates connected
    connected = InternetGetConnectedStateEx(connectionFlags, ByVal pointer, ByVal connectionNameLength, 0&)
    If connected &lt;> 0 Then
        GetOnlineStatus = True
    Else
        GetOnlineStatus = False
    End If
End Function

<b>Public Function GetIEHomepage() As String</b>
<font color="green">'returns the url for the home page of the user</font>
    On Error Resume Next
    
    'call getsetting to retrieve the URL
    GetIEHomepage = GetSettingString(HKEY_CURRENT_USER, _
            "Software\Microsoft\Internet Explorer\Main", "Start Page")
End Function

<b>Public Function GetSettingString(hKey As Long, _</b>
strPath As String, strValue As String, Optional _
default As String) As String
<font color="green">'Retrieve a setting from the registry</font>
    On Error Resume Next
    Dim hCurKey As Long
    Dim lResult As Long
    Dim lValueType As Long
    Dim strBuffer As String
    Dim lDataBufferSize As Long
    Dim intZeroPos As Integer
    Dim lRegResult As Long
    
    'If no default was sent, then set up a default value
    If Not IsEmpty(default) Then
        GetSettingString = default
    Else
        GetSettingString = ""
    End If
    
    'expand the registry key and query value of the string in that key
    lRegResult = RegOpenKey(hKey, strPath, hCurKey)
    lRegResult = RegQueryValueEx(hCurKey, strValue, 0&, _
    lValueType, ByVal 0&, lDataBufferSize)
    
    'if this query was successful
    If lRegResult = ERROR_SUCCESS Then
        'if the value is in fact a string
        If lValueType = REG_SZ Then
    
            strBuffer = String(lDataBufferSize, " ")
            lResult = RegQueryValueEx(hCurKey, strValue, 0&, 0&, _
            ByVal strBuffer, lDataBufferSize)
    
            intZeroPos = InStr(strBuffer, Chr$(0))
                If intZeroPos > 0 Then 'return results
                    GetSettingString = Left$(strBuffer, intZeroPos - 1)
                Else
                    GetSettingString = strBuffer
                End If
    
        End If
    
    Else 'if the original query was not successful
<font color="green">'        MsgBox gobjLanguageHandler.GetText("A registry access error has occurred."), vbOKOnly, gobjLanguageHandler.GetText("Registry error")</font>
    End If
    
    'finish by closing the expanded key of the registry
    lRegResult = RegCloseKey(hCurKey)
End Function

<b>Public Sub WriteToLogFile(logentry As String, Optional Path As String)</b>
    On Error Resume Next
    Dim fn As Integer
    fn = FreeFile
    
    If Len(Path) = 0 Then
        If Right(App.Path, 1) = "\" Then
            Path = App.Path
        Else
            Path = App.Path & "\"
        End If
        Path = Path & App.EXEName & ".log"
    End If
    Open Path For Append As #fn
    Write #fn, Now & ": " & logentry
    Close #fn
<b>End Sub</b>

<b>Public Sub CreateLogFile(logentry As String, Optional Path As String)</b>
    On Error Resume Next
    Dim fn As Integer
    fn = FreeFile
    If Len(Path) = 0 Then
        Path = App.Path
        If Right(Path, 1) &lt;> "\" Then Path = Path & "\"
        Path = Path & App.EXEName & ".log"
    End If
    Open Path For Output As #fn
    Write #fn, Now & ": " & logentry
    Close #fn
<b>End Sub</b>

<b>Public Function GetNonRoamingApplicationDirectory() As String</b>
<font color="green">'uses the Windows API to get the path for the application directory,</font>
<font color="green">'Application Data</font>
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL_LOCAL_APPDATA, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to My Documents
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetNonRoamingApplicationDirectory = Path
End Function

<b>Public Function GetMyDocuments() As String</b>
<font color="green">'uses the Windows API to get the path for the user's home directory,</font>
<font color="green">'My Documents.</font>
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL_PERSONAL, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to My Documents
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetMyDocuments = Path
End Function

<b>Public Function GetTempDirectory() As String</b>
<font color="green">'uses the Windows API to get the path for the current temp directory</font>
    On Error GoTo localHandler:
    GetTempDirectory = GetNonRoamingApplicationDirectory
    'This is now ....Local Settings\Application Data, but we want
    '....Local Settings\Temp
    'I'm assuming that these aren't localised!
    GetTempDirectory = Replace(GetNonRoamingApplicationDirectory, "Application Data", "Temp")
    Exit Function
localHandler:
    'MsgBox Err.Number & " " & Err.Description & vbNewLine & Err.Source, vbOKOnly, "Error: GetTempDirectory"
    Resume Next
End Function

<b>Public Function GetRoamingApplicationDirectory() As String</b>
<font color="green">'Uses the Windows API to get the path for the user's roaming profile</font>
    On Error Resume Next
    GetRoamingApplicationDirectory = GetSpecialFolderPath(CSIDL_APPDATA)
End Function

<b>Public Function GetCurrentDateAsRFC822() As String</b>
<font color="green">'returns current date in RFC822 specification</font>
    On Error Resume Next
    Dim datetime As String
    
    datetime = WeekdayName(Weekday(Date), True) & ", "
    datetime = datetime & day(Date) & " "
    datetime = datetime & MonthName(Month(Date), True) & " "
    datetime = datetime & Right(year(Date), 2) & " "
    datetime = datetime & DatePart("h", Now) & ":" & DatePart("n", Now)
    
    GetCurrentDateAsRFC822 = datetime
End Function

<b>Public Function BuildNonRoamingApplicationPath(companyName As String, productName As String, version As String) As String</b>
<font color="green">'returns a Windows-compliant non-roaming application path where you can store</font>
<font color="green">'programme data</font>
    On Error Resume Next
    Dim Path As String
    
    Path = GetNonRoamingApplicationDirectory
    Path = Path & "\" & companyName & "\" & productName & "\" & version
    BuildNonRoamingApplicationPath = Path
End Function

<b>Public Function BuildRoamingApplicationPath(companyName As String, productName As String, version As String) As String</b>
<font color="green">'returns a Windows-compliant nroaming application path where you can store</font>
<font color="green">'programme data</font>
    On Error Resume Next
    Dim Path As String
    
    Path = GetRoamingApplicationDirectory
    Path = Path & "\" & companyName & "\" & productName & "\" & version
    BuildRoamingApplicationPath = Path
End Function

<b>Public Sub CreateNonRoamingApplicationPath(companyName As String, productName As String, version As String)</b>
<font color="green">'returns a Windows-compliant non-roaming application path where you can store</font>
<font color="green">'programme data</font>
    On Error Resume Next
    Call CreateApplicationPath(GetSpecialFolderPath(CSIDL_LOCAL_APPDATA), companyName, productName, version)
<b>End Sub</b>

<b>Public Sub CreateRoamingApplicationPath(companyName As String, productName As String, version As String)</b>
    On Error Resume Next
    Call CreateApplicationPath(GetSpecialFolderPath(CSIDL_APPDATA), companyName, productName, version)
<b>End Sub</b>

<b>Private Sub CreateApplicationPath(rootPath As String, companyName As String, productName As String, version As String)</b>
    On Error Resume Next
    Dim Path As String
    Dim fso As FileSystemObject
    
    Set fso = New FileSystemObject
    Path = rootPath & "\" & companyName
    If Not fso.FolderExists(Path) Then
        Call fso.CreateFolder(Path)
    End If
    Path = Path & "\" & productName
    If Not fso.FolderExists(Path) Then
        Call fso.CreateFolder(Path)
    End If
    Path = Path & "\" & version
    If Not fso.FolderExists(Path) Then
        Call fso.CreateFolder(Path)
    End If
<b>End Sub</b>

<b>Public Function GetUserHomeDirectory() As String</b>
    On Error Resume Next
    GetUserHomeDirectory = GetSpecialFolderPath(CSIDL_PERSONAL)
End Function

<b>Public Function GetLocalApplicationDirectory() As String</b>
    On Error Resume Next
    GetLocalApplicationDirectory = GetSpecialFolderPath(CSIDL_LOCAL_APPDATA)
End Function

<b>Public Function GetApplicationDirectory() As String</b>
    On Error Resume Next
    GetApplicationDirectory = GetSpecialFolderPath(CSIDL_APPDATA)
End Function

<b>Public Sub ShutDownWindows()</b>
    On Error Resume Next
    'Shutdown Windows XP
    Call Shell("shutdown -s -f -t 0")
<b>End Sub</b>

<b>Public Function GetUserDirectory() As String</b>
<font color="green">'uses the Windows API to get the path for the user's home directory,</font>
<font color="green">'My Documents.</font>
    On Error Resume Next
    GetUserDirectory = GetSpecialFolderPath(CSIDL_PERSONAL)
End Function

<b>Public Function GetSpecialFolderPath(CSIDL As Long) As String</b>
<font color="green">'returns the special folder indicated by the CSIDL constant</font>
    On Error Resume Next
    Dim Path As String
    Dim result As Long
    Dim referenceID As Long
    
    'work out where to save them to:
    Path = Space(260)
    result = SHGetSpecialFolderLocation(0, CSIDL, referenceID)
    result = SHGetPathFromIDList(referenceID, Path)
    'assertion: path now contains path to special folder
    Path = Trim(Path)
    'take off final null character which trim has left behind
    Path = Replace(Path, Chr(0), "")
    'return
    GetSpecialFolderPath = Path
End Function

<b>Public Function GetNumlockState() As Boolean</b>
    On Error Resume Next
    Dim O As OSVERSIONINFO
    Dim keys(0 To 255) As Byte
    
    O.dwOSVersionInfoSize = Len(O)
    Call GetVersionEx(O)
    Call GetKeyboardState(keys(0))
    GetNumlockState = CBool(keys(VK_NUMLOCK))
End Function

<b>Public Sub SetNumlockState(state As Boolean)</b>
<font color="green">'See http://support.microsoft.com/kb/177674/</font>
    On Error Resume Next
    Dim O As OSVERSIONINFO
    Dim NumLockState As Boolean
    Dim keys(0 To 255) As Byte
   
    O.dwOSVersionInfoSize = Len(O)
    Call GetVersionEx(O)
    Call GetKeyboardState(keys(0))
    ' NumLock handling:
    NumLockState = keys(VK_NUMLOCK)
    If NumLockState = state Then
        'already in correct state
    Else
        'need to change
        If O.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS Then  '=== Win95/98
            keys(VK_NUMLOCK) = IIf(state, 1, 0)
            Call SetKeyboardState(keys(0))
        ElseIf O.dwPlatformId = VER_PLATFORM_WIN32_NT Then   '=== WinNT
            'Simulate Key Press
            Call keybd_event(VK_NUMLOCK, &H45, KEYEVENTF_EXTENDEDKEY Or 0, 0)
            'Simulate Key Release
            Call keybd_event(VK_NUMLOCK, &H45, KEYEVENTF_EXTENDEDKEY _
             Or KEYEVENTF_KEYUP, 0)
        End If
    End If
<b>End Sub</b>

<b>Public Sub CreateShortcut(targetFile As String, shortcutFile As String)</b>
<font color="green">'creates a shortcut at shortcutFile to the targetFile</font>
<font color="green">'see http://www.melbpc.org.au/pcupdate/2206/2206article14.htm</font>
    On Error Resume Next
    Dim ws As Object ' WshShell
    Dim newShortcut As Object
    
    Set ws = CreateObject("WScript.Shell", "")   'New WshShell
    Set newShortcut = ws.CreateShortcut(shortcutFile)
    newShortcut.TargetPath = targetFile
    Call newShortcut.save
<b>End Sub</b>

<b>Public Function GetLocaleInformation(locale As Long, query As Long) As String</b>
<font color="green">'returns locale info from GetLocaleInfo: locale should be one of modshared</font>
<font color="green">'modshared.LOCALE_SYSTEM_DEFAULT or modshared.LOCALE_USER_DEFAULT,</font>
<font color="green">'query can be one of modshared.LOCALE_ constants</font>
    On Error Resume Next
    Dim result As String
    Dim resultLength As Long
    
    result = Space(255)
    resultLength = Len(result)
    Call GetLocaleInfo(locale, query, result, resultLength)
    'Debug.Print "r:" & result
    result = Replace(result, Chr(0), Empty)
    GetLocaleInformation = Trim(result)
End Function

<b>Public Function GetSystemFontName() As String</b>
<font color="green">'returns the system font name</font>
<font color="green">'See http://www.freevbcode.com/ShowCode.Asp?ID=208</font>
    On Error Resume Next
    Dim s As String
    Dim i As Byte
    Dim ncm As NONCLIENTMETRICS
    Dim sdfont As StdFont
    
    ncm.cbSize = Len(ncm)
    If SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, ncm, 0) Then
        s = StrConv(ncm.lfCaptionFont.lfFaceName, vbUnicode)
        i = InStr(s, vbNullChar)
        If i > 0 Then s = Left(s, i - 1)
    End If
    GetSystemFontName = s
End Function

<b>Public Function GetSystemFontSize() As Long</b>
<font color="green">'returns the system font size: lets you know if the system is using small</font>
<font color="green">'fonts or not.</font>
<font color="green">'See http://www.developerfusion.co.uk/show/275/</font>
    On Error Resume Next
    Dim hdc, hwnd, PrevMapMode As Long
    Dim tm As TEXTMETRIC

    ' Set the default return value to small fonts
    'gbl_GetFontRes$ = &quot;VGA&quot;

    ' Get the handle of the desktop window
    hwnd = GetDesktopWindow()

    ' Get the device context for the desktop
    hdc = GetWindowDC(hwnd)
    If hdc Then
        ' Set the mapping mode to pixels
        PrevMapMode = SetMapMode(hdc, MM_TEXT)

        ' Get the size of the system font
        Call GetTextMetrics(hdc, tm)

        ' Set the mapping mode back to what it was
        PrevMapMode = SetMapMode(hdc, PrevMapMode)

        ' Release the device context
        Call ReleaseDC(hwnd, hdc)

        ' If the system font is more than 16 pixels high,
        ' then large fonts are being used
        GetSystemFontSize = tm.tmHeight
    End If
End Function

<font color="green">'Launch a url in the system's default web browser (E.g. IE)</font>
<b>Public Function OpenURLInWebBrowser(url As String) As Long</b>
    On Error Resume Next
    OpenURLInWebBrowser = ShellExecute(0&, "open", url, "", "", SW_SHOW)
End Function

<font color="green">'Public Sub ApplyLargeFonts()</font>
<font color="green">''iterates through application applying large fonts to the</font>
<font color="green">''application's forms</font>
<font color="green">'Oh wait, need to write code to detect large fonts! Screen.TwipsPerThing</font>
<font color="green">'doesn't hack it. Doesn't change. Need to use GetDeviceCaps</font>
<font color="green">'    On Error Resume Next</font>
<font color="green">'    Dim controlIterator As Control</font>
<font color="green">'    Dim formIterator As Form</font>
<font color="green">'    Dim largeFonts As Boolean</font>
<font color="green">'    Dim extraLargeFonts As Boolean</font>
<font color="green">'</font>
<font color="green">'    'have we got large fonts?</font>
<font color="green">'    If Screen.TwipsPerPixelY > 14 Then</font>
<font color="green">'        largeFonts = True</font>
<font color="green">'    Else</font>
<font color="green">'    End If</font>
<font color="green">'</font>
<font color="green">'    If largeFonts Then</font>
<font color="green">'        For Each formIterator In Forms</font>
<font color="green">'            For Each controlIterator In formIterator.Controls</font>
<font color="green">'                Select Case TypeName(controlIterator)</font>
<font color="green">'                    Case "ListBox"</font>
<font color="green">'</font>
<font color="green">'                End Select</font>
<font color="green">'            Next controlIterator</font>
<font color="green">'        Next formIterator</font>
<font color="green">'    End If</font>
<font color="green">'End Sub</font>
<font color="green">'</font>

<b>Public Sub OpenControlPanel(cplFilename As String, Optional arguments As String = "")</b>
<font color="green">'see http://www.vbcode.com/Asp/showsn.asp?theID=11982</font>
<font color="green">'Runs the control panel applet specified by cplFilename (e.g. inetcpl.cpl)</font>
<font color="green">'with optional arguments arguments. It's up to the calling code to add any</font>
<font color="green">'commas to arguments, e.g. ", panel=6", since some control panel applets</font>
<font color="green">'may not take them.</font>
    On Error Resume Next
    Dim commandLine As String
    
    commandLine = "Rundll32.exe Shell32.dll,Control_RunDLL " & cplFilename & _
        " " & arguments
    Call Shell(commandLine)
<b>End Sub</b>

<b>Public Sub SetFontToSystemFont()</b>
<font color="green">'iterate through the entire application setting the font to the system default</font>
    On Error Resume Next
    Dim f As Form
    Dim c As Control
    Dim systemFont As String
    Dim systemSize As Long
    
    systemFont = GetSystemFontName
    systemSize = GetSystemFontSize
    For Each f In Forms
        f.FontSize = systemSize
        f.FontName = systemFont
        For Each c In f.Controls
            Select Case TypeName(c)
                Case "CheckBox"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "CommandButton"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "Frame"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "Label"
                    c.FontSize = systemSize
                    c.FontName = systemFont
                Case "OptionButton"
                    c.FontSize = systemSize
                    c.FontName = systemFont
            End Select
        Next c
    Next f
<b>End Sub</b>

<b>Public Function StripTerminator(ByVal strString As String) As String</b>
    On Error Resume Next
<font color="green">'used in processing the results of ini file reads</font>
    Dim intZeroPos As Integer

    intZeroPos = InStr(strString, Chr$(0))
    If intZeroPos > 0 Then
        StripTerminator = Left$(strString, intZeroPos - 1)
    Else
        StripTerminator = strString
    End If
End Function

<font color="green">'-----------------------------------------------------------</font>
<font color="green">' FUNCTION: ReadIniFile</font>
<font color="green">'</font>
<font color="green">' Reads a value from the specified section/key of the</font>
<font color="green">' specified .INI file</font>
<font color="green">'</font>
<font color="green">' IN: [strIniFile] - name of .INI file to read</font>
<font color="green">'     [strSection] - section where key is found</font>
<font color="green">'     [strKey] - name of key to get the value of</font>
<font color="green">'</font>
<font color="green">' Returns: non-zero terminated value of .INI file key</font>
<font color="green">'-----------------------------------------------------------</font>
<font color="green">'</font>
<b>Public Function SharedReadIniFile(ByVal strIniFile As String, ByVal strSECTION As String, ByVal strKey As String) As String</b>
    On Error Resume Next
    Dim strBuffer As String
    Dim intPos As Integer
    Dim emptyS As String

    '
    'If successful read of .INI file, strip any trailing zero returned by the Windows API GetPrivateProfileString
    '
    strBuffer = Space$(256)
    strSECTION = strSECTION & Chr(0)
    strKey = strKey & Chr(0)
    emptyS = "" & Chr(0)
    strIniFile = strIniFile & Chr(0)
    If GetPrivateProfileString(strSECTION, strKey, emptyS, strBuffer, Len(strBuffer) - 1, strIniFile) > 0 Then
        SharedReadIniFile = Left(strBuffer, InStr(strBuffer, Chr(0)) - 1)
<font color="green">'    If GetPrivateProfileString(strSECTION, strKey, gstrNULL, strBuffer, gintMAX_SIZE, strIniFile) > 0 Then</font>
<font color="green">'        ReadIniFile = RTrim$(StripTerminator(strBuffer))</font>
    Else
        SharedReadIniFile = gstrNull
    End If
End Function

<b>Public Function SharedReadIniFileDefault(ByVal strIniFile As String, ByVal strSECTION As String, ByVal strKey As String, default As String) As String</b>
    On Error Resume Next
    Dim strBuffer As String
    Dim intPos As Integer

    '
    'If successful read of .INI file, strip any trailing zero returned by the Windows API GetPrivateProfileString
    '
    strSECTION = strSECTION & Chr(0)
    strKey = strKey & Chr(0)
    strIniFile = strIniFile & Chr(0)
    default = default & Chr(0)
    strBuffer = Space$(256)
    If GetPrivateProfileString(strSECTION, strKey, default, strBuffer, Len(strBuffer) - 1, strIniFile) > 0 Then
        SharedReadIniFileDefault = Left(strBuffer, InStr(strBuffer, Chr(0)) - 1)
<font color="green">'    If GetPrivateProfileString(strSECTION, strKey, gstrNULL, strBuffer, gintMAX_SIZE, strIniFile) > 0 Then</font>
<font color="green">'        ReadIniFile = RTrim$(StripTerminator(strBuffer))</font>
    Else
        SharedReadIniFileDefault = default
    End If
End Function

<b>Public Function WriteIniFile(ByVal strIniFile As String, ByVal section As String, ByVal setting As String, ByVal value As String)</b>
    On Error Resume Next
    strIniFile = strIniFile & Chr(0)
    section = section & Chr(0)
    setting = setting & Chr(0)
    value = value & Chr(0)
    Call WritePrivateProfileString(section, setting, value, strIniFile)
End Function

<b>Public Function ReadFile(ByRef strFile As String) As String</b>
    On Error GoTo exitReadFile:
    Dim intFileNumber As Long
    intFileNumber = FreeFile
    Open strFile For Binary As #intFileNumber
    ReadFile = Space(LOF(intFileNumber))
    Get #intFileNumber, , ReadFile
    Close #intFileNumber
exitReadFile:
 
End Function

<b>Public Function ConvertWindowsToCSSColours(windowsColour As String) As String</b>
    On Error Resume Next
<font color="green">'converts a Windows colour (BGR) to CSS (RGB)</font>
    Dim newColour As String
    Dim hexColour As String
    hexColour = Hex(windowsColour)
    newColour = String(6 - Len(hexColour), "0") & hexColour
    ConvertWindowsToCSSColours = "#" & Right(newColour, 2) & Mid(newColour, 3, 2) & Left(newColour, 2)
End Function

<b>Public Function MakePathSafe(Path As String) As String</b>
<font color="green">'Returns a path with invalid characters removed.</font>
    On Error Resume Next
    Dim suggestedName As String
    suggestedName = Path
    suggestedName = Replace(suggestedName, vbNewLine, "")
    suggestedName = Replace(suggestedName, vbCr, "")
    suggestedName = Replace(suggestedName, vbLf, "")
    suggestedName = Replace(suggestedName, "\", "_")
    suggestedName = Replace(suggestedName, "/", "_")
    suggestedName = Replace(suggestedName, ":", "_")
    suggestedName = Replace(suggestedName, "*", "_")
    suggestedName = Replace(suggestedName, "?", "_")
    suggestedName = Replace(suggestedName, """", "_")
    suggestedName = Replace(suggestedName, "&lt;", "_")
    suggestedName = Replace(suggestedName, ">", "_")
    suggestedName = Replace(suggestedName, "|", "_")
    suggestedName = Trim(suggestedName)
    MakePathSafe = suggestedName
End Function

</pre>
<h2>Module modVersion</h2>
<p>Filename: ..\Common\modVersion.bas</p><p>Date last modified: Fri May 2009 18:20</p><!-- 
Attribute VB_Name = "modVersion"
'modVersion

'Finds out the installation version of the suite by reading version.ini

Option Explicit

Private Declare Function GetPrivateProfileStrPackageVersion Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long

Public Function GetPackageVersion() As String
    On Error Resume Next
    Dim s As String
    s = Space(255)
    Call GetPrivateProfileStrPackageVersion("Package", "Version", "", s, Len(s), App.Path & "\version.ini")
    s = Replace(s, Chr(0), " ")
    GetPackageVersion = Left(s, InStr(1, s, " ") - 1)
End Function

-->
<pre id="0">
Option Explicit

Private Declare Function GetPrivateProfileStrPackageVersion Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long

<b>Public Function GetPackageVersion() As String</b>
    On Error Resume Next
    Dim s As String
    s = Space(255)
    Call GetPrivateProfileStrPackageVersion("Package", "Version", "", s, Len(s), App.Path & "\version.ini")
    s = Replace(s, Chr(0), " ")
    GetPackageVersion = Left(s, InStr(1, s, " ") - 1)
End Function

</pre>
</body></html>